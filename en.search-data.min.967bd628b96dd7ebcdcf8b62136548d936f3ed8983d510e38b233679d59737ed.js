'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/school/html/','title':"Html",'content':"Введение в HTML #  По мере написания будут появляться новые главы. Творческих успехов и вам.\nВведение\n"});index.add({'id':1,'href':'/school/java/','title':"Java",'content':"Java #  К данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки.  "});index.add({'id':2,'href':'/school/java/basic-course/001-java-setup/','title':"001 Java Setup",'content':"HelloWorld.java — первая программа на Java — введение в Java 001 #  Установка JDK #  В интернете существуют тысячи инструкций по установке окружения для работы в Java.\nЯ уверен, что вы сможете вбить в Google запрос на английском: \u0026ldquo;How to Install Java Development Kit\u0026rdquo; или на русском: \u0026ldquo;Установка JDK\u0026rdquo;. Java принадлежит фирме Oracle и можно сразу скачать Java с её страниц, скачав просто JDK, скачав Netbeans вместе с JDK или скачав открытую AdoptOpenJDK (предпочтительнее для новичков).\nЕсли нет, то я попробую рассказать основное: что нам надо, и где это взять.\nUpdate: 29.08.2020\nJava Development Kit #  JDK — это программа, которая будет переводить написанный вами код в понятный для машин. На вашей машине может быть установлено несколько разных версий Java. Одной из них должна быть Java 8.x. Это та версия, на которой базируются все современные версии, и для изучения основ языка и ООП именно оно нам и \u0026ldquo;нада\u0026rdquo;.\nСкачать JDK можно с AdoptOpenJDK:   Скачать AdoptOpenJDK   Скачать JDK можно с Oracle:   JDK download Oracle   Уверен, вы справитесь с установкой этой программы самостоятельно или с помощью Google.\nРабота с Java #  Работа с Java \u0026ldquo;по старинке\u0026rdquo;.\nВо всех языках программирования стало стандартом первым уроком выводить на экране строчки \u0026ldquo;HelloWorld!\u0026rdquo;.\nКто я такой, что бы идти против правил? Сегодня мы напишем нашу первую программу и выведем на экран \u0026ldquo;Привет Мир!\u0026rdquo;.\nМы создаём файл в редакторе(эдиторе) и сохраняем его под названием HelloWorld.java\n/** * Created by www.andron13.de on 27.12.2016. **/ public class HelloWorld { // Начало нашего класса HelloWorld  public static void main(String[] args) { // Начинаем наш метод, главный метод (мэйн)  System.out.print(\u0026#34;Привет \u0026#34;); System.out.println(\u0026#34;Мир! :-)\u0026#34;); System.out.println(\u0026#34;\\t Hello World!!!\u0026#34;); } // Закрываем главный метод } // Закрываем класс Сразу обращаем внимание на два слеша (слэш, слеш, а также slash, с англ. — «разрез, порез», «резкий удар», «косая черта»), которыми в конце строки можно отделить пометки в тексте. Также комментировать код можно, выделив его с двух сторон звёздочкой и слешем вот так: /* комментарий тут */. Комментарии в коде очень важны. Уже пару дней спустя не всегда очевидны некоторые решения и названия переменных. В иной программе может быть с десяток классов и в каждом — по несколько переменных. И все они что-то там считают, куда-то там что-то передают и зачем-то все вот прям здесь, и \u0026ldquo;кто это вообще написал\u0026rdquo;. Не стесняйтесь комментировать свой код и свои решения. Привычка писать \u0026ldquo;понятный\u0026rdquo; код поможет вам и в учёбе, и в работе.\nЗапускаем терминал или командную строку под Windows: Cтарт-\u0026gt; CMD-\u0026gt; Выполнить.\nКомпилируем и запускаем код:\njavac HelloWorld.java // или javac -encoding utf8 HelloWorld.java // и запускаем с помощью java HelloWorld Внимание - параметр -encoding сработал не во всех версиях JDK на 2.07.2020. Версии от Oracle поддерживают код выше.\n  терминал   С помощью javac мы создаём из нашей программы код, понятный машине. Не считаю нужным углубляться в детали этого процесса, но и ничто не мешает вам почитать о:\n байт-коде, компиляторе, JVM, SDK, JDK  на других полезных ресурсах. История JVM (Java Virtual Machine) очень интересна, ведь ей уже более 20 лет.\nПри запуске мы увидим все системные сообщения на экране. Изменяя параметры программы, мы изменяем результаты. Это и есть программирование. И мы только что написали нашу первую программу.\nЕсли у вас не прошла компиляция, как у меня, попробуйте скомпилировать с помощью учёта кодировки. Кириллица до сих пор не всегда хорошо работает в терминалах Windows. Если у вас не прошла компиляция вообще, то проверьте параметры настроек Java под Windows.\nНе забывайте, что вы должны находиться в той папке, которая внесена в настройках в рабочие Java_Home.\nВ AdoptOpenJDK можно при инсталляции пакета указать на установку Java_Home.\nУстановка Adopt Open JDK:   установка AdoptOpenJDK   Если у вас всё получилось — поздравляю! Вы только что поняли, как именно работали первые Java-кодеры.\nЕсли у вас не всё получилось — не расстраивайтесь. В следующих уроках я подробнее расскажу, как удобнее работать с программами без командной строки и ручной компиляции. Вы можете спокойно переходить ко второму и третьему уроку. С ними всё встанет на свои места.\nСреда разработки Java — выбираем IDE программирования #  Среда разработки Java: Android Studio, IntelliJ IDEA, NetBeans IDE, Eclipse Java Neon\u0026hellip;\nПервую программу на Java я написал в обычном эдиторе на Solaris. Потом компилировал \u0026ldquo;ручками\u0026rdquo;. И запускал тоже ручками, примерно так, как было описано выше. И радовался тогда, очень радовался, если компилятор не выдавал ошибки и, уж тем более, испытывал настоящий восторг, если приложение делало, то что я и хотел. Позже я помню дотошную настройку под Windows 95. С внесением рабочей Java-папки в переменную среду пользователя.Поверьте на слово, порой я настраивал эти переменные среды часами.\nБыло много чего испробовано:\n UltraEdit Notepad и Notepad++ PHP Expert Editor Visual Studio Code Sublime Text и многие другие  Но время редакторов и даже очень хороших редакторов прошло, и если для очень быстрых вещей, особенно за чужим компьютером, я с удовольствием использую портабельный \u0026ldquo;Notepad++\u0026rdquo; с флэшки, то дома я работаю в другой среде. Не в редакторе. А именно среде. И с объяснения термина \u0026ldquo;интегрированная среда разработки\u0026rdquo; мы и начнём.\nИнтегрированная среда разработки - IDE #  Программа для написания кода должна упрощать жизнь программиста и ускорять его работу, например:\n \u0026ldquo;подсвечивать\u0026rdquo; нужные фрагменты, скобки, переменные и т.д. и давать возможность настроить или отключить часть подсветки; подсказывать или \u0026ldquo;автозаполнять\u0026rdquo; код программисту, угадывать, если хотите, что именно он хочет написать; возможность менять дизайн отображения кода; быстро и чётко показывать результат; быстро переключаться между проектами; \u0026ldquo;самостоятельно\u0026rdquo; контролировать версии (например закидывать всё на GIT); помогать найти ошибки в коде и, тем более, синтаксические и орфографические ошибки; и многое другое.  Понятно, что всё это не про Notepad и даже не про Notepad++, хотя с подсветкой справляются многие \u0026ldquo;мелкие\u0026rdquo; редакторы. На рынке сейчас есть несколько крупных программ, которые заявляют себя как JAVA-IDE: это Eclipse (Eclipse Java Neon), IntelliJ IDEA (от JetBrains), NetBeans IDE (от Oracle), Android Studio (от Google \u0026amp; JetBrains).\nДавайте я скажу по \u0026ldquo;два слова\u0026rdquo; о каждой из них:\nAndroid Studio #  Android Studio — основан на IntelliJ IDEA с добавлениями, которые нужны при работе с android приборами. И, на самом деле, это среда разработки под Android на Java. И, говоря о плюсах или минусах, мы всё равно обсуждаем IntelliJ IDEA.\nNetBeans IDE #  NetBeans IDE — рабочая среда от владельцев Java. Можно программировать, есть подсказка, есть подсветка. С моей точки зрения, это очень тяжёлый Notepad++ со встроенным компилятором. Но, на самом деле, NetBeans совсем не так уж плох. И не надо забывать, что он бесплатный и предоставляется компанией, которой принадлежат права на Java.\nIntelliJ IDEA #  IntelliJ IDEA — редактор, утверждающий, что это IDE для Java и всех JVM-языков. Вполне возможно, что это так. Есть бесплатная версия и платная расширенная версия для Java EE (Java Platform, Enterprise Edition). Думаю, что многим будет важно узнать, что программу делают русскоязычные ребята.\nEclipse #  Eclipse — среда разработки для всего. Всех языков, всех платформ. Очень старая программа. Примерно треть всех разработчиков Java сидят в этой программе. Программа выросла из внутренних разработок фирмы IBM и, действительно, известна всем. На мой взгляд, главный конкурент любой среде разработки.\nVisual Studio Code #  Visual Studio Code — изначально этот эдитор не был описан в этой статье. Однако, со временем, я всё чаще и чаще писал программы и документацию именно в нём. Мощный эдитор с огромным комъюнити и огромнейшим количеством полезных плагинов для всех видов разработки.\nЯ использую на работе NetBeans IDE, а дома IntelliJ IDEA и, на самом деле, вы не всегда можете контролировать то, в какой среде вы будете работать. Бывают ситуации, когда работать приходится просто в блокноте. Я веду к тому, что ознакомиться стоит со всеми программами и быть готовым к тому, что их придётся использовать.\nПрежде чем выбирать окончательное решение, стоит поставить, может быть, все IDE и решить самому. Я лично надеюсь, что и Eclipse, и IntelliJ IDEA, NetBeans IDE будут чувствовать себя хорошо и жить долго, чтобы мы могли наслаждаться качеством конкуренции.\nЯ считаю, что в 2020-м году стоит начать с адекватной программы, и мой выбор падает на бесплатную intellij idea community edition, именно в ней будут даны первые уроки.\nУстановка и настройка IntelliJ IDEA для работы в Java #  IntelliJ IDEA — среда разработки программного обеспечения, сделанная в Кронштадте Санкт-Петербурге. Отличие среды разработки(IDE) от редакторов в том, что среда разработки должна \u0026ldquo;предугадывать\u0026rdquo; мысли и действия программиста. Можно, пожалуй, сравнить обычную бумажную записную книжку с телефонами друзей и электронную в телефоне. Удобство пользования электронной намного выше.\nПовторюсь, что, прежде всего, у разработчика должна быть установлена на компьютере восьмая и/или актуальная версия JDK. На данный момент за Java Development Kit отвечает Oracle и у него можно скачать актуальную версию тут. На момент написания статьи это была версия 8.02, и скачать её можно было как отдельно от NetBeans IDE 8.2, так и вместе. Я выбрал JDK 8u111 with NetBeans 8.2. Я очень надеюсь, что будущему разработчику не надо объяснять, какой кнопочкой скачивать из интернета. После установки JDK можно перейти к IntelliJ IDEA.\nIntelliJ IDEA можно скачать на сайте www.jetbrains.com/idea/. Пожалуй, стоит знать, что там же качается и PhpStorm для php и PyCharm для Python.\nIntelliJ IDEA есть в двух версиях — в бесплатной Community и платной Ultimate. Обе версии бывают только на одном языке, и это не русский. Для введения в Java бесплатная версия ничем не хуже платной. Различия в версиях можно посмотреть на сайте производителя перед скачиванием.\nЕсли вам жизненно необходима Ультимативная версия, то не скачивайте \u0026ldquo;лекарство\u0026rdquo;, не ломайте софт и не прописывайте левый сервер в лицензиях. Вы не сможете обновиться, а обновления бывают достаточно часто. Просто скачайте ультимативную версию и закажите себе бесплатные студенческие логины. Подробности студенческой лицензии тут — www.jetbrains.com/student/. IDEA нет на русском языке. Если русский язык очень важен, то у вас есть возможность работать с русским интерфейсом на NetBeans.\nПри установке можно для начала согласиться со всеми настройками по умолчанию и дойти до создания нового проекта. Проектов может быть множество. Например, игра для андроид-приборов или прошивка для \u0026ldquo;умного холодильника\u0026rdquo;. Предположу, что вы не знаете, как будет называться ваша первая программа, поэтому можете назвать проект \u0026ldquo;myFirstJavaProject\u0026rdquo;, \u0026ldquo;JavaBeginner\u0026rdquo; или \u0026ldquo;JavaFromAndron13\u0026rdquo;. Название можно поменять позже, проект можно удалить или перенести файлы из проекта в проект, и поэтому над названием можно особо долго не думать. Желательно, что б оно было говорящее само за себя. На случай если у вас будет 20-30 или даже 1000 проектов.\nДомашнее задание #   Поиграйтесь с выводом строчек в своей среде разработки и попробуйте написать нормальное предложение.  Пример выполненного домашнего задания:  public class HelloWorld { // Начало нашего класса HelloWorld  public static void main(String[] args) { // Начинаем наш метод, главный метод (мэйн)  System.out.print(\u0026#34;Привет \u0026#34;); System.out.println(\u0026#34;Мир! :-)\u0026#34;); System.out.println(\u0026#34;\\t Hello World!!!\u0026#34;); System.out.print(\u0026#34;\\t И ещё строчка :-)\u0026#34;); System.out.print(\u0026#34;Это моя первая программа \\n\u0026#34; ); System.out.print(\u0026#34;\\u0423\\u0440\\u0430 \\n\u0026#34;); System.out.println(\u0026#34;- Mein erstes Programm :-)\u0026#34;); //моя первая программа  } // Закрываем главный метод } // Закрываем класс  Удалите все комментарии из кода и запустите снова. Научитесь быстро находить и печатать следующие символы(они все нам понадобятся при изучении Java) - \u0026#34;() {} [] ^^ || \u0026amp;\u0026amp; %% __ -- ++ ** // \\\\ \u0026#39;\u0026#39; ~~ ;; :: ,, .. \u0026lt;\u0026gt; == !=\u0026#34;  В строке выше 22 пары символов. У вас 22 секунды на написание этой строки самостоятельно.  Дополнительные материалы #   List of Unicode characters https://en.wikipedia.org/wiki/List_of_Unicode_characters  "});index.add({'id':3,'href':'/school/java/exercises/','title':"Exercises",'content':"Задачи для курса введение в веб-программирование. #  "});index.add({'id':4,'href':'/school/tools/','title':"Tools",'content':"Java #  К данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки.  "});index.add({'id':5,'href':'/school/java/basic-course/026-java-string-stringbuffer-stringbuilder/','title':"StringBuffer, StringBuilder и String в чём отличие",'content':"#String, StringBuffer и StringBuilder — введение в Java 026\nНас уже не должны пугать ключевые слова с большой буквы. Нам известны как минимум два из них String и Scanner. StringBuffer и StringBuilder родные братья уже давно изученного типа данных String.\nЧем был плох String? #  String всем прекрасен, только он неизменяем (immutable). И операции со строковыми величинами иногда дороги в потреблении ресурсов. Например, если мы в цикле изменяем строку добавляя к ней символы. Java каждый раз создаёт новый String. Пример:\npublic class MyString { public static void main(String[] args) { triangle(10); } private static void triangle(int n) { String star = \u0026#34;*\u0026#34;; String row = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { row = row + star; System.out.println(row); } } } Короткая рекомендация - использовать String для редко изменяемых переменных. Например для имени, фамилии, адреса пользователя.\nStringBuffer и StringBuilder, почему сразу два новых типа? #  StringBuffer и StringBuilder абсолютно идентичные классы и их следует использовать для часто изменяемых строк. Различие в том, что\nStringBuffer синхронизированный(synchronized) и потокобезопасный. StringBuilder однопоточный и не потокобезопасный.\nЧто такое синхронизация, коротко #  Представьте, что вы пишите приложение для продажи ЖД-билетов. И вы не можете дважды продать одно место. Синхронизация блокирует метод, если один из потоков его запустил. То есть в многопоточном приложении доступ к продаже ведётся поочерёдно. В однопоточном приложении доступ разрешается всем сразу. Совсем коротко, синхронизация более дорогая в ресурсах, но по другому проблему доступа решить не всегда возможно.\nhttps://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java https://metanit.com/java/tutorial/7.3.php\n- [26 - StringBuffer](/school/java/basic-course/026-java-string-stringbuffer-stringbuilder/) "});index.add({'id':6,'href':'/school/html/02-html-hello-world/','title':"Введение в HTML - HelloWorld",'content':"Теперь мы попробуем приветствовать мир\nПривет-мир #   Создаём рабочую папку В папке создаём файл \u0026ldquo;first-page.html\u0026rdquo;  Если у вас проблемы с созданием файла с расширением html, то вам нужны курсы по компьютерной грамотности и с интернетом пока стоит повременить. Вы можете, конечно, попробовать создать этот файл с помощью запроса в google \u0026ldquo;как создать html файл\u0026rdquo;. Рекомендую параллельно к этому пособию вообще нагугливать термины и объяснения из альтернативных источников. А вдруг я не прав, а вдруг всё уже поменялось?   Открываем в редакторе вашего выбора наш файл. И пишем в нём ручками код.   helloworld   Что бы привести код в порядок и красиво его отформатировать - мы можем спросить у google как - \u0026ldquo;How do you format code in Visual Studio Code\u0026rdquo;. На первом месте (скорее всего) у вас будет сайт stackoverflow.com. Этот сайт помог не одному программисту в тяжёлой ситуации. Не стесняйтесь им пользоваться. Просто иногда задавайтесь вопросом: \u0026ldquo;Кто вы без этого сайта и сможете ли вы без него повторить то, что узнали?\u0026rdquo;  Сохраняем наш файл и открываем с помощью браузера. Если всё пошло так, то мы в Chromo-подобном браузере мы увидим:\n  helloworld в хромиуме   А в интернет эксплорере скорее всего:\n  helloworld в IE   И мы сразу же можем начинать ругать IE потому что он неправильно отображает страницы. Ну или дядю Андрея, потому что он специально не дал ещё одну строчку.\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; Мы добавляем её так, что бы она оказалась седьмой. Вот так:\n  helloworld с UTF   Сохраняемся и проверяем в Интернет Эксплорере наш файл заново:\n  Проверка страницы в IE   Так что же мы написали #  Давайте начнём с конца. \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; это то, что должно стоять в вашем HTML коде всегда. Это указание браузеру, что на странице используется не только английская кодировка. Существует множество разных кодировок кроме utf-8. Пока можете не углублять свои познания и просто пишите это строчку всегда.\nТо что IE-7 в итоге отобразил нашу страшненькую страницу, не значит, что мы его простили. Я держу его только для того, что бы посмотреть время от времени какой oн ужасный. Раз мы уже коснулись браузеров - вам придётся поставить маленький зоопарк: Chrome, Firefox, Safari, Opera. Хотя с большего и хром, и опера, и фаерфокс это один и тот же браузер. Ну почти. Движок у них общий - chromium. этот зоопарк нужен для проверки работоспособности ваших приложений(web-apps) в различных ситуациях.\n\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; - это на самом деле 3 указания. Во-первых, мета обозначает, что сейчас пойдёт указание для браузера, которое не видно пользователю. Чисто техническая информация. Во-вторых, идёт указание о роде технической информации - charset. И, в-третьих, уже значение чарсета utf-8.\nНо вернёмся к написанному.\nDTD - Document Type Definition #  \u0026lt;!DOCTYPE html\u0026gt; - говорит браузеру, что сейчас начнётся документ написанный в HTML5. Браузер не обладает интеллектом и ему надо говорить, что он должен делать. И именно доктайп говорит, что сейчас надо отображать документ формата HTML, HTML5. Да именно в версии 5. Существуют различные доктайпы. Вот так мог выглядеть доктайп для четвёртого хтмл \u0026lt;!DOCTYPE HTML PUBLIC \u0026quot;-//W3C//DTD HTML 4.01//EN\u0026quot;.\n\u0026lt;!DOCTYPE html\u0026gt; - всегда будет для вас (мастеров HTML5) одинаков, неизменяем и всегда пишется в первой строке.\nHTML #  \u0026lt;html\u0026gt; один раз открывает код страницы и \u0026lt;/html\u0026gt; один раз закрывает. Между открывающим и закрывающим тегом html мы и пишем весь код нашей страницы.\nСам html разбит на две части head и body - голова и тело.\nМы будем возвращаться к голове и телу ещё не один раз. Ну, во-первых, без них нельзя сделать ни одну страницу. А во-вторых некоторые последующие теги привязаны только к \u0026ldquo;голове\u0026rdquo; или только \u0026ldquo;телу\u0026rdquo;.\nЗакрытие и открытие этих тегов проходит, как и у тега html. И мы можем учить новое слово Структурные элементы страницы. Их много больше, одни можно вкладывать в другие, так же как подъезд дома вложен в сам дом, а этаж в подъезд, а квартира вложена в этаж. Комната в квартиру, стол в комнате, а компьютер на столе, при этом стол не может быть в проходе, либо в рабочий кабинет, либо в коридоре, нельзя его оставить в дверях.\nАбсолютно точно так же как и эта аллегория работает структура веб страницы эдакая матрёшка. Один элемент вложен в другой.\nДолжен признать. Я вас обманул. Всё это не так просто. Но вот до этой строчки был порог вхождения. Если вы всё поняли, представили и разобрались до этого момента, то дальше точно будет легко и просто. Обещаю!\nКупились? Не будет. Нет ничего лёгкого даже в этом языке разметки. Мир меняется каждый день, все новые приборы, безбарьерный интернет, новые технологии - всё это накладывает отпечаток на наши веб страницы. Этих элементов и правда не много - сотня. Ещё с какое-то количество атрибутов к ним, ну как charset и их значений. Но с каждым из них реально надо разобраться, посмотреть примеры, применить в практике и запомнить. Не слушайте тех, кто скажет, что редакторам или блогерам HTML не нужен - это миф. Это как фехтовальщику не нужна техника владения мечом - просто руби сверху вниз. Каждый кто связан по работе с веб страницами - обязан хотя бы один раз ознакомится с возможностями этого самого HTML.\nНо мы отвлеклись - едем дальше!\nHead #  , Голова, то есть head в него мы вложили ещё title. У тайтла тоже есть открывающий и закрывающий тег. И внутри него мы разместили текст.\n Этот текст отображается в самом тайтле браузера или в закладке браузера, где открыта наша страница. Если закладок много, то текста пользователь скорее всего не увидит. Но это тот же текст, который по дефoлту(default - стандартно) подставляется при внесении страницы в закладки. Попробуйте. Это тот текст, который может быть виден пользователю в результатах поиска в Google.  Отсюда мораль - тайтл должен быть продуманным, если это рецепт борща, то я бы рекомендовал написать там \u0026ldquo;Рецепт борща - 12 шагов\u0026rdquo;. Если это первая страничка на уроке HTML - то наверное есть смысл написать там \u0026ldquo;My first HTML-page - HelloWorld !\u0026rdquo;. Или то что считаете нужным, например \u0026ldquo;qwerty\u0026rdquo; вы же теперь вебмастер знающий основы HTML - вам и решать.\nTitle #  Title размещается только внутри тега head. Title поддерживает \u0026ldquo;Global Attributes\u0026rdquo; - глобальные атрибуты (мне надо было похвалиться своим прекрасным знанием английского языка). Список этих атрибутов я приведу позже, но самостоятельно вы его можете нагуглить уже сейчас, например этой магической фразой \u0026ldquo;global attributes w3c\u0026rdquo;. W3C - это консорциум всемирной паутины, проще говоря боги этого вашего интернета. Про них можно нагуглить в Википедии. Я вас всё время куда-то посылаю не потому что мне лень об этом написать. Просто если я буду писать про все детали - я никогда не закончу. Моя задача научить вас HTML-грамоте. Дополнительные, интересные и полезные материалы часто будут как ссылка в гугл.\nНо давайте сконцентрируемся и перейдём к тому, что мы написали в body, мы открываем и закрываем теги 4 раза: H1, article, p и q.\nHTML-тег H1 #  H1 - это заголовок всей страницы видимой пользователю. Очень часто H1 это название самого сайта или название статьи на нём (рецепта, видео, заметки). Вы заметили, что я написал H1 с большой? Мы ведь договорились писать всё с маленькой. Не забываем быть последовательными. h1 - браузеру всё равно, а вот читающему код человеку не всегда.\nHTML-тег article #  article - вся статья помещается внутри этого тега. Если на странице две статьи, то article будет или должен быть использован дважды. Как вы понимаете, желаемое и действительное не всегда одно и то же.\nHTML-тег p(paragraph) #  p - отмечает начало и конец абзаца. Зачем? Ну например, что бы текст начинался с красной строки или каждый нечётный абзац помечался бы другим оттенком, или\u0026hellip; или\u0026hellip; Вариантов использования для чего множество. Например транслировать на сайте в блоке \u0026ldquo;Интересные мысли\u0026rdquo; случайные абзацы редакторов сайта.\nHTML-тег q (HTML Quote Element) #  q - короткая цитата или прямая речь. Очень удобно красиво выделять мысли в тексте. И кстати именно это пример малоизвестного тега, который входит в список \u0026ldquo;ай зачем их всех учить\u0026rdquo;. Забегая вперёд скажу, что если есть короткая цитата, то будет и длинная :).\nЧто мы должны были заметить кроме этого, что вложенный тег должен сначала закрыться сам, прежде чем можно закрывать тег родитель.\n\u0026lt;p\u0026gt;Щас скажу \u0026lt;q\u0026gt;прямую речь\u0026lt;/p\u0026gt; только абзац новый начну\u0026lt;/q\u0026gt; - так не правильно.\nСначала мы должны закончить прямую речь и закрыть тег q и только потом закрыть родительский тег. Смотрим как мы это сделали в примере.\n\u0026lt;p\u0026gt;Щас скажу \u0026lt;q\u0026gt;прямую речь\u0026lt;/q\u0026gt; только абзац новый начну\u0026lt;/p\u0026gt;\nПринципиально, азы HTML мы только что прошли. На самом деле теперь вы можете всем говорить, что вы знаете и понимаете структуру HTML. Вот тот пример мы теперь всё время и будем изменять. Добавлять все новые теги в него и смотреть как он изменяется. Каждый тег мы сейчас будем проходить как маленькую главу и рассматривать примеры применения. Но сначала я вам расскажу про CSS.\nCSS #  Сначала будем делать руками, потом я попробую объяснить, что мы сделали.\n Создаём в той же папке, где у нас лежит наш хтмл исходник, новый файл с названием style.css Редактируем наш html файл и добавляем туда строчку \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;style.css\u0026quot;\u0026gt;. Строчка должна быть вложена в head страницы, так как это информация не для человека, а для браузера. Этим самым мы говорим, где считывать стили страницы. В сам css файл вносим: body { background-color: #2D2D2D; } h1 { color: saddlebrown; font-size: 30px; font-family: Menlo, Monaco, fixed-width; } p { color: white; font-family: \u0026#34;Source Code Pro\u0026#34;, Menlo, Monaco, fixed-width; } q { color: yellow; }  Сохраняемся и проверяем наш результат в браузере. У нас должно было получится примерно следующее:    опера css   Ещё раз код и текст, который лежит в нашей html странице\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- Это моя первая страница. Создана 12 октября 2018 года --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Привет мир\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;article\u0026gt; \u0026lt;p\u0026gt; Это моя первая web-страница и я очень волнуюсь: \u0026lt;q\u0026gt;получится ли у меня?\u0026lt;/q\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Что мы написали в стилях #  Мы указали каждый тег в стилях и сказали как его отображать.\nДля всего body в фигурных { } скобках мы указали цвет бэкграунда. Цвет мы указали в общепринятой 16-ричной системе исчисления. Эту систему обозначают буквами HEX - hexadecimal или система исчисления с базисом 16. Если вы не знаете, что это такое, то коротко скажу, что мы используем систему с базисом 10 и считаем до десяти, вебдизайнеры считают до 16. Подробнее про неё можно (но не обязательно) загуглить в Яндексе - \u0026ldquo;Шестнадцатеричная система счисления\u0026rdquo;.\nДля тайтла(h1) мы указали цвет букв, размер букв и тип и свойства шрифта.\nДля абзаца(p) мы провели такую же операцию только с другими значениями, как и для тайтла. И обратите внимание, и там и там мы указали цвет \u0026ldquo;английскими словами\u0026rdquo;, а не значениями HEX. Существует табличками с заданными названиями для пары сотен HEX значений. Её точно наизусть учить не надо, но эти значения удобно использовать например в протоколировании страницы.\nИ наконец для короткой цитаты (q) мы просто поменяли цвет.\nПринципиально всё. Вы только что изучили введение в CSS. Дальше мы будем тоже просто изменять и пробовать улучшить наши страницы и изучать, что можно сделать с помощью HTML и CSS, а что нет.\nПока можете стереть некоторые значения или даже добавить свои. Внести article в css со своими значениями и попробовать сделать конфликт, например указав разные цвет, размер для шрифтов артикля и абзаца, и посмотреть кто победит.\nПро CSS мы должны знать только, что это стили, что они пишутся в отдельном файле и что все теги можно описать по отдельности, не описывать иногда вовсе или написать в каждом теге одно и тоже. Всё. Это базовый уровень на самом деле, которого вам хватит с головой, если вы не хотите становиться фронтендером.\nА мы продолжаем дальше.\n"});index.add({'id':7,'href':'/school/tools/04-how-to-create-passwords/','title':"Как правильно создавать пароли",'content':"Немного о паролях, или как их правильно создавать\n  -Вы слабое звено! И вы выбываете из игры!\n  Можно добавить ещё пару анекдотов, чтобы правда жизни не так резала по сердцу.\nОднако. Здравствуйте. При самом крутом алгоритме шифрования пароль \u0026ldquo;мама\u0026rdquo; вскрывается за одну секунду. Также не стоит ставить паролем свой день рождения. Если бы вы знали сколько мужей погорело на различных Love-порталах, выбравших свой день рождения паролем. А недовольных дворецких и секретарш на пенсии, тоже ещё никто не удосужился отменить.\nА ведь в нашем окружении немало людей, знающих наши привычки и пристрастия. Поэтому просто перейдём к тому как правильно создавать пароли.\nУровень сложности пароля #  У любого из нас уже могла возникнуть ситуация, когда нам проходилось сообщать пароль от какой-либо системы (емайл, банк, компьютер, программа и тд и тп) своим близким или коллегам. В наш информационный век с десятком емайлов и форумов, аккаунтом к Ebay, интернет доступом к своему банку и паролем на \u0026ldquo;вторую\u0026rdquo; бухгалтерию тяжело, даже очень тяжело придумывать в каждом отдельном случае новый пароль. И очень часто неплохой пароль используется везде. Один и тот же. Не всегда есть возможность сказать решительное: \u0026ldquo;Нет. Я не дам тебе свой пароль\u0026rdquo;. А к чему может это привести, каждый из должен понимать сам.\nИтак. Имеет смысл ввести пяти или десяти бальный приоритет паролей. Чем выше приоритет, тем он для вас важнее.\nДесятибалльная система приоритетов для паролей #   Пароль на пароли. Записная книжка с кодом или маленький контейнер с личными данными и записной книжкой с паролями от всего , где у нас есть пароль. Пароль на модуль шифрования в личной или деловой переписке. Пароль на контейнер с защищённой информацией (разница с пунктом 10 в размере). Доступ к компьютеру Пароль к электронной почте (емайл) Банковский пароль Пароли к сервисам с оплатой (ebay, online-shops итд и тп) Пароли к Facebook, Instagram, Telegram, Icq, Msn, Skype и тд и тп. Пароли к развлекательным порталам и форумам Пароль на фотографии с последней вечеринки.  Приоритеты каждый расставляет сам, и просматривая эту таблицу, выясняется, что кроме последней вечеринки, вся остальная информация не предназначена для других глаз.\nОднако. Здравствуйте. Как тогда получается, что пароль с самым высоким приоритетом является фамилией той девочки, что сидела с вами в первом классе за одной партой, а у компьютера вообще нет пароля и вся информация лежит абсолютно открыто?\nПри аккуратном разделении типа информации/паролей, намного легче менять скомпрометировавшие себя пароли. И мы избежим цепной реакции при возможном нападении.\nА вот как узнать скомпрометировал себя пароль или нет? И как часто нужно менять пароли?\nСмена пароля. Как часто? #  Скомпрометированные пароли сразу. Скомпрометированным паролем считается пароль, который записан на бумажку и приклеен к монитору, либо носится в портмоне. Также скомпрометированы те пароли, которые кроме вас знает ещё один человек.\nЗависит от ценности информации. К примеру, в Skype или ICQ я не менял пароль уже лет 10. Потеря логина или УИНа не отразится на моих контактах и финансах. Скорее испортится настроение на 6,5 минут. Естественно, если у кого то супер-элитный 5-значный уин с френдлистой на всю женскую сборную по синхронному плаванию России, то пароль стоит менять хотя бы раз в год.\nИ приоритет пароля повышается до пункта 2, а то и 1. Пароль на пароли я тоже на самом деле не менял ни разу. Пользуюсь им я редко, а бэкапов от контейнера с паролями много. И вот тут один из радикальных вопросов криптологии.\nПодавляющее большинство специалистов и сисадминов регулярно советуют, либо заставляют менять пароли. Правильно замечая, что пароли со временем компрометируются самыми различными способами и ухищрениями. От банального воровства пароля, до глупости юзера, когда он использует рабочий пароль для входа во все форумы и чаты.\nОднако. Здравствуйте. Регулярная смена паролей приводит к тому, что юзеры записывают их на бумажках и телефонах, визитных карточках и просто на мониторе. Если раньше в до-интернетовскую эру, мы не удивлялись ходячим записным книжкам, в головах которых были записаны все телефоны знакомых, то сейчас мозг почти не тренируется, любая информация либо записана в кпк, либо есть в сети. И просто запомнить девятизначный номер телефона уже становится экзаменом для многих. Поэтому я рекомендую:\nПароль для доступа к рабочей станции(компьютер) не должен быть более чем двухсложным и оптимально 8-12 знаков.\nПримеры: #   trzg457fg - цифры и маленькие буквы. GDUI?!:ZH- большие буквы и спецзнаки.  По договорённости, юзер сам должен иметь право придумывать себе пароль. К примеру, если пароль больше 30 знаков. В качестве хорошего примера (до того как он здесь был опубликован.\n  kak_by_ya_hotel_zarabatywat_w_mesac_milion_dolarow\n  Рекомендации для сис-админов и фирм с ценными данными #   Обязательно ознакомить всех сотрудников с принципами защиты, хранения и обработки информации.\nПонимая хотя бы основы криптологии, можно избежать многих ошибок. Классификация прав на доступ к информации по степени секретности(от „секретно в стадии разработки“, до „совершенно секретно“- при разглашении уголовное преступление Роспись каждого сотрудника об ознакомлении и исполнении требований по защите информации, подкреплённое организационными и дисциплинарными мерами, при нарушении этих требований.\nТакая роспись о неразглашении творит поистине чудеса. Желательно провести ликбез на тему „защита информации, трояны, вирусы, программы шифрования и взлома“ и сдача тематического зачёта. Иметь в штате специалиста, профессионально разбирающегося в криптологии. Стараться использовать то программное обеспечение, в котором есть 100% уверенность. Анализ действий вероятного противника (конкурента). Грамотно использовать программы защиты и по возможности избегать „сертифицированных“ в США или России программ. Использовать программы с открытым алгоритмом работы. Использовать такие настройки операционной системы, которые предотвращали бы „заражение“ компьютера или тем паче всей фирмы через интернет или электронную почту. Дополнительно разработать комплексную стратегию защиты информации на вашем предприятии. Лучше поручить такую задачу сторонним специалистам. Например - мне. Провести \u0026ldquo;испытание\u0026rdquo; имеющихся у вас средств защиты информации, поручив стороннему специалисту испробовать на прочность вашу защиту.  "});index.add({'id':8,'href':'/school/java/basic-course/025-java-idea-basics/','title':"Настройка, горячие клавиши, debugging в IntelliJ IDEA",'content':"IntelliJ IDEA — настройка, горячие клавиши, debugging — введение в Java 025 #  Сегодняшний программист очень сильно отличается от программиста 90-х.\nБлокноты сменились мощными инструментами, которые подсказывают нам даже эффективные методы решения. Порой, кажется, что ещё чуть-чуть и людям точно не надо будет учить программирование, потому что Idea сделает всё сама.\nНо пока этого не случилось нам стоит потратить немного времени на настройку самого главного инструмента, в котором мы пишем код. Idea может очень многое. Очень. В этой главе мы рассмотрим несколько горячих клавиш, некоторые типы подсказок и базисные вещи, которые нам предлагает рефакторинг и дебаггинг.\nДавайте на секунду отвлечёмся от самого кодинга и попробуем настроить наш инструмент для работы с Java и подтянуть наши скилы для работы с ним.\n  Отладка программы в intellij idea   Рефакторинг #  Alt + F6 — одна из самых полезных функций рефакторинг. Переименование переменной во всём коде программы, сколько бы раз она не упоминалась.\nДля этого надо выделить название метода, класса или переменной и вызвать из контекстного меню или горячими клавишами безопасное переименование. Очень удобно и для тех случаев, когда класс создан с грамматической ошибкой. IDEA переименовывает и файл и класс одновременно.\n  Безопасное переименование переменных   Не только hotkeys #  Горячие клавиши очень полезны в работе, но всё же не все функции доступны через клавиши.\nСтоит выделить время и посмотреть что может программа: подобрать цветовую гамму, шрифты и их размер, научиться делить окна на рабочие зоны.\nКак открыть одновременно 2 класса в IDEA? #  Например мы можем работать одновременно в нескольких классах (файлах). Эта функция доступна нам, если мы правой кнопкой нажмём на вкладку файла в окне, а затем на \u0026ldquo;Split Vertically\u0026rdquo; или \u0026ldquo;Split Horizontally\u0026rdquo;. Это очень удобно, когда программа состоит из больше, чем одного класса.\n  Разделить окно IDEA   Как добавить плагин в intellij idea? #  File -\u0026gt; Settings -\u0026gt; Plugins здесь можно посмотреть, что уже установлено или добавить новый полезный плагин.\nНапример мне оказался очень полезен плагин Grazie - проверка орфографии.\n  Grazie - проверка орфографии   Проверка правописания в Intellij Idea для русского текста #  File -\u0026gt; Settings -\u0026gt; Editor -\u0026gt; Proofreading\nЗдесь можно добавить те языки, которые нужны в работе над кодом и документацией.\n  Настройка проверки орфографии в IDEA   Горячие клавиши #  \u0026ldquo;Alt + h + k\u0026rdquo;. В Idea есть возможность вызвать помощника по горячим клавишам \u0026ldquo;Alt + h + k\u0026rdquo; открывает pdf файл, где описаны поддерживаемые вызовы.\nОтладка программы #  Отладка Java кода в IDEA. Основные возможности отладчика.   "});index.add({'id':9,'href':'/school/java/basic-course/024-java-swap-two-variables/','title':"Обмен значений переменных в Java",'content':"Обмен значений переменных — введение в Java 024 #  Допустим у нас есть переменная A со значением 5 и переменная B со значением 3. И нам нужно поменять значения у переменных местами.\nint a = 5; int b = 7; int temp = a; a = b; b = temp; Мы создаём дополнительную переменную. Передаём ей временно для хранения значение A, в само A передаём значение B. В B присваиваем значение, которое у нас хранится во временной переменной.\nСуществуют способы поменять их местами не создавая новую переменную.\npublic class Main { public static void main(String[] args) { int a = 5; int b = 3; // меняем местами пошагово  a = a + b; b = a - b; a = a - b; // меняем местами в одну строчку.  a = a + b - (b = a); // меняем местами пошагово с помощью XOR  a = a ^ b; b = b ^ a; a = a ^ b; } } Вариант с созданием дополнительной переменной легко читаемый и понятный всеми вариант.\nДомашнее задание #   Попробуйте дополнительно поменять местами переменные используя другие арифметические операторы.  "});index.add({'id':10,'href':'/school/html/03-html-path/','title':"Относительные и абсолютные пути - введение в HTML",'content':"Относительные и абсолютные пути #  С HTML у нас будет очень много различных файлов и папок, и изображений, и стилей. Поэтому нам надо понять как именно можно указывать месторасположение наших ресурсов.\nЧетыре варианта, которые указывают на то, где лежит файл.\n1. \u0026#34;styles.css\u0026#34; 2. \u0026#34;./styles.css\u0026#34; 3. \u0026#34;./../styles.css\u0026#34; 4. \u0026#34;/my_styles/styles.css\u0026#34; 5. \u0026#34;http://www.povar.eu/style.css\u0026#34;  Первый и второй вариант пытаются указать на один и тот же файл, который лежит в этой же папке. Третий вариант ищет файл на один уровень выше. Четвёртый в подпапке my_styles Пятый вариант указывает абсолютный путь в интернете.  Нюансы #  Написание путей влияет не только на css, но и на другие файлы: js, java, php и прочие.\n"});index.add({'id':11,'href':'/school/','title':"С чего начать",'content':"Какой же язык программирования лучше изучать первым #  Перед тем как выучить основы программирования в своём первом выученном языке, я задавал этот вопрос десятки раз. И лучше всего мне ответили единожды. Ответом был — английский. На самом деле доля правда в этом есть.\nСовременные языки так сильно пытаются упростить вхождение в основы, что написанный код читается уже почти как нормальный произносимый английский: \u0026ldquo;Возьми переменную а, и пока она меньше 10, прибавляй к ней переменную б.\u0026rdquo; Без английского очень часто никак и никуда. Если говорить о современных компьютерных реалиях, то лично моё мнение далеко не однозначно.\nСписок языков, разметок, скриптов и технологий с которыми стоит ознакомиться:\n Java C# Python PHP Javascript HTML CSS XML Word Excel PowerPoint Access Реляционные базы данных, например MySQL, SQL или Derby PowerShell Swift UML Реляционная алгебра Булева алгебра Теория множеств Тестирование программного обеспечения Разработка программного обеспечения  Поверьте мне, что любой программист раскритикует данный список в пух и прах и предоставит свой. Но позвольте я сначала объясню, что я подразумеваю под каждым пунктом.\nJava #  Java — высокоуровневый объектно-ориентированный язык программирования со строгой типизацией переменных. Программы на этом языке работают практически везде, на мой взгляд, это математически хорошо структурированный язык, с прекрасной обучающей документацией и на русском языке. Разработчики и программы на Джаве нужны практически везде: в банковском секторе, на заводах, в медицине и вебдевелопменте(например, поиск). Программы на андроид используют Джаву. Определённо, человек осиливший джаву, не испугается необходимости обучению ещё одному языку. Джава достаточно, если не очень, сложна в обучении и требует хорошего абстрактного мышления. Пример применения в играх — Майнкрафт. Именно с этого языка началось моё знакомство с программированием и, несмотря на все тяжести обучения, я даже полюбил этот язык. Немножко. :)\nC# #  C# — почти всё, что было сказано про Джаву можно сказать и про Сишарп. Майкрософт попытался сделать свою Java и, конечно, языки очень похоже и внешне. Прежде всего, оба языка называются си-подобными. Разница между Си и Джавой с Сишарпом только в уровне. Си низкоуровневый язык, что значит доступ \u0026ldquo;к железу\u0026rdquo; напрямую. А Джава и Сишарп — высокоуровневые, что значит доступ \u0026ldquo;к железу\u0026rdquo; через прослойку в виде операционной системы. Это не плохо и не хорошо. Это просто особенности языков со своими плюсами и минусами, которые следует учитывать при разработке. Если говорить только о Сишарпе, то стоит сказать, что очень многие приложения для смартфонов сделаны на Unity3d, что в свою очередь использует C# и Javascript. Мораль. Если вам интересна десткопная разработка под Windows10 и позже, то скорее всего, вам стоит посмотреть в сторону C# внимательнее. Изучение основ Джавы или Си перед изучением C# совсем не помешает.\nPython #  Python — помимо того, что Питон (или Пайтон) современный и объектно-ориентированный, он ещё и достаточно широко используется. Питон по легенде придуман после попытки выучить Java. Задача стояла сделать синтаксис языка как можно проще, меньше и понятнее. Частично это удалось и, на мой взгляд, Питон — самый распространённый язык среди таких не профессиональных программистов, как бигдата-аналитиков, систем-администраторов, математиков и прочих. С этого языка определённо можно начать знакомство с миром машин. Существует масса уроков онлайн и поддержка комьюнити.\nPHP #  PHP — среди \u0026ldquo;настоящих\u0026rdquo; программистов ходят шуточки про PHP-кодеров. Суть их сводится к тому, что PHP ненастоящий, несерьёзный язык, в нём нет, к примеру, чёткой типизации данных и нет объектов. И, исходя из этого, в PHP кодят те, кто не осилил \u0026ldquo;нормальный\u0026rdquo; язык, как Си, Java, Python и тд. На самом деле, частично всё так. В PHP очень много случайных людей, они пилят свои маленькие псевдосайтики и у них самые маленькие зарплаты в отрасли. Но такое наблюдается практически только среди джунов и, частично, мидлов. Опытные разработчики прекрасно разбираются в архитектуре, проектировании и объектах. И зарплаты у опытных спецов ничем не хуже, чем у коллег из смежных специальностей. Помимо того, уже сейчас в новых версиях PHP активно используется ООП и новые версии фрейморков, например Drupal, вовсю используют \u0026ldquo;сложные\u0026rdquo; технологии, которые раньше в вебдеве были только в энтерпрайзе. Я считаю, что в коммерческой веб-разработке без знания PHP сложно. И можно записать в список изучения PHP, если вы хотите добиться успехов. Именно список. К английскому и PHP добавятся ещё некоторые вещи.\nJavascript #  Javascript — история наименования языка показывает, что нейминг — далеко не бесполезная наука. На данный момент Javascript не менее популярен, чем Java. Javascript используется в вебразработке и уже при создании почти всего. Браузеры же есть везде, а там где есть браузеры, может быть использован и Яваскрипт. Уже упомянутый выше фреймворк Unity3d использует и наш Javascript. И, несмотря на это, я бы его внёс в список изучения не на первом месте. Но всё же обязательным к изучению для всех. Потому что интернетом пользуются все, а интернет и Яваскрипт сегодня \u0026ldquo;неотделимы\u0026rdquo;.\nHTML #  HTML — Hypertext Markup Language. Не язык. Вообще никак не язык. Это просто разметка страницы. Знание основ Hypertext Markup Language входит уже в общее образование, как знание геометрии. Поэтому уговаривать его учить смысла нет. Если вы ещё не знаете, как выглядит HTML-страница изнутри — учите!\nCSS #  CSS — Cascading Style Sheets. Это стили, помогающие отобразить информацию в HTML-документе корректно. Без CSS современная веб-разработка уже невозможна. Первоначально служило дополнением к HTML. На сегодняшний день применяется много шире. К примеру GUI (графический интерфейс) Java в последней версии — JAVAFX использует элементы CSS для отображения информации. В связи с этим, кем бы вы не хотели стать, для чего бы вы не использовали навыки кодирования, скорее всего вам пригодятся знания каскадных стилей. Основы HTML и CSS неподготовленному студенту-филологу можно выучить за 5-10 полноценных учебных дней.\nXML #  XML — ещё один тип разметки, eXtensible Markup Language. Интересен для изучения тем, что разобраться с ним можно за несколько часов, максимум за пару дней. А вкупе с HTML помогает понять, что разметки не такие уж и сложные, и каждая следующая будет даваться легче и легче. Например MD — Markdown, который всё чаще встречается вместо привычного txt-формата. Следует осознать, что иксмл используется везде. В Java, Андроид-разработке, веб-разработке, в создании маленьких \u0026ldquo;домашних\u0026rdquo; \u0026ldquo;баз данных\u0026rdquo;. Если хотите, то это то, что надо выучить первым. И перенести всю коллекцию фильмов в формат XML.\nWord #  Word — в бытность шефом одной небольшой веб-студии, мне очень хотелось скинуть часть скучных обязанностей на своих сотрудников. Не получилось. В совершенстве ни вордом, ни экселем, ни поверпойнтом не владел никто. В итоге был вынужден заняться самообучением и выучить пакет MS Office самостоятельно. И поверьте мне, там есть что учить. В среднем, продвинутым пользователем в ворде можно стать за две-четыре недели обучения. И это пригодится, тем более, программисту. Как вы думаете в какой программе вы будете делать 100-страничную документацию к бухгалтерской программе и вебсайту для средней пиццерии? Что, серьёзно, не задумывались, что всё это кому-то надо делать? Ещё раз - ВОРД!!! Полноценное образование без ворда невозможно.\nExcel #  Excel — MS Excel или Google Spreadsheet. Это то, что надо выучить. Вместо \u0026ldquo;или\u0026rdquo; можно поставить \u0026ldquo;и\u0026rdquo;, и добавить Libre Office. Уверенно чувствовать себя надо везде. Сложные формулы в Google Spreadsheet пишутся кстати на Яваскрипте, а в Екселе на VBS. VBS учить не рекомендую вообще. Малоперспективный скрипт, который забыт даже производителем. MS Excel — это наиболее широко используемая система функционального программирования и помимо того, что помогает в профессиональном плане, никогда не будет лишним и в повседневной жизни.\nPowerPoint #  PowerPoint — или любая другая программа для составления презентаций. В данном случае производитель абсолютно не имеет значения. Но я Виндовс-пользователь и мне проще говорить о продуктах Майкрософт. Я немало поездил по отраслевым конференциям и могу сказать, что далеко не все спикеры умеют выжимать из презентационных материалов максимум возможностей. Умение доступно выражать свои мысли, в том числе, перед коллегами и клиентами поможет в работе неимоверно.\nAccess #  Access — работа с базами данных. В сети достаточно материалов по всем продуктам майкрософта и обучение с Access тем легче, что зачастую он уже есть на компьютере и ничего не надо ставить дополнительно. Программисты хранят данные в базах данных. Системные администраторы администрируют, в том числе, и базы данных. А проектировщики должны, в том числе, понимать, что такое проектирование базы данных. Суть — надо, но, может, всё-таки не в самом начале списка.\nРеляционные базы данных #  Реляционные базы данных, например MySQL, SQL или Derby — существуют различные системы управлениям базами. Ударение стоит сделать на реляционных базах данных. И на MySQL. Но всё же большей разницы, на самом деле, нет. После полноценного изучения MySQL (2-4 недели) каждая следующая система учится за день-два. Если вы учите Java, то вам интересна Дерби и MySQL, если вы хотите учить PHP, то мимо MySQL вам не пройти. Самое главное — научиться проектировать базы, приводить их в нормальную форму и научиться составлять запросы. За месяц-два обучения можно стать очень хорошим специалистом.\nPowerShell #  PowerShell — в своё время я администрировал компы, и именно тогда я возненавидел VBS. Он мне встречался ещё при создании макросов для MS Office. VBS — очень страшная вещь, которая может отбить охоту программировать навсегда. PowerShell — это замена ненавистному скрипту. И, на удивление, замечательная замена. Если у вас Win10, то можете прямо сейчас начать изучать PowerShell и его возможности. С ним можно достичь великих целей. И это совсем не шутка. Администрирование парка машин на Win10 без знания PowerShell невозможно.\nSwift #  Swift — язык, на котором Apple рекомендует писать приложения для OSx. В том числе, и айфонов. Для этих целей я бы рекомендовал именно его тоже.\nUML #  UML — Unified Modeling Language. Язык, который практически не используется в Рунете и, тем более, в вебразработке Рунета. А зря. С помощью этого языка можно нарисовать всё, что угодно: дом, взаимодействие с новой программой, новую базу данных с отношениями и атрибутами, классы и методы с параметрами и без. Всё что угодно. И умея UML и C#, и Java, и Swift, и MySQL дадутся намного легче. Если вообще их можно выучить без знания UML.\nБулева алгебра #  Реляционная алгебра, Булева алгебра, Теория множеств — три крайне важные темы в математике, которые вам понадобятся при обучении языков программирования. Понятно, что в жизни вам может и не понадобятся знания XOR, AND, NOT или OR; но не в обучении. Без понятия булевой алгебры будет очень тяжело. 95% программ не требуют досконального знания двоичной системы, сдвигов влево и вправо, умения в уме складывать и перемножать true и false, но и скрипичный ключ, с войной и миром мне в повседневной жизни не сильно нужен. Это базовые знания. Учить. По-любому.\nМораль #  Морали нет. Путей развития множество:\n Работая в аналитике больших данных, вам никак нельзя без знания алгебры и высшей математики и, скорее всего, будет достаточно Python. Занимаясь веб-разработкой, даже такой \u0026ldquo;простой CMS\u0026rdquo;, как WordPress или Drupal вам понадобятся знания — PHP, HTML, CSS, Javascript, MySQL. Работая Windows-системным администратором, вам понадобится знание всего пакета MS Office, PowerShell, HTML, CSS, XML и алгебры. Разрабатывая под Андроид, понадобится так же немало — Java, HTML, CSS, XML, MySQL.  И, конечно же, всем нужны полноценные знания в MS Office или его аналогам, как минимум, на уровне пользователя.\nМой личный совет — составить план, где урок алгебры чередуется с уроком по Офису и программированием. И мой минимальный список изучения для Windows пользователя:\nПлан Минимум #   Реляционная алгебра, булева алгебра,теория множеств MS Office Markdown XML HTML, CSS Git Java UML Реляционные базы данных, на примере MySQL, Acces Регулярные выражения Javascript  Если вы думаете, что это много, то не забывайте, что вам, скорее всего (возможно), придётся ещё вплотную разбираться с докером, векторной графикой, фотошопом, видео- и аудио- кодеками, апи- фейсбука, инстаграмма, вконтакте, телеграма и тд, и тп.\nПенсионеры #  \u0026ldquo;Ух какой список для пенсионеров!\u0026rdquo;,- заметил мой друг забежав на мой сайт. Этому списку всего 4 года, а уже я бы что-то добавил и убрал.\nПоявились и утвердились на рынке прекрасные языки GO, Kotlin, Dart. Влияние C# на рынок стало меньше. Влияние Windows на разработку уменьшается и PowerShell вряд ли стоит ставить в список обязательно изучаемых вещей.\nТак что скорее мораль - список устарел. А писать его каждый пол-года заново дело малоблагодарное.\n"});index.add({'id':12,'href':'/school/html/01-html-intro/','title':"Уроки HTML и CSS Online",'content':"Веб-девелопмент — пособие для начинающих #  Предисловие #  Свой первый сайт я сделал ещё в 96-м году. Просто скопировав исходники с сайта модного компьютерного журнала и поставив их на свой. Принципиально это не самый плохой способ. Подсмотреть и сделать лучше. Что бы понять как это работает — просмотр чужих примеров просто обязателен.\nПоследние пару лет слово пример практически не используется в моём IT-круге. Принято говорить кейсы, кейс клиентa, пользовательский кейс. И это важная черта компьютерных разговоров. Очень много англицизмов. Невозможно перевести всю документацию на языки пользователей. Английский как язык технического документооборота принят на многих фирмах, где англичан к примеру никогда и не было, да и команда разработки к примеру - русская. В одной из таких фирм меня шеф бил по рукам за комментарии в коде на русском языке.\nАнглийский #  Это я к тому, что если вы не выучите английский, то шансов стать хорошим разработчиком у вас нет. И мы подошли к главному - для кого это пособие. Сейчас, когда написана только первая глава, я вижу, что книга должна помочь взрослому человеку разобраться в мире веб-технологий. То есть это пособие для меня в прошлом, когда я не знал с чего начинать учить Frontend.\nВполне возможно, что оно поможет и редакторам сайтов, которые не собираются углубляться в веб-строительство, а просто хотят хорошо делать свою работу. Как минимум для вас, моих коллег-редакторов я и сделал обзор тегов HTML и их возможностей. Один раз ознакомиться с этим списком важно для любого человека, который пишет в этом вашем интернете.\nНадеюсь это пособие поможет и тебе.\nHTML и 2019 год #  Официально интернет пришёл в разные страны по разному.\nНациональные доменные зоны #     Домен Назначение Дата появления     COM Коммерческие для всех 1 января 1985   US США 15 февраля 1985   DE ФРГ 5 ноября 1986   SU Советские Союз 19 сентября 1990   UA Украина 1 декабря 1992   RU Россия 7 апреля 1994   BY Республика Беларусь 10 мая 1994    В 95-м году интернет на территории бывшего СССР стоил больших денег и был скорее доступен сотрудникам научно-технических организаций и студентам высших учебных заведений. В это же время в странах западной Европы и США были уже частные интернет провайдеры, которые предлагали доступ для частных лиц из дома. В Германии на тот момент час \u0026ldquo;звонка\u0026rdquo; с модема на модем внутри города стоил около 5 немецких марок(2,5€).\nКак мы видим интернет тогда был и на Западе уделом богатых или умных, или умных и богатых. Так он и развивался, медленно, лишь постепенно становясь доступным массовому пользователю и бизнесу. Развиваясь, в нём появлялись деньги, исполнители, знания, новые требования, новые возможности. И он менялся; прокладывались новые линии, придумывались новые языки, библиотеки, методы решения проблем и \u0026hellip; снижался порог входа.\nТо, что мы сегодня называем интернетом очень и очень отличается от того, что называли интернетом в 1994 году.\n HTML5 - сегодняшний стандарт интернета - принят в 2014 году. CSS3 - существует с 2000 года. React, который используется сейчас чуть ли не на 80% новых сайтов вообще придуман в 2014 году.  Технологии действительно новы и вместе с вами их учат и \u0026ldquo;бывалые\u0026rdquo; программисты. Так что это примерно как с правилами дорожного движения. У старых водителей есть опыт, у новых водителей знания. И где-то за два года работы каждый новенький становится стареньким.\nЭто всё просто #  Нет, серьёзно! Это всё несложно. До определённой степени. Ну так же несложно как писать красивые письма, делать презентации или отсылать письма.\nHypertext Markup Language #  HTML (Hypertext Markup Language) - не язык программирования, а язык разметки. С помощью него нельзя вычислить траекторию полёта, предсказать погоду на завтра или смоделировать поведение человека. Это просто правила отображения текста на экране.\nЧто мы должны понять и запомнить? C помощью HTML мы указываем параметры текста, что является заголовком, что чужой цитатой, что считать аббревиатурой, а что статьёй. Указателей для текста или правил много, больше сотни. Но все их можно выучить за неделю. С учителем. Без учителя до месяца. Даже мне понадобился всего месяц, что бы с нуля пройти весь HTML5. А мне уже за 40, плохое зрение, одышка и желание учиться новому так себе, на самом деле. Я к чему? — это действительно несложно. Это HTML.\nСуществует множество способов разметки текста. Ваш простой ворд-файл тоже сохраняется в одной из таких разметок. В этом пособии я коснусь HTML, XML, Markdown. Первых два - общепринятые способы хранения \u0026ldquo;компьютерных данных\u0026rdquo;. Markdown — один из самых популярных, на данный момент, способов написания документации. Помимо HTML мы коснёмся достаточно подробно CSS и совсем немного JavaScript, чисто что бы понять, что это такое.\nДавайте начнём!\nРедактор HTML #  При обучении любой компьютерной технологии первым уроком учат писать Hello World!\nЯ не могу бросить вызов сложившийся культуре, но первым делом нам придётся выбрать инструменты где мы будем это писать.\n   Название эдитора Короткое примечание     Atom Очень приятный и достаточно популярный эдитор от платформы Github (это слово надо знать - Github)   Sublime Text Очень популярный редактор у маководов.   Visual Studio Code Очень, очень годный продукт от Microsoft. В нём я пишу это пособие   WebStorm Раньше был бесплатен. На данный момент для студентов есть возможность бесплатного использования. Практически обязателен к установке. Jetbrains продукты внешне очень похожи между собой. У меня он установлен, как и все выше перечисленные редакторы.   Notepad++ Любимый редактор моей жены. Сам, я лично не использую этот реактор, потому что он мне напоминает встроенный windows-редактор. Но должен сказать, что Notepad++ популярен и среди разработчиков. И очень неплох.    Вы можете установить все эти редакторы и перепробовать их по очереди. Работать с ними одновременно или разделить их по языкам. Например, я использую \u0026ldquo;Visual Studio Code\u0026rdquo; для написания документации к софту и в нём у меня очень много плагинов. В Webstorm пишу уже непосредственно сайты, а Sublime у меня без плагинов, очень лёгкая и его я запускаю часто вторым редактором. Выберете свой редактор из списка или спросите друзей. Кстати очень неплохой совет. Редакторы в 2019 году достаточно сложны. И настроить для повседневной работы получится далеко не сразу. Лишний совет никогда не помешает. Спросите, чем пользуются ваши друзья.\nРабочая папка и домашняя директория #  Во-первых, давайте создадим папку в которой вы будете работать. Например в домашней директории папку \u0026ldquo;HtmlLessons\u0026rdquo;. И уже здесь у вас могло возникнуть два вопроса: что такое домашняя директория и почему не \u0026ldquo;html-lessons\u0026rdquo;.\nДомашняя директория под Виндовсом обычно c:/users/\u0026ldquo;имя пользователя\u0026rdquo; и в компьютерной терминологии обозначается просто значком тилда — \u0026ldquo;~\u0026rdquo;, потому что в терминале в неё попасть можно через тилду. Под Линуксом разумеется можно попасть через тилду. Под Виндовсом тилда вызывает домашнюю директорию только в линуксоподобном теминале, например Bash. Который вам тоже придётся рано или поздно поставить, потому что иначе вы не научитесь работать с Git(вы же запомнили слово GitHub вверху?).\nБез упоминания слов Linux, Bash, Git стать программистом сложно. По этому лучший совет от меня - выписывать все оставшиеся непонятными слова и искать их в поиске. Языки программирования мало чем отличаются от обычных иностранных языков. Кому-то они даются легко, а кому-то сложно. Если вы из второй категории, то сжимаем зубы и зубрим.\nGit #     Термин Ссылка Пояснение     Git https://git-scm.com/downloads Git - это очень популярная технология контроля версий, используемая при разработке програмного обеспечения и веб-приложений. Онлайн инструкция на русском языке   Github https://github.com/ Популярный сервис для хранения Git-репозиториев. С 2018 года принадлежит Microsoft   Bitbucket https://bitbucket.org/ Популярный сервис для хранения Git-репозиториев. Принадлежит Atlassian и очень тесно интегрирован с популярными IT-приложениями этой формы как Trello или Jira   Gitlab https://gitlab.com/ Альтернативный сервис для хранения Git-репозиториев.    Вам не надо скачивать и ставить всё это сразу. Но когда первый страх пройдёт, когда вы начнёте разбираться с HTML - вернитесь и попробуйте разобраться с GIT. Мне на это понадобилось несколько попыток. Примерно с пятой я начал разбираться и не вздрагивать при слове Git.\nЯ не мог не сказать про тилду, линукс, bash-терминал и Git. Уже более чем в половине видеоуроков для начинающих люди показывают всё с маков или линуксов и активно используют \u0026ldquo;~\u0026rdquo; не объясняя что это. Это очень важное сокращение, которое я тоже активно буду использовать. Потому что для меня WEB - это мир иксов(Linux, Unix, Mac OS X).\nОчень краткая методичка по работе с Git.\nКебаб из верблюдов и змей #  Второй вопрос, который у вас должен был возникнуть почему папка названа большими и два слова не разделены минусом. Вопрос очень хороший. Спасибо Андрей, что задал его. Отвечать будет тоже Андрей.\nЛинукс различает написание строчных и прописных букв(маленькие и большие), а виндовс нет. И как бы вы не назвали файл или папку, вы должны помнить, что если вы будете хранить бэкап(резервную копию) на своём компьютере, то \u0026ldquo;одинаковые\u0026rdquo; файлы могут привести к проблемам. В HTML в принципе стараются писать всё маленькими буквами(строчными) и соединять слова через тире. Для домашнего компьютера я больше предпочитаю \u0026ldquo;CamelCaseNotation\u0026rdquo;, когда всё пишется маленькими буквами, без тире, но начальные буквы каждого слова пишут с большой буквы, так принято например в языке программирования Java. Другой вариант написания через \u0026ldquo;-\u0026rdquo; называется kebab-case или lisp-case. Всё понятно? Но вы зря расслабились, это ещё не конец. У нас есть Snake case. Это змейка \u0026ldquo;foo_bar\u0026rdquo;. Но и это было бы слишком просто. Есть UPPER_SNAKE_CASE и lower_snake_case. Запутались? Давайте табличку сделаем.\n   Название термина Пример Ссылка на википедию     CamelCase HelloWorld.java Распространённая система обозначения переменных и файлов в Java, Pascal   snake_case регистр_длинный_как_змея Распространённая система обозначения переменных в Perl, Python, PHP, Ruby   kebab-case шашлычный-регистр Язык Lisp использует такой регистр. Или Gatsby.js    Система, которой вы будете пользоваться не имеет большого значения, это скорее зависит от того на какой машине вы работаете и с какими технологиями. Самое главное, что бы вы были последовательными. Иногда это вообще не ваш вопрос, а политика фирмы. Спросите шефа как работает ваша фирма и следуйте указаниям. Порой это требования клиента. И от проекта к проекту настройки могут отличаться.\nВозвращаясь к эдиторам. Иногда на фирме есть стандарт, который нельзя нарушать или технически не очень удобно использовать другой.\nConvention #  Таких религиозных вопросов в работе будет немало. Обычно для каждого языка есть конвенции(Convention). Конвенция - это свод правил, которые программисты выбрали для данного стэка(технология). Если хотите, своеобразное джентльменское соглашение Запрос \u0026ldquo;CSS Naming Conventions\u0026rdquo; выдаёт правила написания кода для CSS, которым вы будете следовать, если дойдёте до главы \u0026ldquo;CSS - это вооооообще лёхка!\u0026rdquo;\n"});index.add({'id':13,'href':'/school/java/basic-course/','title':"Уроки Java Online",'content':"Базовый курс Java online #  Курсы программирования по java, без sms и регистраций. Совершенно бесплатно\nБазовый курс Java включает в себя императивное программирование на Java. Курс включает в себя азы Java, простые типы данных, строковые значения, массивы, задачи и алгоритмы их решения.\nУроки ориентированы на начинающих.\nДля успешного освоения желательно знать школьный курс математики, иметь желание, абстрактное мышление и время. В среднем один урок - 2-5 часов освоения и 3-5 часов самостоятельное закрепление материала.\nУроки регулярно дополняются.\nК данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки. Скоро будет ссылка.  И конечно же задачник #   Задачник  01 - Логика 02 - Switch 03 - Если, то 04 - Первая дюжина тем 05 - Цикл for    Сами уроки #   Уроки online  Java setup Целочисленные типы данных Десятичные дроби Символы и строки Булевые, логические типы данных Switch - case If - else Modulo Арифметические операторы Цикл for Casting литералов Методы, немного подробнее Цикл while Ввод данных Scanner Системы счисления Тернарный оператор Рекурсия, введение Массивы знакомство Цикл foreach Varargs Многомерные массивы Таинственный main Операторы перехода Обмен значений между переменными IDEA - настройка      Java   "});index.add({'id':14,'href':'/posts/hello/','title':"У меня снова есть блог",'content':"Блогер это навсегда #  Около 5 лет у меня не было блога. И вот у меня снова появилось желание, а мои возможности позволяют выбирать из большего, чем 10 лет назад.\nНадеюсь до конца лета я смогу выложить свой курс введения в веб-программирование с первым языком обучения Java.\nПроверьте сами, вдруг получилось. На секундочку, сам канал сделал ещё 4 года назад - 17.10.2016.\n  ночной берлин   "});index.add({'id':15,'href':'/posts/','title':"Blog",'content':""});index.add({'id':16,'href':'/school/hidden/','title':"Hidden",'content':"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); Тестовое вставка видео    "});index.add({'id':17,'href':'/school/java/basic-course/002-java-integers/','title':"002 Java Integers",'content':"Простые типы данных — byte, short, int, long, в примерах — введение в Java 002 #  Чтобы вызвать на экран что-то большее, чем \u0026ldquo;Привет, Мир!\u0026rdquo;, надо работать с числами, символами и буквами. Чтобы работать с ними в Java — надо научиться их хранить и передавать. Для этого нам надо познакомиться с понятием \u0026ldquo;типы данных\u0026rdquo;, а точнее \u0026ldquo;простые типы данных\u0026rdquo;.\nПростые типы данных — Java Primitives #  Существуют следующие базовые типы данных: byte, short, int, long, float, double, char, boolean и String (не совсем примитив, но базовый тип данных).\nЦелочисленные типы данных #  Мы начнём знакомство с базовыми типами данных с int.\nС помощью целочисленного типа данных, а именно так и переводится \u0026ldquo;integer\u0026rdquo;, мы храним в int целые числа. Для визуализации можно попробовать представить себе следующие примеры:\n Общепринятая нумерация домов во всем мире использует целые числа: ул. Грибоедова 15, ул. Каштановая 10, пятое Авеню 457 и т.д. Перекличка в классе тоже возможна с помощью типа данных int — первый, второй, третий, четвёртый\u0026hellip; Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\u0026hellip; Возведение одного простого числа в степень другого простого числа — например 2 в степени 7 = 128.    Целые числа   Давайте совершим пару арифметических действий на практике.\npublic class HalloInteger { public static void main(String[] args) { // Создаём переменные и присваиваем им значения  int a = 2; int b = 3; int c = a + b; System.out.println(\u0026#34;Сумма a и b = \u0026#34; + c); // Найдём периметр квадрата.  int d = 4; System.out.println(\u0026#34;Периметр квадрата со стороной d =\u0026gt; P = \u0026#34; + 4 * d); } } В Java есть несколько типов данных для хранения целых чисел, это — byte, short, int, long. Принципиально они различаются только размером. Для хранения числа в \u0026ldquo;int\u0026rdquo; надо 4 байта, если речь идёт о таблице Менделеева или о простых задачах, то мы можем обойтись и примитивным типом данных \u0026ldquo;byte\u0026rdquo;. Именно столько занимает места этот тип данных, 1 байт (byte) или 8 бит. Давайте посмотрим таблицу:\n   Тип Размер (бит) Диапазон     byte 8 бит от -128 до 127   short 16 бит от -32768 до 32767   int 32 бит от -2147483648 до 2147483647   long 64 бит от -9223372036854775808 до 9223372036854775807    2 в восьмой степени = 256. Именно столько можно запомнить в примитивном типе данных переменных byte. От -128 до 127 мы можем работать с любым числом в десятичной системе, включая ноль.\npublic class HalloLong { public static void main(String[] args) { long a = 7_456_678_678L; long b = 87_456_678_678L; long c = a + b; System.out.println(c); } } Нам надо помнить только, что byte — это 8 бит, short — 16 бит, int — 32 бита, long — 64 бита. Обычно возникают 2 вопроса. Какой тип данных использовать и зачем эти 4 типа \u0026ldquo;одинаковых\u0026rdquo; данных?\nРазные типы данных сложились исторически. Из-за особенностей x86-процессоров. Всё, что нам надо помнить — это экономия: размер ячейки для хранения, мы экономим место, процессорное время, RAM компьютера или прибора пользователя, и на планете не умирают котики.\nЕсли постоянно всё писать просто в long, то наша программа будет занимать неоправданно много места, она будет \u0026ldquo;есть\u0026rdquo; память и доставлять неудобства. И действительно, зачем использовать программу в 8 гигабайт, если можно сделать её, как минимум, в восемь раз меньше?\nЕщё раз для закрепления:\npublic class IntegerTypes { public static void main(String[] args) { byte a = 111; short b = 1111; int c = 7777777; long d = 2_358_765_649l; // Постфикс l или L обозначает литералы типа long.  // L нужна только за границами int.  // В Java можно использовать подчёркивания для визуального разделения чисел.  // 2_358_765_649 = 2358765649, для программы разницы нет.  System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); } } Пример использования byte:\npublic class AdditionByte { public static void main(String[] args) { byte a = 10; byte b = 30; byte c = (byte) (a + b); System.out.println(\u0026#34;The c variable Value after Addition is : \u0026#34; + c); } } Если сложить два byte числа, которые в сумме дают больше 127, например 70 и 80, то мы получим не 150, а отрицательное число. Byte пойдёт в минусовые значения и будет считать дальше от -128. По кругу, в своём диапазоне из 256 возможных значений. Мир типа данных Byte — всего лишь один байт. Это его ограничение.\nОпределение, объявление, инициализация переменных #  Definition, declaration, initialization #  В Java переменная определяется и объявляется одновременно:\nshort b; Отделить эти понятия нельзя. Обычно в Java говорят только о декларации переменной, когда она просто объявляется:\n \u0026ldquo;Слушайте все!!! И не говорите, что не слышали! Мы объявляем, что от сего дня создана переменная B типа шорт\u0026rdquo;.\n В момент, когда мы присваиваем переменной значение, мы говорим об инициализации переменной.\n \u0026ldquo;Отныне переменная B получает графство и значение\u0026rdquo; 3.\n b = 3; Двоичные числа и не только #  Java позволяет хранить не только десятичные числа\nint hexValue1 = 0x100; // Шестнадцатеричная система счисления int binar = 0B1001_1001; // Двоичная система счисления int octal = 0757; // восьмеричная система счисления Домашнее задание #  Найдите применение каждому типу данных из заголовка и напишите программу с использованием byte, short, int, long:\n Найти площадь и периметр квадрата Найти площадь и периметр прямоугольника Найти площадь и периметр куба Найти количество зёрен на шахматной доске, если на первую клетку положить одно зёрнышко, на вторую клетку два зёрнышка, на третью в два раза больше, чем на предыдущей, то есть четыре и так далее.    шахматы   Дополнительные материалы #   https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html Легенда о шахматах и зёрнах  "});index.add({'id':18,'href':'/school/java/basic-course/003-java-float-double/','title':"003 Java Float Double",'content':"Типы данных с плавающей точкой: float и double — введение в Java 003 #  Числа с плавающей точкой #  Для хранения дробных чисел в Java используют float и double. Правильное название — простые (примитивные) типы данных с плавающей точкой. Примитивные типы данных — byte, short, int, long, которые являются целыми числами, — мы рассматривали - здесь.\n  число Пи   Float #  Давайте сразу рассмотрим практический пример:\npublic class TestFloat { public static void main(String[] args) { float a = 3.5f; float b = 4.5F; float c = (float) 5.5; float d = a + b + c; System.out.println(\u0026#34;a+b+c: \u0026#34; + d); } } Здесь использованы три способа объявления переменных типа float. Самое важное при работе с ними — избавится от \u0026ldquo;запятых\u0026rdquo;. Java — американский язык программирования, и в американсой математике дробь отделяется точкой.\nDouble #  Давайте отдельно рассмотрим пример деления с целыми и дробными числами. Сначала целые числа:\npublic class IntDiv { public static void main(String[] args) { int a, b, c; a = 1; b = 10; c = a / b; System.out.println(c); } } При делении единицы на десять мы получаем ноль целых и, при использовании типа данных int, после и\u0026hellip; больше ничего не будет. Деление единицы на десять даёт ноль.\n- Сколько айфонов ценой в 1000€ я могу купить за 10€? - Ноль. За 10€ я куплю ноль айфонов. И за 999€ я куплю ровно ноль айфонов.  Результат деления целых чисел (тип данных int) округляется до меньшего целого числа. #  public class IntDiv { public static void main(String[] args) { double a, b, c; a = 1; b = 10; c = a / b; System.out.println(c); } } Но, если мы при инициализации переменных изменим их тип на double, то получим привычное нам 0.1.\nПредставьте, что вы купили десять метров ткани, и на костюм вам надо 7 метров. Сколько костюмов вы сошьёте из 10 метров? Один или полтора? В некоторых случаях нам абсолютно не нужны дробные (с плавающей точкой) числа, а в некоторых — целые.\nНа простейшем примере можно увидеть работу double ещё раз:\npublic class HalloDouble { public static void main(String[] args) { final double PI = 3.14; // final - используется для \u0026#34;финализации\u0026#34; переменной,  // теперь переменной PI нельзя присвоить другое значение.  double r = 5.5; double k = r * r; double s = PI * r * r; System.out.println(k); // промежуточный результат  System.out.println(s); } }    Тип Максимальное позитивное значение Минимальное позитивное значение Размер (бит)     float 3.4028234663852886E+038 1.4012984643248171E-045 32   double 1.7976931348623157E+308 4.9406564584124654E-324 64    Экспоненциальная запись #  Экспоненциальная запись — представление действительных чисел в виде мантиссы (дробной части логарифма числа) и порядка. Удобна при представлении очень больших и очень малых чисел, а также для унификации их написания.\n1_000_000 - один миллион: 1,0Е+6 соответствует один умножить на десять в шестой степени.  Что использовать нам в программе? Float или double #  У меня два ответа на этот вопрос.\nВариант один. Пока вы учитесь, используйте double. Он проще не требует буковок после цифры или дополнительного кастинга.\nВариант два. Производительность программы с float ровно в два раза выше, чем с double. Если вам важно делать свой код изящнее, то вы всегда должны понимать, какие типы данных уместнее использовать.\nДавайте попробуем сделать программу, которая считает степень двойки.\npublic class HalloDouble2 { public static void main(String[] args) { double a = 2; double b = 30; double c = Math.pow(a, b); System.out.println(c); // Выводит на экран 1.073741824E9  } } Достаточно интересный вопрос: что происходит при пересечении разных типов данных? Что произойдёт, если тип переменных int встретится с double? Я подготовил программу без единой строчки комментария. Попробуйте предугадать то, что Java выведет на экран.\npublic class IntToDouble { public static void main(String[] args) { int var1 = 5; int var2 = 2; int var3 = var1 / var2; double var4 = 5.0; double var5 = 2.0; double var6 = var4 / var5; double var7 = var1 / var2; double var25 = var1 / var4; System.out.println(\u0026#34;Int Var3 = \u0026#34; + var3); System.out.println(\u0026#34;double Var6 = \u0026#34; + var6); System.out.println(\u0026#34;double Var7 = \u0026#34; + var7); System.out.println(\u0026#34;double Var25 = \u0026#34; + var25); int var11 = (int) (var1 / var4); System.out.println(\u0026#34;Int Var11 = \u0026#34;+ var11); System.out.println(\u0026#34;Магия \u0026#34; + 5.0/var2); } } Результат работы IntToDouble:\n Int Var3 = 2 double Var6 = 2.5 double Var7 = 2.0 double Var25 = 1.0 Int Var11 = 1 Магия = 2.5  Результат работы подтверждает, что int находится в пределах double и легко может использоваться в расчётах, где результатом будет число типа double. К сожалению, обратное невозможно. Мы должны преобразовать тип данных — произвести Casting. Пример кастования из нашего IntToDouble: int var11 = (int) (var1 / var4), где int в скобках — и есть преобразование.\nПомимо вычисления степени числа, математическая библиотека Java (Math) предлагает нам метод, который генерирует случайное число. Дотошный разработчик скажет, что это не случайное число, а псевдослучайное, но на нашем уровне обучения псевдослучайности достаточно для работы в Java.\nДавайте, в качестве примера, сгенерируем число от 30 до 100:\npublic static void main(String[] args) { int min = 30; int max = 100; int result = (int) (Math.random() * ((max - min) + 1)) + min; System.out.println(result); } Метод Math.random() представляет результат в виде дробных чисел типа double. Нам нужны целые числа, поэтому мы \u0026ldquo;кастуем\u0026rdquo; результат в нужный тип данных.\nМетод Math.random() генерирует дробные числа между 0 и 1. Поэтому мы с помощью арифметики приводим случайное число между нулём и единицой в случайное число между 30 и 100. Попробуйте получить число между 1 и 50. Поэкспериментируйте с этим методом. Он нам понадобится не один раз.\nМетод Math.random() является одним из многих подготовленных для вас методов, которые часто требуются при программировании. Возведение в степень, число PI, логарифмы и многое другое. Вы можете ознакомиться с официальной документацией к библиотеке Math — здесь\nОстался, может быть, вопрос, что использовать? Если нет особой надобности в учебных целях или для скорости разработки — используйте double и int. Остальные типы данных требуют более бережного отношения и внимания.\nДомашнее задание #   Написать программу для вычисления площади круга. Найти длину окружности. Написать формулу вычисления стоимости Евро, если курс Евро к Доллару 1,1. Найти соотношение площади Беларуси к площади Украины. Найти, во сколько раз площадь Москвы больше площади Берлина. Если клиент положил в банк 1000€ под 3,5%, какая сумма будет его ждать через семь лет?  Дополнительные материалы #   Полезная библиотека - Math Конвенция java договор о правописании и синтаксисе Округление чисел - https://geekbrains.ru/posts/java_round  "});index.add({'id':19,'href':'/school/java/basic-course/004-java-char-string/','title':"004 Java Char String",'content':"Типы данных char и String: примеры применения — введение в Java 004 #  Char #    Таблица символов   Если в программе нужны символы, то для этого мы пользуемся типом данных char. Например:\npublic class HelloChar { public static void main(String[] args) { char zahl = 100; // Сотый по счёту символ в таблице  char octal = \u0026#39;\\u039A\u0026#39;; // Вызов определённого символа кодом  char zeichen = \u0026#39;A\u0026#39;; // Буква A  char tabulator = \u0026#39;\\t\u0026#39;; // В русском языке клавиша называется \u0026#34;Таб\u0026#34;  // Табулятор  char phi = \u0026#39;\\u03A6\u0026#39;; // Греческая буквая Фита - PHI  System.out.println(zahl); System.out.println(octal); System.out.println(zeichen); System.out.print(tabulator); System.out.println(phi); } } Объект базового (примитивного) типа char является 16-битным символом Unicode.\nМы можем вывести любое сообщение или любой символ. однако достаточно сложно вывести на экран кавычки, ведь в них мы и держим значения наших переменных. Для таких случаев мы используем экранирование. С помощью обратной косой черты(обратный слеш) мы экранируем символ или используем её для дополнительных параметров.\n\\b Backspace (Курсор двигается на одно место влево) \\n Newline (Новая строчка) \\f Newpage (Новая страница) \\r Carriage return (Курсор становится на первое место в строчке, возврат каретки) \\t Горизонтальный табулятор \\\u0026quot; Двойная кавычка \\' Одинарная кавычка \\\\ Backslash(вызов обратного слэша) \\___ Символы с октальным значением от 000 до 377, например \\304 соответствует символу Ä \\u___ Вызов символа уникода (Unicode-16). Где например \\u00C4 соответствует Ä Таблица символов Windows (charmap) вызывает и показывает именно те символы, которые можно вызвать в Java.\nString #  Мы можем хранить в программе и набор символов: пароль, фамилию, звание, название улицы или просто набор символов. Для хранения таких данных можно использовать String. Пример использования:\npublic class HelloString { public static void main(String[] args) { String firstname = \u0026#34;Andrej\u0026#34;; String secondname = \u0026#34;Podlubnyj\u0026#34;; char copyright = \u0026#39;\\u00A9\u0026#39;; int old = 18; System.out.println(firstname + \u0026#34; \u0026#34; + secondname + \u0026#34; \u0026#34; + old); String student = firstname + \u0026#34; \u0026#34; + secondname + \u0026#34; \u0026#34; + copyright; System.out.println(student); } } Один символ можно записать как \u0026ldquo;маленьким\u0026rdquo; стрингом, так и через символ при помощи типа данных char. Цепочку символов, больше одного, мы храним в типе данных String. Каждый элемент этой цепочки символов можно отобразить при помощи char. Это очень важно понять и запомнить.\nСтроковый набор символов класса String может немного больше, чем просто хранить строчку в переменной. Например, мы можем вычислить количество символов или длину String, используя один из методов, которые есть в Java. Это примерно такие же методы, как те, что мы использовали в предыдущих уроках, чтобы возводить числа в степень или выводить результаты на экран:\nint dlina; dlina = student.length(); System.out.println(dlina); Для переменных типа String ява заготовила много дополнительных методов, которые делают нашу жизнь проще. Например метод substring, который вырезает из одной цепочки символов другую.\nНапример:\npublic class WhatCanYouDoString { public static void main(String[] args) { String name = \u0026#34;AndrejPodlubnyj\u0026#34;; int dlina = name.length(); System.out.println(name); System.out.println(dlina); // вырезать символы с 6-го по 15-ый \tString firstName = name.substring(6,15); dlina = firstName.length(); System.out.println(firstName); System.out.println(dlina); } } Если мы пишем приложение для веб-сайта с \u0026ldquo;user generated content\u0026rdquo;, то мы можем столкнуться с тем, что часть контента пишется заглавными буквами. В Java есть методы, которые приводят цепочку символов алфавита к прописным (заглавным) или к строчным (маленьким) буквам. Давайте рассмотрим пример:\npublic class UppercaseAndLowercase { public static void main(String[] args) { String articleTitle = \u0026#34;london is the capital\u0026#34;; articleTitle = articleTitle.substring(0,1).toUpperCase() + articleTitle.substring(1); System.out.println(articleTitle); articleTitle = articleTitle.toUpperCase(); System.out.println(articleTitle); System.out.println(articleTitle.toLowerCase()); } } С помощью метода toUpperCase() мы делаем буквы прописными, с помощью метода toLowerCase() мы приводим значение строки к строчным буквам.\nМы обязательно вернёмся к этому и другим возможностям класса. Пока надо только запомнить, что, если мы хотим создать записную книжку, то фамилию и имя абонента мы скорее всего будем хранить с помощью типа данных String.\nЯвные и неявные преобразования #  Значения, передаваемые переменным, можно привести в тот тип данных, которые переменная может принять. Вручную или автоматически, или явно и неявно.\n  преобразование типов данных   Расширение типа (widening Casting), которое можно проследить на схеме с помощью стрелок, происходит автоматически. Это преобразование меньшего типа данных в типа большего размера: byte -\u0026gt; short -\u0026gt; char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double.\nСужение типа (narrowing Casting) — преобразование типа данных большего размера в тип данных меньшего размера — делается вручную: double -\u0026gt; float -\u0026gt; long -\u0026gt; int -\u0026gt; char -\u0026gt; short -\u0026gt; byte\npublic class MyClass { public static void main(String[] args) { int myInt = 9; double myDouble = myInt; // Automatic casting: int to double  System.out.println(myInt); // Outputs 9  System.out.println(myDouble); // Outputs 9.0  } } public class MyClass { public static void main(String[] args) { double myDouble = 9.78; int myInt = (int) myDouble; // Manual casting: double to int  System.out.println(myDouble); // Outputs 9.78  System.out.println(myInt); // Outputs 9  } } Повышение типа на примере\npublic class Main { public static void main(String[] args) { byte b = 42; char c = \u0026#39;a\u0026#39;; short s = 1024; int i = 50_000; float f = 5.67f; double d = .1234; double result = (f * b) + (i / c) - (d * s); System.out.println((f * b) + \u0026#34; + \u0026#34; + (i / c) + \u0026#34; - \u0026#34; + (d * s)); System.out.println(\u0026#34;result = \u0026#34; + result); } } Допустим, у нас имеется старая база данных, где все данные записаны в строковом виде. Например просто текстовый файл столбиком. Java даёт нам возможность \u0026ldquo;спарсить\u0026rdquo; целочисленные данные из строк.\nString number = \u0026quot;10\u0026quot;; int result = Integer.parseInt(number); System.out.println(result); Дополнительные материалы #   По ссылке можно посмотреть все методы, которые поддерживает тип данных String. Сервисы \u0026ldquo;быстрая ссылка\u0026rdquo; и онлайн-компиляторы:   https://www.tutorialspoint.com/compile_java_online.php https://ideone.com/ytQajk https://www.browxy.com/  Домашнее задание #   Найти в интернете таблицы для типа данных char. Проверить, что они действительно соответствуют тому, что выводит Java на экран. Найти \u0026ldquo;смешные\u0026rdquo; символы, символ стандартного смайлика, найти символ телефона, параграфа, копирайта(C), торговой марки(тм), рубля, евро, доллара, знаков зодиака, шахмат, червы. Вбить в поисковую строку Windows \u0026ldquo;charmap\u0026rdquo;. Найдите самостоятельно статьи на тему:  Что такое юникод? Что такое ASCII? Что такое UTF?   Что будет, если сложить переменную String с самой собой? Можно ли умножить её на саму себя? Почему? Вывести на экран сообщение в кавычках. Например собственное имя + \u0026ldquo;профессия\u0026rdquo;. Вывести на экран построчно анкетные данные: Имя, Фамилия, Адрес, Улица и тд и тп. Пример вывода одной строчки:   Имя пользователя: Андрей\n   Вырезать из выражения \u0026ldquo;Вход разрешён\u0026rdquo; последние 8 символов и добавить \u0026ldquo;воспрещён\u0026rdquo;. Вывести на экран \u0026ldquo;Осторожно, вход воспрещён\u0026rdquo; заглавными буквами.  "});index.add({'id':20,'href':'/school/java/basic-course/005-java-boolean/','title':"005 Java Boolean",'content':"Тип данных boolean и логические операторы — введение в Java 005 #    Правда или ложь   Boolean #  Boolean в Java — это логический тип данных. Переменная типа boolean может принимать всего два значения — это правда или ложь — true \u0026amp; false. Эти два значения обозначаются в других языках и часто выдаются на экран как 1 и 0, но всё же не равны этим значениям: например, выражение boolean b = 0; приведёт к ошибке при компиляции программы. Но мы можем сравнить переменные или выполнить логическую операцию с типом данных boolean:\nint a = 1, b = 2; boolean bool = a \u0026lt;= b; Говоря о булевых или логических типах данных, нам придётся освежить свои воспоминания о булевой алгебре и возможных логических операциях.\nТаблица истинности #     a b a \u0026amp; b a I b a ^ b ! a     false false false false false true   false true false true true true   true false false true true false   true true true true false false    Давайте представим себе пример из жизни: мы ищем на сайте все статьи, которые мы опубликовали и комментировали. Должны быть два совпадения — это вариант a \u0026amp; b. Или мы ищем все статьи, в которых есть упоминание слов \u0026ldquo;алгебра\u0026rdquo; или \u0026ldquo;математика\u0026rdquo; — это a | b. А отыскать все статьи, которые написаны не нами, можно, применив логический оператор !a.\nИ так далее, и так далее. Ключевые слова для повторения школьного материала: таблица истинности, булева алгебра, теория множеств, конъюнкция, дизъюнкция.\nС помощью таблицы с результатами логических операций можно перепроверить работу Java:\npublic class NewBoolean { public static void main(String[] args) { boolean a, b, c; a = true; b = false; c = a \u0026amp; b; System.out.println(c); // returns false because only one of the two required values​is true  int d = 1, f = 2; boolean bool = d \u0026lt;= f; int i = 10; int j = 9; System.out.println(i \u0026gt; j); // returns true, because 10 is higher than 9  System.out.println(10 == 15); // returns false, because 10 is not equal to 15  int x = 10; System.out.println(x == 10); // returns true, because the value of x is equal to 10  } } Надо понимать, что значение вашего чекбокса (галочки) на сайте Facebook при регистрации — \u0026ldquo;с правилами ознакомлен и согласен\u0026rdquo; — и есть значение булевой переменной в программе.\nЛогические операторы, которые поддерживаются Java #     Логический операторы Значение     == Проверка на соответствие (допустим, что a равен b)   != Не равно (если a не равно b, то)   ! Отрицание, логическое не   \u0026amp; Логическое И, and   | Логическое или, or    ^ Исключительное или, XOR   \u0026amp;\u0026amp; Укороченный \u0026amp;   || Укороченный или    Амперсанд — это название знака \u0026amp;.\nМы ещё раз рассмотрим данные операторы позже. Пока мы должны понимать, что с арифметическими операторами всё немного сложнее, чем хотелось бы.\nДополнительные материалы #   Булева алгебра — самое важное Булева алгебра Теория множеств Очень неплохая статья simulator — симулятор логических выражений в электротехнике. Очень помог мне в своё время вспомнить булеву алгебру.  Домашнее задание #   Что выдаст программа, если запросить значения a, b, c, d, e, f? Посчитайте сначала в уме и проговорите вслух, что делает каждая строчка. boolean a = (7+8)*5 \u0026gt; 7+8*5; boolean b = (7+8)*4 != 7+4*5; boolean c = 3+4 \u0026gt; 9+1 \u0026amp; 16-5 \u0026gt; 3*4; boolean d = 16/2 \u0026lt; 6+2 | 4+5 \u0026lt;= 4*5; boolean e = !(3*4 \u0026lt; 7+8);  Напишите программу и проверьте свои результаты. Сравните строчку вывода со своей: System.out.println(a + \u0026quot;\\n\u0026quot; + b + \u0026quot;\\n\u0026quot; + c + \u0026quot;\\n\u0026quot; + d + \u0026quot;\\n\u0026quot; + e);  Повторение String: Найдите метод из официальной библиотеки и покажите его работу. По возможности используйте printf.  Булева алгебра #  Булева алгебра, ударение на первый слог. БУлева.\nПринципиально основы булевой алгебры не должны были давать в школе. Программисты учат её в институте.\nДавайте я попробую на пальцах рассказать основы и то, что нам понадобится на минимальном уровне.\nДизъюнкция #   Когда мама ИЛИ папа дают мне деньги на карманные расходы, то я бегу и покупаю себе мороженное.\n Знакомая ситуация, деньги можно получить в трёх случах из четырёх. В одном случае же деньги может дать и мама, и папа, тогда и друга можно угостить мороженным.\nЭто дизъюнкция.\nДизъюнкция - логическое сложение, логическое ИЛИ, включающее или, просто \u0026ldquo;или\u0026rdquo;(англ. OR; нем. ODER) В Java операторы \u0026ldquo;|\u0026rdquo; и \u0026ldquo;||\u0026rdquo;\nboolean a = false, b = true, c; c = a | b; Пример в технике; дублирование выключателя или кнопки, дверной звонок и звонок у калитки вызывают одну и туже реакцию - включается мелодия звонка.\nКонъюнкция #  Конъюнкция - логическое \u0026ldquo;И\u0026rdquo;, логическое умножение, просто \u0026ldquo;И\u0026rdquo;, \u0026ldquo;AND\u0026rdquo;, \u0026quot;\u0026amp;\u0026quot;.\nВ Java оператор \u0026quot;\u0026amp;\u0026quot; и \u0026quot;\u0026amp;\u0026amp;\u0026quot;.\nboolean a = false, b = true, c; c = a \u0026amp; b;  Если светит солнце \u0026ldquo;И\u0026rdquo; у меня выходной, то я иду купаться на озеро.\n Пример из жизни. Ядерный чемоданчик могут активировать только два офицера одновременно. По отдельности чемодан остаётся неактивным.\nАнтиваленц #  \u0026ldquo;XOR\u0026rdquo;, эксклюзивное или, \u0026ldquo;EOR\u0026rdquo;, \u0026ldquo;EXOR\u0026rdquo;. В Java оператор \u0026ldquo;^\u0026rdquo;.\nboolean a = false, b = true, c; c = a ^ b;  Только на горных лыжах в Австрии или на лошадях у бабушки в деревне я забываю про свою работу.\n  Или ты садишься за математику или я расскажу всё отцу.\n ИЛИ - ИЛИ. Исключительное или.\nЛампочка в больнице может работать от городского электричества или от дизельного генератора в подвале. Но не от двух источников одновременно.\nОтрицание #  Negation. NOT. В Java оператор \u0026rdquo;!\u0026quot;.\nboolean a = false, b; b = !a; Давайте представим огромный станок по продольной распилке леса. В цеху есть две кнопки. Зелёная и красная. При включении зелёной пила должна работать. При нажатии на красную пила должна остановится.\nДомашнее задание #  Задача. Петя, Вася и Маша остались дома одни. Кто-то из них ел варенье. На вопрос мамы, кто это сделал, они сказали:\n Петя: \u0026ldquo;Я не ел. Маша тоже не ела.\u0026rdquo; Вася: \u0026ldquo;Маша действительно не ела. Это сделал Петя\u0026rdquo; Маша: \u0026ldquo;Вася врет. Это он съел.\u0026rdquo;  Выясните, кто ел варенье, если известно, что двое из них оба раза сказали правду, а третий один раз соврал, а один раз сказал правду.\nОтвет к задаче для собственной сверки\n"});index.add({'id':21,'href':'/school/java/basic-course/006-java-switch-case/','title':"006 Java Switch Case",'content':"Switch и Case: оператор выбора — введение в Java 006 #  В этом уроке мы рассмотрим на примерах оператор выбора Switch и опции выбора Case.\nПример:\n За пятёрку в четверти по математике папа обещал мне велосипед. За четвёрку в четверти по математике мама купит мне GoPro4. За тройку меня, наверное, не будут ругать. За двойку меня отругают. За единицу меня \u0026ldquo;убьют\u0026rdquo;.    Опять двойка   Типичный жизненный пример, который можно написать на Java:\npublic class SwitchOne { public static void main(String[] args) { int оценкаВЧетверти = 1; String награда; switch (оценкаВЧетверти) { case 5: награда = \u0026#34;Велосипед\u0026#34;; break; case 4: награда = \u0026#34;GoPro4\u0026#34;; break; case 3: награда = \u0026#34;Награды не будет\u0026#34;; break; case 2: награда = \u0026#34;Потерянный час времени и плохое настроение\u0026#34;; break; case 1: награда = \u0026#34;Лучше не спрашивайте\u0026#34;; break; default: награда = \u0026#34;Такой оценки не существует\u0026#34;; break; } System.out.println(награда); } } Мы видим, что каждая оценка заканчивается брейком: если брейк не ставить, то выбор селектирует следующую награду. Удобно, если у нас одинаковый результат на несколько переменных. Заканчивается ввод данных дефолтным выбором, который выдаётся при получении непредусмотренных данных или, лучше сказать, всех остальных неуказанных.\nПри наличии множественных выборов удобно использовать Switch и Case. Направо пойдёшь коня потеряешь, прямо\u0026hellip;. Это именно тот случай, где уже можно использовать такой алгоритм действий.\nПервый же пример из поиска приведёт нас к календарю. Это наиболее используемый пример в учебниках. 12 месяцев с уникальным названием и ID:\npublic class SwitchDemoCalendar { public static void main(String[] args) { int month = 8; String monthString; switch (month) { case 1: monthString = \u0026#34;January\u0026#34;; break; case 2: monthString = \u0026#34;February\u0026#34;; break; case 3: monthString = \u0026#34;March\u0026#34;; break; case 4: monthString = \u0026#34;April\u0026#34;; break; case 5: monthString = \u0026#34;May\u0026#34;; break; case 6: monthString = \u0026#34;June\u0026#34;; break; case 7: monthString = \u0026#34;July\u0026#34;; break; case 8: monthString = \u0026#34;August\u0026#34;; break; case 9: monthString = \u0026#34;September\u0026#34;; break; case 10: monthString = \u0026#34;October\u0026#34;; break; case 11: monthString = \u0026#34;November\u0026#34;; break; case 12: monthString = \u0026#34;December\u0026#34;; break; default: monthString = \u0026#34;Invalid month\u0026#34;; break; } System.out.println(monthString); } } В результате работы данной конструкции мы получаем переменную с нужным значением. В последнем случае \u0026ldquo;monthString\u0026rdquo;, или в случае с оценкой, \u0026ldquo;награда\u0026rdquo;. Абсолютно простая конструкция, где самое сложное — синтаксис, который просто надо выучить. И, после написания 30 различных примеров без шпаргалок, он в крови.\nДля закрепления рассмотрим ещё один пример:\npublic class SwitchCoffee { public static void main(String[] args) { int a = 1; //номер кнопки в кофе-автомате \tswitch (a) { case 1: System.out.println(\u0026#34;Кофе американо готовится\u0026#34;); break; case 2: System.out.println(\u0026#34;Кипяток сейчас будет\u0026#34;); break; case 3: System.out.println(\u0026#34;Кофе эспрессо готовится\u0026#34;); break; case 4: System.out.println(\u0026#34;Какао уже в пути\u0026#34;); break; case 5: System.out.println(\u0026#34;Вода кипятится\u0026#34;); System.out.println(\u0026#34;Кофе мелется\u0026#34;); System.out.println(\u0026#34;Сливки добавляются\u0026#34;); break; default: System.out.println(\u0026#34;повторите свой выбор, напиток под номером: \u0026#34; + a + \u0026#34; Временно недоступен\u0026#34;); break; } System.out.println(\u0026#34;Программа отработана без ошибок\u0026#34;); } } Можно заметить, что в пятом кейсе последнего примера с кофе-автоматом запускается множество сообщений. Мы можем использовать один кейс для запуска нескольких директив. Но это не рекомендуется из-за плохой читаемости кода. Обычно Switch используется для изменения одной переменной. Но это не значит, что вы такого не встретите в чужом коде.\npublic class CoffeeMashine { public static void main(String[] args) { int choose = 2; myChoose(choose); } public static void myChoose(int choose) { switch (choose) { case 3: latte(); break; case 2: americano(); break; case 1: cappucino(); break; default: americano(); } } public static void latte() { System.out.println(\u0026quot;---\u0026quot;); System.out.println(\u0026quot;We are created latte for you master\u0026quot;); milk(40); coffee(30); water(70); System.out.println(\u0026quot;---\u0026quot;); } public static void cappucino() { System.out.println(\u0026quot;---\u0026quot;); System.out.println(\u0026quot;We are created cappucino for you master\u0026quot;); milk(30); coffee(40); water(20); System.out.println(\u0026quot;---\u0026quot;); } public static void americano() { System.out.println(\u0026quot;---\u0026quot;); System.out.println(\u0026quot;We are created americano for you master\u0026quot;); milk(0); coffee(40); water(10); System.out.println(\u0026quot;---\u0026quot;); } public static void water(int ml) { System.out.printf(\u0026quot;Added %d ml of water \\n\u0026quot;, ml); } public static void milk(int ml) { System.out.printf(\u0026quot;Added %d ml of milk \\n\u0026quot;, ml); } public static void coffee(int ml) { System.out.printf(\u0026quot;Added %d ml of coffee \\n\u0026quot;, ml); } } Перед домашним заданием хочется привести ещё один пример применения Switch/Case в жизни: обычный лифт в многоэтажном здании. В зависимости от номера нажимаемой кнопки, лифт едет (ожидаемо) на нужный этаж. Оператор выбора Switch используется вокруг вас везде.\n  Лифт   Дополнительные материалы #  https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\nДомашнее задание #   Напишите программу действий кассира магазина, если у него пытаются купить алкоголь следующие 5 покупателей: 10 лет, 17 лет, 18 лет, 20 лет и 30 лет. Напишите программу, которая определяет сезон года. Месяца указаны int переменными.  "});index.add({'id':22,'href':'/school/java/basic-course/007-java-if-else/','title':"007 Java if Else",'content':"Условный оператор if, if-else — 6введение в Java 007 #    если, то   В прошлом уроке я рассматривал оператор выбора Switch. Оператор IF имеет схожие функции и примерно те же цели. Основные отличия — в используемых условиях. Кстати, как обычно, верить мне необязательно: можно спросить у Google, например \u0026ldquo;java switch vs if сравнение\u0026rdquo;. Только на Хабре я нашёл несколько статей, рассматривающих эстетическую сторону вопроса, вопрос скорости, эффективности и вопрос используемых методов.\nПример: поездка в летний лагерь.\nЕсли от родителей будет разрешение (true), то я поеду в летний лагерь. Иначе я останусь на всё лето дома.\nif (true){ System.out.println(\u0026#34;я поеду в летний лагерь\u0026#34;); } else { System.out.println(\u0026#34;я останусь на всё лето дома\u0026#34;); } Switch нет смысла использовать с булевыми значениями: т.к. это всего два варианта. И это одно из отличий if-else и switch.\nСразу про плюсы: If-else позволяет запускать несколько (больше) одной команд.\npublic class IfElseKosmo { public static void main(String[] args) { int a = 5; final int SUPERCONSTANT_G = 10; // модификатор final обозначает константность переменной, которую невозможно изменить.  // например, ускорение свободного падения на поверхности Земли или  // PI, которое всегда константо. Кроме этой особенности final на результаты вычисления  // не влияет  if (a \u0026lt; SUPERCONSTANT_G){ System.out.println(\u0026#34;Первоночальное ускорение недостаточно\u0026#34;); System.out.println(\u0026#34;Ракета не может стартовать\u0026#34;); System.out.println(\u0026#34;Подготовить аварийные службы\u0026#34;); } else { System.out.println(\u0026#34;Ракета улетает в космос\u0026#34;); System.out.println(\u0026#34;Выпустить пресс-релиз об успешном запуске\u0026#34;); System.out.println(\u0026#34;Подготовить программистов к государственным наградам\u0026#34;); } } } В предыдущем уроке был очень жизненный пример про кассира, алкоголь и несовершеннолетних. В Switch нельзя указать \u0026ldquo;младше 18\u0026rdquo;. А в if else можно:\npublic class AlkogolIfElse { public static void main(String[] args) { int возрастПокупателя = 40; if (возрастПокупателя \u0026lt; 16){ System.out.println(\u0026#34;Алкоголь и сигареты продавать нельзя!!!\u0026#34;); } else if (возрастПокупателя \u0026gt;= 18){ System.out.println(\u0026#34;Можно продавать алкоголь и сигареты\u0026#34;); } else { System.out.println(\u0026#34;Водку продавать ещё нельзя, а пиво и сигареты уже можно\u0026#34;); } } } Переменные набраны кириллицей в учебных целях и, чтобы показать, что такое может пройти. Но считается плохим и очень плохим тоном использовать не ASCI символы в переменных.\nИногда программисты печально шутят, что вся жизнь кодера состоит из написания различных if else и Switch команд. Отчасти так и есть. В фундаменте Java не так много команд. И одну из самых часто употребляемых вы только что изучили.\n  Витязь   Дополнительные материалы #   The if-then and if-then-else Statements: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/if.html  Домашнее задание #   Напишите программу действий для сотрудника дорожной полиции, который остановил машину:  при езде до 50 км/час нарушений нет; за езду от 50 км/час до 65 км/час — устное порицание и лекция на 5 минут; за превышение скорости от 16 км/час — 40 евро штрафа; за езду от 100 км/час до 130 км/час — штраф 500 евро; и за езду свыше 130 км/час — штраф в 1000 евро, конфискация прав на 3 года и конфискация транспортного средства.   Напишите программу, которая объяснит наступление определённых событий, в зависимости от выбора \u0026ldquo;витязя\u0026rdquo;. Напишите программу для машины на светофоре. Что делать, если горит красный, жёлтый или зелёный свет. Напишите программу выдачи денег работнику с учётом надбавки за стаж, если базовая зарплата 500$. За 3 года работы надбавка 10%, за 5 лет работы надбавка 50%, за 10 лет работы надбавка 100%, за 15 лет работы надбавка 150%. Метод вывода даты на экран монитора принимает 3 целочисленных значения(день, месяц, год) и разделитель (например \u0026ldquo;-\u0026quot;). Проверить значения данных на адекватность, и если надо дописать нули.\n- 5.6.2020 должно быть выведено на экран как \u0026ldquo;05-06-2020\u0026rdquo; - 50.40.2020 не должно быть выведено вообще  "});index.add({'id':23,'href':'/school/java/basic-course/008-java-modulo/','title':"008 Java Modulo",'content':"Modulo — модуль деления, введение в Java 008 #  Modulo — в специализированной литературе \u0026ldquo;modulo\u0026rdquo; называется оператором деления по модулю или взятием модуля деления. В Java обозначается знаком \u0026ldquo;процентов\u0026rdquo; - %.\nИспользуется это в программировании, например для перевода десятичных чисел в двоичные. Не надо путать этот оператор с делением \u0026ldquo;/\u0026rdquo;. Замечу, что в Википедии на данный момент по запросу modulo выводится статья про \u0026ldquo;деление с остатком\u0026rdquo; . На мой взгляд это очень сильно дезориентирующие определение. Модуль деления — это вычисление остатка от деления целых чисел. Хотелось бы привести оба оператора и показать разницу.\n56 % 24 = 8; 56 / 24 = 2; 24 дважды помещается в 56 и ещё в остатке имеем 8. Читается это так : — Целочисленный остаток от деления 56 на 24 равно 8.\nЯ выговариваю это так: \u0026ldquo;56 модуло 24 равно 8\u0026rdquo;\nС делением дела обстоят немного по другому. Если мы говорим только о целых числах \u0026ldquo;int\u0026rdquo;, то при делении 56 на 24 получаем 2.\nПростейший пример в Java выглядит вот так:\npublic class Modulo { public static void main (String[] args ) { int x = 85; int y = 7; System.out.println(x + \u0026#34; mod \u0026#34;+ y + \u0026#34; = \u0026#34; + x % 7); System.out.println(x + \u0026#34; / \u0026#34;+ y + \u0026#34; = \u0026#34; + x / 7); } } На экране мы получаем:\n85 mod 7 = 1 85 / 7 = 12 Дополнительная литература #   Деление с остатком  Домашнее задание #   Напишите программу, которая находит чётные числа. Напишите программу, которая находит нечётные числа. Напишите программу, которая находит числа кратные 11. Напишите программу, которая находит простые числа. Дано число меньше 3000. При делении числа на 32 получается остаток 30, при делении на 58 - остаток 44. Найдите число или числа. Напишите программу, которая проверяет год на високосность. Кратный четырём. Прочитайте в Википедии, какие года являются високосными и дополните предыдущую задачу.  "});index.add({'id':24,'href':'/school/java/basic-course/009-java-arithmetic-operators/','title':"009 Java Arithmetic Operators",'content':"Операторы в Java — введение в Java 009 #  Мы уже использовали многое в наших программах не задумываясь. Например знаками знакомыми нам из школьной математики: +, -, = и др.. Пришло время узнать весь список доступных в Java операторов и применение.\nЗаранее скажу, что для введения в Java достаточно понимать первые две таблицы - арифметические операторы и операторы сравнения.\nАрифметические операторы - arithmetic operators #     Оператор Пример использования Пояснение     + a + b Сложение   - a - b Вычитание (также унарный минус)   * a * b Умножение   / a / b Деление   % a % b Деление по модулю   ++ a++ Инкремент, а++ соответствует а = а + 1   \u0026ndash; a\u0026ndash; Декремент, а\u0026ndash; соответствует а = а - 1   += a += b Сложение с присваиванием Выражение a += b эквивалентно значению a = a + b.   -= a -= b Вычитание с присваиванием   *= a *= b Умножение с присваиванием   /= a /= b Деление с присваиванием   %= a %= b Деление по модулю с присваиванием    Знак +, ой, простите, оператор сложения может быть и оператором конкатенации. Конкатенация = объединение, сцепление. Мы с ним знакомы, когда цепляем один String с другим. Мы их не складывали, а конкатенировали.\nОператоры сравнения #  Мы с ними немного познакомились при рассмотрении: тип данных boolean и логические операторы.\n   Оператор Пример Пояснение     == a == b a соответствует(равно) b   != a != b a не соответствует(не равно) b   \u0026gt; a \u0026gt; b а больше b   \u0026gt;= a \u0026gt;= b а больше либо равно b   \u0026lt; a \u0026lt; b а меньше b   \u0026lt;= a \u0026lt;= b а меньше либо равно b   \u0026amp;\u0026amp; a \u0026amp;\u0026amp; b а и b истинны, b оценивается условно (если а ложно, b не вычисляется)   || a || b а или b истинно, b оценивается условно (если а истинно, b не вычисляется)   ! !a а ложно   \u0026amp; a \u0026amp; b AND, а и b истинны, b оценивается в любом случае   | a | b OR, а или b истинно, b оценивается в любом случае   ^ a ^ b XOR, а и b различны (исключительное или, побитовое логическое или)    Побитовые операторы #  Побитовые операторы работают с целыми числами, то есть с типами данных long, int, short, char(!), byte.\n   Оператор Пояснение     ~ Побитовый унарный оператор NOT   \u0026amp; Побитовый AND   \u0026amp;= Побитовый AND с присваиванием   | Побитовый OR   |= Побитовый OR с присваиванием   ^ Побитовый исключающий OR   ^= Побитовый исключающее OR с присваиванием   \u0026raquo; Сдвиг вправо   \u0026raquo;= Сдвиг вправо с присваиванием   \u0026raquo;\u0026gt; Сдвиг вправо с заполнением нулями   \u0026laquo; Сдвиг влево   \u0026laquo;= Сдвиг влево с присваиванием   \u0026raquo;\u0026gt;= Сдвиг вправо с заполнением нулями с присваиванием    Это далеко не простая тема и требует повторения/изучения математической состовляющей. Но теоретически можно изучать Java и дальше, оставив эту тему на когда-нибудь потом, самое главное никому не говорите, что я это сказал. А если серьёзно, то изучив эту тему вы станете на один шаг ближе к \u0026ldquo;стать программистом\u0026rdquo;.\nДоп. ссылки:\n Битовый сдвиг Побитовые операции в Java Побитовые операторы RAID  Логические операторы #     Логический операторы Значение     == Проверка на соотвествие (допустим, что a равен b)   != Неравно (eсли a неравно b, то)   ! Отрицание, логическое не   \u0026amp; Логическое И, and   | Логическое или, or   ^ Исключительное или, XOR   \u0026amp;\u0026amp; Укороченный \u0026amp;   || Укороченный или   \u0026amp;= AND с присваиванием   |= OR с присваиванием   ^= XOR с присваиванием   ?: Тернарный (троичный) условный оператор    Тернарный оператор достаточно интересен, мы его обязательно рассмотрим отдельно в следующих уроках.\nОператоры присваивания #  Операторы присваивания содержат в себе знак равенства =. Все их мы уже рассмотрели в рамках других операторов. И в этом нет никакого противоречия. Java многогранна и её не всегда можно однозначно описать простым языком кожаных мешков. Тот же += является одновременно оператором арифметическим и присваивания.\nЭто не значит, что вы не можете составить таблицу операторов сравнения самостоятельно.\nДля факультативного изучения #    Помимо всего прочего, операторы бывают унарными. Соответственно существуют бинарные и тернарные операторы. Логические операторы \u0026amp;\u0026amp; и || - это укороченные версии операторов \u0026amp; и |.   Отличие заключается в том, что например в укороченной версии (или), если первый операнд имеет значение (true), то выражение сразу становится (true) и второй операнд даже не рассматривается. То же самое и с (и), если первый операнд имеет ложное значение (false), то и все выражение сразу становится (false), второй операнд не рассматривается. И соответственно благодаря тому, что значение второго операнда вычислять не нужно, экономится время и повышается эффективность кода.\nПример:\npublic class AndAnd { public static void main(String[] args) { if(a() \u0026amp;\u0026amp; b()){ //здесь меняем оператор и сравниваем результаты  System.out.println(\u0026#34;Готово\u0026#34;); }else{ System.out.println(\u0026#34;Не получилось\u0026#34;); } } public static boolean a(){ System.out.print(\u0026#34;Hallo \u0026#34;); return false; } public static boolean b(){ System.out.println(\u0026#34;World\u0026#34;); return true; } }   //Если использовать оператор \u0026amp;\u0026amp;, то\n  Hallo Не получилось\n  //Вывод при использовании оператора \u0026amp;\n  Hallo World\n  Не получилось\n  Если должны быть проверены все условия, то надо использовать \u0026amp;. Если речь идёт о быстром и чётком решении, то \u0026amp;\u0026amp; помогает сэкономить ресурсы и время.\nДомашнее задание #   Ознакомьтесь с термином - body mass index (BMI) Индекс массы тела . Напишите программу расчёта индекса массы тела. Если возникнут сложности, помните, что у вас есть все знания, что бы решить данную задачу. Просто решите её сначала на бумаге, а потом перенесите в Java.  Дополнительные материалы #   https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html Прекраснейшая статья о побитовом сдвиге - https://javarush.ru/groups/posts/1925-pobitovihe-operacii https://www.baeldung.com/java-compound-operators  Очень рекомендую последний ресурс - 4. www.baeldung.com. На проекте очень много грамотных постов о Java и из мира Java. Можно ввести в Google запрос \u0026ldquo;baeldung cast int\u0026rdquo; и получить прекрасную статью для самостоятельного изучения конвертации данных из типа данных String в int. Ресурс определённо в закладки.\n"});index.add({'id':25,'href':'/school/java/basic-course/010-java-for/','title':"010 Java For",'content':"Цикл FOR — введение в Java 010 #    петля   Каждый день я встаю в шесть утра и иду на завод к восьми, в семь вечера я уже снова дома, смотрю кино по телевизору, курю с соседом на лестничной клетке и в одиннадцать уже иду спать. Утром вторника повторяется всё то же самое, и в среду, и в четверг, и в пятницу.\nВсё это можно описать, например, с помощью блока if else. Ничего сложного: если понедельник, то подъём; а если вдруг вторник, то тоже подъём; если среда, то подъём и т.д. и т.п. Но кусок кода повторяющийся, и для таких случаев придумали циклы, один из них — цикл FOR. Условно, с понедельника по пятницу выполняется следующий алгоритм действий: подъём, работа, телевизор, спать. Пример:\npublic class FourWeek { public static void main(String[] args) { int weekDays = 7; for (int i = 1; i \u0026lt; weekDays ; i++) { System.out.println(\u0026#34;------------\u0026#34;); System.out.println(\u0026#34;Новый день\u0026#34;); System.out.println(\u0026#34;я встаю в шесть утра\u0026#34;); System.out.println(\u0026#34;иду на завод к восьми\u0026#34;); System.out.println(\u0026#34;я уже дома\u0026#34;); System.out.println(\u0026#34;смотрю кино по телевизору\u0026#34;); System.out.println(\u0026#34;курю с соседом на лестничной клетке\u0026#34;); System.out.println(\u0026#34;иду спать\u0026#34;); System.out.println(\u0026#34;День подошёл к концу\u0026#34;); System.out.println(\u0026#34;-------------\u0026#34;); } } } Область видимости #  Мы можем использовать несколько циклов подряд:\npublic class Main { public static void main(String[] args) { int a = 0; for (int i = 0; i \u0026lt; 10; i++) { a++; } for (int i = 0; i \u0026lt; 20; i++) { a++; } System.out.println(a); System.out.println(i); } } При этом операции над переменной a будут проходить в каждом цикле, потому что a принадлежит к области видимости всего метода. А вот попытка вывести на консоль i приведёт к ошибке. Переменная i, в данном случае, объявлялась только в циклах, и за пределами самого цикла не видна. Именно поэтому мы и смогли декларировать эту переменную дважды. Потому что в самом методе её как бы и нет.\nМы можем экранировать переменные просто скобками:\npublic class Main { public static void main(String[] args) { int a = 0; { int b = 7; a = a + b; } System.out.println(a); System.out.println(b); } } В данном примере попытка \u0026ldquo;распечатать\u0026rdquo; b приведёт к ошибке. Декларация переменной произошла в экранированном участке кода. Но операции с a программа запомнит, потому что программа декларировала a, и закрытый участок кода для а — просто часть программы. Сверху вниз смотреть можно, а снизу вверх смотреть нельзя.\nИ снова к самому циклу for #  Это могут быть и арифметические операции:\npublic class FourTest { public static void main(String[] args) { int a = 20; int b = 11; int c; for (int i = 0; i \u0026lt; a; i++) { b = b + i; c = i + 1; System.out.println(\u0026#34;c \u0026#34; + c); } System.out.println(\u0026#34;b \u0026#34; + b); } } В определённом или в заданном интервале мы изменяем переменную по определённой формуле.\nfor (начало; условие; шаг) { // ... тело цикла ... в котором можно выполнять одну, две, три или даже очень много операций. } for (initialization condition; testing condition; increment/decrement){ statement(s) } For — это цикл, в котором \u0026ldquo;тело\u0026rdquo; выполняется заданное количество раз.\nНачало, условие, шаг #  Начало, условие, шаг надо запомнить не как \u0026ldquo;Отче наш\u0026rdquo;. А \u0026ldquo;Отче наш\u0026rdquo; заменяется теперь на \u0026ldquo;начало, условие, шаг\u0026rdquo;. Ещё один пример, где мы работаем только с одной переменной — отсчёт обратного времени. Именно этот код используется всеми космодромами при запуске ракет в космос:\npublic class TickTackStart { public static void main(String[] args) { for (int i = 10; i \u0026gt; 0; i--) System.out.println(\u0026#34;i= \u0026#34; + i); } } Начало может быть любым. Другой переменной int i = b или любым (обычно int) числом. Например, int i = 7.\nУсловие задаёт рабочий интервал между началом и концом программы.\nШаг может быть любым. Минус два, плюс два, минус 100 или плюс 5000. Шаг мы задаём сами. В шаге мы можем складывать, вычитать, умножать и даже делить: i = 2*i.\nfor (int i = 0; i \u0026lt; 20; i = 2*i){ System.out.println(i); } И это уже домашнее задание #    Определите на глаз, что будет выдано на консоли после запуска последнего куска кода?\n  Даны целые числа A и B, где B \u0026gt; 0. Вывести B раз число A.\n  Вывести в порядке возрастания все числа между А и B, где а = 5, а B = 17.\n  Сколько раз будет выведено сообщение на экран?\nfor (int i = 3; i \u0026lt; 10; i ++){ System.out.println(i); }   \u0026ldquo;Нарисуйте\u0026rdquo; (выведите на консоль) треугольник из звёздочек, используя только одну звёздочку и то, что только что изучили:\n  * ** *** **** ***** ****** ******* ******** ********* ********** Дополнительные материалы #   https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html  "});index.add({'id':26,'href':'/school/java/basic-course/011-java-string-possibilities-and-more/','title':"011 Java String Possibilities and More",'content':"Возможности различных типов данных, литералов в Java — введение в Java 011 #  В четвёртом уроке мы затронули преобразования одних типов данных в другие. Давайте для начала посмотрим, что именно мы тогда учили.\nЯвные и неявные преобразования #  Значения, передаваемые переменным, можно привести в тот тип данных, которые переменная может принять. Вручную или автоматически, или явно и неявно.\n  преобразование типов данных   Расширение типа (widening Casting), которое можно проследить на схеме с помощью стрелок, происходит автоматически. Это преобразование меньшего типа данных в типа большего размера: byte -\u0026gt; short -\u0026gt; char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double.\nСужение типа (narrowing Casting) — преобразование типа данных большего размера в тип данных меньшего размера — делается вручную: double -\u0026gt; float -\u0026gt; long -\u0026gt; int -\u0026gt; char -\u0026gt; short -\u0026gt; byte\nString to int and double #  Помимо уже надеюсь привычного преобразования переменных и литералов из int в double И обратно мы можем большее.\nString number = \u0026quot;10\u0026quot;; int result = Integer.parseInt(number); System.out.println(result); Parse #  English\nThe software parses and filters the incoming data.  Русский\nПрограммное обеспечение разбирает и фильтрует поступающие данные.   int result = Integer.parseInt(\u0026#34;709\u0026#34;); Java разбирает на составные части наш строковый литерал и если в нём содержится целочисленное значение, то успешно записывает его в переменную с типом данных int.\nString.valueOf(3.14) #  Если у нас будет в строковом литерале десятичная дробь, то мы тоже можем \u0026ldquo;вытянуть\u0026rdquo; её.\ndouble pi = 3.14; String myPi = String.valueOf(pi); Магия строки: String to char #  charAt - Что это за символ? #  Мы можем взять из стрингастрокового литерала любой символ и записать его в переменную с типом данных char.\nString name = \u0026quot;Андрей\u0026quot;; char myChar = name.charAt(2); Мы можем узнать числовое значение символьного литерала с помощью хитрости:\nSystem.out.println(0 + myChar); И это нам должно напомнить, что любой чар-литерал легко преобразовывается в инт-литерал. Давайте посмотрим всё сначала и вместе:\nString name = \u0026#34;Андрей\u0026#34;; char myChar = name.charAt(2); System.out.println(0 + myChar); int myInt = myChar; System.out.println(myInt); substring #  Чар-литерал является частью строки. Точно так же мы можем даже \u0026ldquo;вырезать\u0026rdquo; любой символ из строкового литерала.\nString name = \u0026quot;Андрей\u0026quot;; String myLittleString = name.substring(0, 1); Но (пока) он так и останется строковым литералом, просто содержащим в себе один символ. Конечно же существуют ещё несколько возможностей разложить весь стринг на составные части, перебрать их и взять нужный. Но давайте пока разберёмся с\nchar myChar = \u0026quot;Андрей\u0026quot;.charAt(2); // так тоже теоретически можно писать Документация и доступные методы #  Я взял первых семь методов из официальной документации:\n   Modifier and Type Метод Пояснение     char charAt(int index) Returns the char value at the specified index.   int codePointAt(int index) Returns the character (Unicode code point) at the specified index.   int codePointBefore(int index) Returns the character (Unicode code point) before the specified index.   int codePointCount(int beginIndex, int endIndex) Returns the number of Unicode code points in the specified text range of this String.   int compareTo(String anotherString) Compares two strings lexicographically.   int compareToIgnoreCase(String str) Compares two strings lexicographically, ignoring case differences.   String concat(String str) Concatenates the specified string to the end of this string.    Ещё раз и \u0026ldquo;по-русски\u0026rdquo; #     Метод Перевод     charAt(int index) Возвращает значение символа по указанному индексу.   codePointAt(int index) Возвращает символ (Unicode code point) в указанном индексе.   codePointBefore(int index) Возвращает символ (точка Юникода) перед указанным индексом.   codePointCount(int beginIndex, int endIndex) Возвращает количество символов Юникода в указанном текстовом диапазоне данной строки.   compareTo(String anotherString) Сравнивает две строки лексикографически.   compareToIgnoreCase(String str) Сравнивает две строки лексикографически, игнорируя case написания   concat(String str) Конкатенирует эту строку на конец другой строки.    Лично мне перевод мало что сказал. Давайте посмотрим на примерах, что мы можем сделать.\ncharAt мы уже разобрали выше в этой же статье.\ncodePointAt(int index) - пример использования #  String testStr = \u0026#34;Группа студентов\u0026#34;; int result = testStr.codePointAt(1); System.out.println(\u0026#34;Результат проверки метода codePointAt = \u0026#34; + result); На экране мы увидим:\nРезультат проверки метода codePointAt = 1088 codePointBefore(int index) - пример использования #  String str = \u0026#34;I love Java\u0026#34;; System.out.println(\u0026#34;String = \u0026#34; + str); int result = str.codePointBefore(1); System.out.println(\u0026#34;Character(unicode point) = \u0026#34; + result);\tНа экране мы увидим:\nString = I love Java Character(unicode point) = 73 codePointCount(int beginIndex, int endIndex) - пример использования #  System.out.println(); String str = \u0026#34;Мы учимся в школе Telran\u0026#34;; System.out.println(\u0026#34;Оригинальная строка : \u0026#34; + str); // codepoint from index 1 to index 10 int ctc = str.codePointCount(3, 10); // prints character from index 1 to index 10 System.out.println(\u0026#34;Считаем символы = \u0026#34; + ctc); На экране мы увидим:\nОригинальная строка : Мы учимся в школе Telran Считаем символы = 7 compareTo(String anotherString) - пример использования #  Значение 0, если аргумент является строкой, лексикографически равной этой строке; значение меньше 0, если аргумент является строкой, лексикографически большей, чем эта строка; и значение больше 0, если аргумент является строкой, лексикографически меньшей, чем эта строка.\nЛексикографический порядок — отношение линейного порядка на множестве слов над некоторым упорядоченным алфавитом Sigma. Своё название лексикографический порядок получил по аналогии с сортировкой по алфавиту в словаре.\nString str1 = \u0026#34;Строка для теста\u0026#34;; String str2 = \u0026#34;Строка для теста\u0026#34;; String str3 = \u0026#34;Другая строка для теста\u0026#34;; int result = str1.compareTo( str2 ); System.out.println(result); result = str2.compareTo( str3 ); System.out.println(result); result = str3.compareTo( str1 ); System.out.println(result); Результат проверки compareTo(String anotherString):\n0 13 -13 compareToIgnoreCase(String str) - пример использования #  String str1 = \u0026#34;Строка для теста\u0026#34;; String str2 = \u0026#34;сТрОкА дЛя тЕсТа\u0026#34;; String str3 = \u0026#34;Другая строка для теста\u0026#34;; int result = str1.compareToIgnoreCase(str2); System.out.println(result); result = str2.compareToIgnoreCase(str3); System.out.println(result); result = str3.compareToIgnoreCase(str1); System.out.println(result); Результат проверки compareToIgnoreCase(String str):\n0 13 -13 concat(String str) - пример использования #  String str = \u0026#34;Привет\u0026#34;; str = str.concat(\u0026#34; Мир\u0026#34;); System.out.println(str); Результат проверки concat(String str):\nПривет Мир К каждому типу данных существует множество стандартных методов. Важно уметь читать документацию и пользоваться поисковиками.\nДомашнее задание #  Разобраться с методами:\n contains(CharSequence s) endsWith(String suffix) equals(Object anObject) equalsIgnoreCase(String anotherString) isEmpty() length() replace(char oldChar, char newChar) startsWith(String prefix) startsWith(String prefix, int toffset) substring(int beginIndex) toLowerCase() toUpperCase() trim()  Дополнительные ссылки #   Oфициальная документация к String  "});index.add({'id':27,'href':'/school/java/basic-course/012-java-methods-void-return/','title':"012 Java Methods Void Return",'content':"Методы в Java немного подробнее: возвратные и исполняющие — введение в Java 012 #  Главный метод класса #  public static void main(String[] args) Каждый раз пишем эту магическую строку что бы запустить нашу программу. MAIN - обозначает точку входа в программу. Мы можем один раз написать этот метод в главном классе, например Main:\npublic class Main { public static void main(String[] args) { // просто тестирование  } } Следующим методом мы можем написать метод сложения двух целых чисел. Название метода addition мы пишем с маленькой буквы.\n\tstatic void addition (){ int a = 4; int b = 5; int c = a + b; System.out.println(c); } И тогда мы можем в нашей точке входа запустить(вызвать) метод сложения и весь наш класс тогда будет выглядеть вот так:\npublic class Main { public static void main(String[] args) { addition(); } static void addition() { int a = 4; int b = 5; int c = a + b; System.out.println(c); } } Создание класса #  Точно также мы можем создать совсем новый класс для вычисления целых чисел. И назвать его Calculator, и в нём написать наш метод:\npublic class Calculator { static void addition() { int a = 4; int b = 5; int c = a + b; System.out.println(c); } } Аргументы #  Мы можем сделать метод принимающим параметры(атрибуты, аргументы), например так:\n\tstatic void addition (int a, int b){ System.out.println(a+b); } Тогда запустить этот метод в Main можно, давайте сначала подумаем как, а потом попробуем посмотреть:\nCalculator.addition(a, b); //Запускать метод мы можем один или несколько раз Calculator.addition(4, 7); Calculator.addition(17, 25); Метод сам по себе у нас может быть нетронутым и только в месте его вызова мы \u0026ldquo;манипулируем\u0026rdquo; с аргументами.\nТипы методов #  Принципиально в Java два типа методов:\n Исполняемые (void). Эти методы просто исполняют команды. Возвратные. Эти методы всегда что-то возвращают.  Пример метода, который возвращает значение int:\npublic static int devide() { int a = 0; return a; } Пример метода, который возвращает int и принимает два int аргумента\npublic static int devide(int a, int b) { return a / b; } Пример метода, который принимает String, а возвращает int:\npublic static int vornameAndName(String vorname, String name) { int result = vorname.length() + name.length(); return result; } Очень важно понимать, что main вход в программу, с этого метода начинаются необходимые действия. Например на условной кассе в магазине в точке мейн запускается процесс подсчитывания стоимости продуктов, и после этого стоимость передаётся в метод вывода чека на печать и ещё раз на экране у кассира. Нет хороших или плохих методов, удобных или неудобных; это просто инструменты и левша может использовать другие инструменты чем правша. \u0026ldquo;Правильность\u0026rdquo; особо нигде не прописана.\nЕщё один пример. Нам надо поехать в отпуск:\npublic class Main { public static void main(String[] args) { weGoOnVacation(); } static void weGoOnVacation() { // псевдометод, который описывает, что надо сделать что бы поехать в отпуск \tbookFlights(); bookHotel(); packUp(); callTaxi(); excellentMood(); } static void excellentMood() { //каждый из этих методов описывает как добиться поставленной цели. а может вызывать и другие дополнительные методы. \t// например для хорошего настроения нужно отключиться от работы и улететь туда где тепло\t\t} } Зарезервированные слова #     Нельзя использовать в переменных     abstract double int super   boolean else interface switch   break extends long synchronized   byte final native this   case finally new throw   catch float package throws   char for private transient*   class goto* protected try   const* if public void   continue implements return volatile   default import short while   do instanceof static     Модификаторы доступа. Private, protected, default, public #   private; default; protected; public.  Private — наиболее строгий модификатор доступа. Он ограничивает видимость данных и методов пределами одного класса.\nDefault — package visible.\nProtected — package visible.\nProtected data member and method are only accessible by the classes of the same package and the subclasses present in any package. You can also say that the protected access modifier is similar to default access modifier with one exception that it has visibility in sub classes.\nPublic — Кто угодно может этим пользоваться.\n   _ Class Package Subclass(same pkg) Subclass(diff pkg) World     public + + + + +   protected + + + +    no modifier + + +     private +        Модификатор static в Java #  Static показывает, что это метод или переменная класса. На данном этапе большего нам знать пока не надо.\npublic class HelloStatic { private static int count = 10; public static void main(String args[]) { System.out.println(count); //compile time error \t} } Дополнительные материалы #   https://www.oreilly.com/library/view/think-java/9781491929551/ch04.html https://docs.oracle.com/javase/tutorial/java/javaOO/returnvalue.html https://www.baeldung.com/java-methods Ещё раз ссылка с конвенцией (договор о правописании и синтаксисе) - https://www.oracle.com/technetwork/articles/javaee/codeconventions-135099.html https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html  Домашнее задание #   Давайте попробуем написать методы для вычисления площади и периметра фигур: квадрата, прямоугольника, треугольника, круга. И один раз напишем их исполняющими, а один раз возвратными. В обоих случаях методы должны принимать необходимые данные для вычисления: как радиус, длину сторон или прочее. Давайте напишем генератор паролей. Методу передаётся длина пароля. И метод генерирует пароль используя латиницу, цифры и некоторые спецсимволы(на ваш выбор). Подсказка - использовать только те знания, которые были уже изучены. Существует как минимум два(на самом деле 222) разных подхода к решению этой проблемы. Не бойтесь пробовать.  "});index.add({'id':28,'href':'/school/java/basic-course/013-java-while-dowhile/','title':"013 Java While Dowhile",'content':"Цикл While и Do While — введение в Java 013 #  Это самая лёгкая глава. Потому что цикл while — родной брат цикла for.\nПример:\npublic class WhileWeAreYoung { public static void main(String[] args){ int i = 0; while(i \u0026lt; 10){ System.out.println(i); i++; } } } Изученный цикл for мы бы написали так:\npublic static void main(String[] args) { for (int i = 0; i \u0026lt; 10 ; i++){ System.out.println(i); } } В цикле for стоит условие, и в while стоит условие. While цикл только проверяет правильность условия. В какой-то мере while может заменить связку for + if: \u0026ldquo;пока дети младше 18 лет — алкоголь не продавать\u0026rdquo;.\nИногда мы можем предполагать, что операция запустит бесконечный процесс или процесс, который невозможно выполнить современными средствами. Тогда нам помогает break — выход из цикла.\nНапример, такое возможно при подсчёте степени двойки (вспоминаем задачу про шахматную доску) или при подсчёте точного числа PI или при вычислении ряда Фибоначчи.\nwhile (true){ System.out.println(i); i++; if (i \u0026gt; 20) //код break; // выход из цикла } Если вам он кажется достаточно спорным, помните, что ситуации бывают разными.\nУ цикла while есть кузен do-while:\ndo { Команда(); } while(Булевое выражение) Например:\n// Декларирование и инициализация переменной int i = 0; // Команда, которая будет выполнена минимум один раз do { // Команда выполняется трижды System.out.println(\u0026quot;i равно \u0026quot;+ i); // Инкриментирование переменной i+=10; } // Условие выхода из цикла while(i \u0026lt;= 20); Цикл while называют циклом с предусловием.\nЦикл do while — циклом с постусловием.\nВ первом случае (while) код будет выполнен, согласно данным входа, во втором случае (do while) код будет выполнен минимум один раз, и только потом будет проверка на выход из цикла.\nЦикл — определение #  Циклы — это разновидность управляющих конструкций для организации многократного выполнения одного и того же участка кода.\nКод внутри такой управляющей конструкции выполняется циклично. Каждое выполнение кода — это итерация цикла. Количество итераций регулируется условием цикла. Код, который выполняется внутри цикла, называют телом цикла.\nПример использования while #  78 из десятичной системы переводим в двоичные 1001110.\n78 : 2 = 39 остаток: 0 39 : 2 = 19 остаток: 1 19 : 2 = 9 остаток: 1 9 : 2 = 4 остаток: 1 4 : 2 = 2 остаток: 0 2 : 2 = 1 остаток: 0 1 : 2 = 0 остаток: 1 Решение с помощью while\npublic static String convertDecimalToBinary(int decimal) { int remainder; String output = \u0026quot;\u0026quot;; while (decimal \u0026gt; 0) { remainder = (decimal % 2); output = Integer.toString(remainder) + output; decimal = decimal / 2; } return output; } Дополнительные материалы #  While, Do While: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html\nДомашнее задание #   Перепишите примеры из урока 10 с использованием новых знаний. Попробуйте написать вложенные циклы с помощью While и Do-While  "});index.add({'id':29,'href':'/school/java/basic-course/014-java-scanner/','title':"014 Java Scanner",'content':"Scanner — введение в Java 014 #  Я хочу ввести немного магии в наши программы. Мы уже пользовались и пользуемся для вывода результатов командой System.out.println(). Возможность ввода данных через терминал в программу также существует.\nimport java.util.Scanner; public class WhileScanner { public static void main(String[] args) { Scanner input = new Scanner(System.in); int old; System.out.println(\u0026#34;Сколько тебе лет? \u0026#34;); old = input.nextInt(); while (old \u0026gt;= 18){ System.out.println(\u0026#34;Ты можешь купить на вечер что-то более крепкое, чем чай\u0026#34;); break; // выход из цикла \t} } } Удачное ли использование цикла while в примере выше?\nМы снова используем внешнюю библиотеку и в первой строчке мы её импортируем.\nВ строчке Scanner input = new Scanner(System.in); мы объявляем переменную input, которая будет отвечать за введённые в терминал данные.\nОбратите внимание на оператор new – с его помощью мы работаем с \u0026ldquo;непростыми данными\u0026rdquo;. Позже мы к нему вернёмся.\nПока же просто воспользуемся \u0026ldquo;сканером\u0026rdquo; и присвоим значение введённых данных переменной нашей old. С помощью old = input.nextInt(); мы передаём введённые целочисленные данные. Мы можем \u0026ldquo;перехватывать\u0026rdquo; данные любого типа. Просто мы должны записывать их в соответствующие переменные.\nДополнительные материалы #  Подробнее о Scanner\nДомашнее задание #   Напишите программу, которой надо представиться. Данные, которые спрашивает машина: имя, фамилия, пол, возраст, e-mail. Для считывания данных типа String используйте метод next(): input.next() Напишите программу, которая принимает из \u0026ldquo;сканера\u0026rdquo; возраст человека в строке и отдаёт его в вашу переменную int. В четвёртой главе(char, String) мы коротко рассматривали один из способов передачи такой информации. Напишите программу, которой надо представиться. Данные, которые спрашивает машина: имя, фамилия, пол, возраст, e-mail. Для считывания данных типа String используйте метод next(): input.next()  Интерактивные программы - игры #   Компьютер загадывает число от 1 до n. У пользователя k попыток отгадать. После каждой неудачной попытки компьютер сообщает меньше или больше загаданное число. В конце игры текст с результатом (или “Вы угадали”, или “Попытки закончились”). Президент приходит к власти если набрал 51% голосов избирателей. Создайте машину для ввода результатов выборов.  "});index.add({'id':30,'href':'/school/java/basic-course/015-java-binary-and-decimal-issue/','title':"015 Java Binary and Decimal Issue",'content':"Двоичная, десятичная, восьмеричная и прочие системы в Java и преобразования между ними — введение в Java 015 #    символы майя   Для усвоения этого урока достаточно знать циклы for (while, do-while), оператор выбора switch, условный оператор **if **, знание и уверенное пользование арифметическим оператором modulo.\nЭто один из лучших примеров, который показывает, что первоначально абсолютно неподъёмная задача при решении оказывается не такой уж и страшной.\nМы уже рассматривали во главе, которая знакомила нас с while как из десятичных чисел получить двоичные.\nПовторение, 78 превращаем в 1001110.\n78 : 2 = 39 остаток: 0 39 : 2 = 19 остаток: 1 19 : 2 = 9 остаток: 1 9 : 2 = 4 остаток: 1 4 : 2 = 2 остаток: 0 2 : 2 = 1 остаток: 0 1 : 2 = 0 остаток: 1 Давайте переведём двоичное число в десятичное. Давайте возьмём уже известное нам число 1001110. В одном байте восемь битов. Число 1001110 состоит из семи цифр. В таких случая часто дописывают недостающие ноли и 100_1110 превращается в 0100_1110. Это удобно и очень важно при визуализации чисел.\n   Порядковый номер цифры в числе 7 6 5 4 3 2 1 0     Степени двойки 2^7 2^6 2^5 2^4 2^3 2^2 2^1 2^0   Чему в итоге равны степени 128 64 32 16 8 4 2 1   Пример двоичного числа 0 1 0 0 1 1 1 0   Как считается десятичное 0*128 1*64 0*32 0*16 1*8 1*4 1*2 0*1   Результат вычислений 0 64 0 0 8 4 2 0    Сумма чисел из последней строчки 64+8+4+2 = 78\nЕсли с приведёнными примерами всё понятно, то можно перейти дальше и записать оба примера в Java.\nПереведём число из десятичной системы в двоичную, пока не забыли.\npublic static String convertDecimalToBinary(int decimal) { int remainder; String output = \u0026quot;\u0026quot;; while (decimal \u0026gt; 0) { remainder = (decimal % 2); output = Integer.toString(remainder) + output; decimal = decimal / 2; } return output; } И обратно из двоичной в десятичную\npublic static int convertBinaryToDecimal(int binaryDigit) { int decimal = 0; int n = 0; int temp = 0; while (binaryDigit \u0026gt; 0) { temp = binaryDigit % 10; decimal += temp * Math.pow(2, n); binaryDigit = binaryDigit / 10; n++; } return decimal; } Замечу, что это простейший метод преобразования, который работает только с целыми числами больше нуля. Однако краткость этого метода должна помочь понять суть методики. Единственное, что стоит особенно подчеркнуть - результат работы метода строковое значение.\nЕсли поработать над читаемостью метода convertDecimalToBinary, то мы заметим, что у нас (как минимум) дважды используется magicNumber 2 . Если мы догадаемся назвать это число systemIndex, то это будет частью решения метода convertDecimalToAnything.\npublic static String convertDecimalToAnything(int decimalDigit, int systemIndex) { int remainder; String output = \u0026quot;\u0026quot;; while (decimalDigit \u0026gt; 0) { remainder = (decimalDigit % systemIndex); output = Integer.toString(remainder) + output; decimalDigit = decimalDigit / systemIndex; } return output; } Теоретически, можно подумать как из бинарной системы перевести числа в любую другую систему. Но зачем? Если есть метод преобразования бинарного числа в десятичную систему, а потом в любую другую.\nУ нас только одна проблема, наша система работает с числами систем меньше десятичной. Для того, что бы нам одолеть системы свыше десятичной, нам надо понять, что происходит с числом, когда его делят на 11, 12, 13, 14, 15, 16 и так далее. И здесь нам должен помочь switch, который будет перехватывать результаты деления свыше 10 и подставлять в output вместо числовых значений буквенные A, B, C, D, E, F и так далее.\nРекомендую в рамках Java ограничиться целыми позитивными числами до шестнадцатеричной системы. Она нам важна, так как в ней информатике хранят цветовую гамму.\nДополнительные ссылки #   Бинарные(двоичные) числа в Java - официальная документация. Троичный компьютер  Шестнадцатеричная система Двадцатиричная система Шести десятеричная Двенадцатеричная система счисления Цифры майя  Домашнее задание #   Ознакомиться со всеми дополнительными ссылками. Написать метод, который \u0026ldquo;вычитывает из строковых литералов десятичные и двоичные числа. Используйте метод - \u0026quot; Integer.parseInt(); Написать свой собственный класс ConvertDigits  добавить интерактивность, общение программы с пользователем. не использовать цикл while.    Задачи с очень повышенным уровнем сложности. #   Написать метод, который решает вопрос с делением на числа из систем свыше десятичной - 11-16. (Факультатив)Написать метод перевода числа из \u0026ldquo;любой\u0026rdquo; системы в десятичную. // Мы вернёмся к этому методу в будущем.  "});index.add({'id':31,'href':'/school/java/basic-course/016-java-ternary-operator/','title':"016 Java Ternary Operator",'content':"Тернарный оператор \u0026ldquo;?:\u0026rdquo; — введение в Java 016 #  Выражение:\nif (условие) { number = 10; } else { number = -10; } Можно заменить на\nnumber = (условие) ? 10 : -10; То есть ?: укороченный условный оператор if, if-else из седьмого урока\nпеременная = (выражение) ? значение if true : значение if false public static void ternar(int schoolАttestat){ String resultAtHome = \u0026quot;\u0026quot;; resultAtHome = (schoolАttestat \u0026gt;= 3) ? \u0026quot;Ребёнок переходит в следуюший класс\u0026quot; : \u0026quot;Ребёнок остаётся на второй год\u0026quot;; System.out.println( \u0026quot;Результат учёбы за год: \u0026quot; + resultAtHome); } Ещё пример для закрепления:\nclass TernarOperator { public static void main(String[] args) { Double kelvin = -273.15; String result; result = (kelvin \u0026gt; 0.0) ? \u0026#34;positive\u0026#34; : \u0026#34;not positive\u0026#34;; System.out.println(number + \u0026#34; is \u0026#34; + result); } } Рекурсивный метод нахождения факториала для будущего урока можно записать так:\n static int fact(int num) { return ((num \u0026gt; 1) ? num * fact(num - 1) : 1); } Тернарный оператор применяют когда абсолютно простая операция может иметь два варианта развития. Это так называемый синтаксический сахар. Помогает быстрее и лаконичнее писать код.\nЯ несколько раз видел, как тернарный оператор вкладывают один в другого. Я не буду приводить пример, потому что моё личное мнение - такой код абсолютно нечитаем.\nДополнительная ссылка #  https://www.baeldung.com/java-ternary-operator\nДомашнее задание #   Компьютер загадывает число от 1 до n. У пользователя k попыток отгадать. После каждой неудачной попытки компьютер сообщает меньше или больше загаданное число. В конце игры текст с результатом (или “Вы угадали”, или “Попытки закончились”).  "});index.add({'id':32,'href':'/school/java/basic-course/017-java-recursion-intro/','title':"017 Java Recursion Intro",'content':"Рекурсивные методы в Java — введение в Java 017 #    рекурсия экрана   Многие из нас пытались сфотографировать себя в зеркале так, что бы в зеркале было снова изображение фотографирующего в зеркале и так до бесконечности. Это и есть частный случай рекурсии. В программировании это - метод, вызывающий(повторяющий) сам себя.\nРекурсия в программировании #  Давайте попробуем найти факториал числа\npublic class Factorial{ static int calculateFactorial(int n){ int result = 1; for (int i = 1; i \u0026lt;=n; i ++){ result = result*i; } return result; }\tpublic static void main(String[] args){ System.out.println(calculateFactorial(4)); } } То же самое можно сделать и рекурсивным способом\n// Вычисление факториала числа public class Factorial{ public static void main(String[] args) { System.out.println(fact(5)); } static int fact(int digits) { if (digits \u0026gt; 1) { return digits * fact(digits - 1); // здесь переменная умножается на метод \t} else { return 1; } } } Ещё раз:\n{ if (digits \u0026lt;= 1) // Базовый случай { return 1; } else { return digits * fact(digits - 1); // рекурсивный вызов с аргументом, который стремится к базовoму случаю. } Рекурсия и тернарный оператор вместе #  static int fact(int num) { return ((num \u0026gt; 1) ? num * fact(num - 1) : 1); } Рекурсия в программировании – это вызов функцией самой себя с другими аргументами. Во избежание бесконечного цикла самозапуска внутри функции должно быть условие выхода (digits \u0026lt;= 1). Рекурсивная функция вызывает себя с аргументами, которые стремятся к базовому случаю (digits - 1).\nЧисла Фибоначчи #  Решение задачи обычным способом:\npublic class Fibonaci { public static void main(String[] args){ int n0 = 1; int n1 = 1; int n2; System.out.print(n0+\u0026#34; \u0026#34;+n1+\u0026#34; \u0026#34;); for(int i = 3; i \u0026lt;= 11; i++){ n2=n0+n1; System.out.print(n2+\u0026#34; \u0026#34;); n0=n1; n1=n2; } System.out.println(); } } Рекурсивное решение\nstatic int calculateFibonaci(int n){ if (n == 0){ return 0; } if (n == 1){ return 1; } else{ return calculateFibonaci(n - 1) + calculateFibonaci(n - 2); } } Дополнительные материалы #   https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8 https://www.baeldung.com/java-recursion  "});index.add({'id':33,'href':'/school/java/basic-course/018-java-array/','title':"018 Java Array",'content':"Массивы в Java — введение в Java 018 #  Давайте представим себе книжную полку на которой стоит множество книг. Или камеру хранения на вокзале со множеством ячеек. У каждой ячейки есть номер и в каждой из них может находиться чемодан.\n  Массив в реальной жизни - камера хранения   В Java тоже есть похожие \u0026ldquo;книжные полки\u0026rdquo; или \u0026ldquo;камеры хранения\u0026rdquo;. Называются они массивами и в массиве мы можем хранить множество переменных одного типа. То есть на книжной полке с книгами не может стоять любимая ваза. Только книги. Если вазы так нужны, то мы можем выделить для всех ваз отдельную полку.\n  Массив в реальной жизни   Java - это строго типизированный язык программирования. И именно здесь она проявляет строгость. Данные одного типа можно хранить только с данными этого же типа.\nОбъявление массива #  Пример объявления(декларации) dataType[] arrayName;\nint[] myArray; String[] user; double[] gpsPoints; boolean[] truthTable; char[] cyrillicAlphabet; Срабатывает и такой синтаксис объявления массива dataType arrayName[];:\nint myArray[]; String user[]; double gpsPoints[]; boolean truthTable[]; char cyrillicAlphabet[]; Этот синтаксис наследован от языка C, который является родным папой Явы. Его можно встретить, это не является ошибкой. Но рекомендуется использовать первый вариант.\nИнициализация происходит с помощью знакомого нам по Scanner оператора new, массивы также можно объявлять и инициализировать одновременно:\n\u0026lt;\u0026lt;ИмяУжеОбъявленнойПеременной\u0026gt;\u0026gt; = new \u0026lt;\u0026lt;типДанных\u0026gt;\u0026gt; \u0026lt;\u0026lt;ДлинаМассива\u0026gt;\u0026gt; int[] field; field = new int[10]; //в массиве 10 ячеек. String[] fourSeasons = new String[] {\u0026quot;Vivaldi\u0026quot;, \u0026quot;Tchaikovsky\u0026quot;, \u0026quot;Astor Piazzolla\u0026quot;, \u0026quot;Stephen Edwin King\u0026quot;}; int[] numberFibonacci = new int[] {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144} String[] germanCity = new String[] {\u0026quot;Berlin\u0026quot;, \u0026quot;München\u0026quot;, \u0026quot;Dresden\u0026quot;,\u0026quot;Hamburg\u0026quot;,\u0026quot;Köln\u0026quot;,\u0026quot;Potsdam\u0026quot;} То есть мы можем задать пустой массив определённого размера или заполненный массив, где длина массива очевидна. Инициализированный массив не может быть неопределённого размера.\nДавайте на последнем примере посчитаем элементы в массиве и общее количество знаков, к примеру.\npublic static void germanCity() { String[] germanCity = new String[]{\u0026quot;Berlin\u0026quot;, \u0026quot;München\u0026quot;, \u0026quot;Dresden\u0026quot;, \u0026quot;Hamburg\u0026quot;, \u0026quot;Köln\u0026quot;, \u0026quot;Potsdam\u0026quot;}; int allGermanCity = germanCity.length; int allLetter = 0; for (int i = 0; i \u0026lt; allGermanCity - 1; i++) { allLetter = allLetter + germanCity[i].length(); } System.out.println(\u0026quot;allGermanCity: \u0026quot; + allGermanCity); System.out.println(\u0026quot;allLetter: \u0026quot; + allLetter); } Дополнительные материалы #  Полезно и обязательно стоит почитать:\n Официальный сайт - https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html Русскоязычная адоптация - https://javarush.ru/groups/posts/massivy-java https://www.baeldung.com/java-arrays-guide  Домашнее задание #  Постарайтесь не гуглить чужие решения. Все нужные знания у вас есть. Гуглите методы, которые вам могут понадобиться:\n Заполните массив случайным числами и выведете максимальное, минимальное и среднее значение. Для генерации случайного числа используйте метод Math.random(), который возвращает значение в промежутке [0, 1]. Напишите программу, которая выводит на консоль простые числа в промежутке от [2, 100]. Используйте для решения этой задачи оператор \u0026ldquo;%\u0026rdquo; (остаток от деления) и циклы.  "});index.add({'id':34,'href':'/school/java/basic-course/019-java-foreach/','title':"019 Java Foreach",'content':"For-Each Loop — введение в Java 019 #  Мы изучали цикл for, где в определённом диапазоне мы перебирали элементы. Существует брат уже изученного цикла - for each (фор ич). For each позволяет манипулировать со всеми элементами массива. Например\npublic class Main { public static void main(String[] args) { arrayTryandCry((int) (Math.random() * 100)); } static void arrayTryAndCry(int arrayLength) { int[] myArray = new int[arrayLength]; for (int element : myArray) { element = element + (int) (Math.random() * 100); System.out.println(element); } } } Давайте я попробую прочитать вслух, то что написано вверху:\nВ классе мэйн мы в точке входа в программу в методе мейн запускаем метод arrayTryAndCry(), в котором передаём параметр типа int. Этот параметр мы генерируем с помощью метода random() из библиотеки Math.\nВ методе arrayTryAndCry() наш параметр задаёт длину массива, а с помощью цикла фор ич и уже знакомого нам метода генератора случайных чисел мы заполняем наш массив значениями от нуля до 99.\nНадеюсь вы можете сказать почему именно до 99, а не до 100. Или всё-таки до 100? А я ошибся?\nFor each отличается от for тем, что он проработает со всеми элементами массива, а for только с теми , на которые попал шаг.\nВыгодное отличие, благодаря этому нам не надо указывать с какого элемента начинать работать и длину массива.\nДомашнее задание #   Сгенерируйте массив со случайными числами. Как записать элементы массива в обратном порядке? Запишите.  "});index.add({'id':35,'href':'/school/java/basic-course/020-java-varargs/','title':"020 Java Varargs",'content':"Variable arguments - Varargs — введение в Java 020 #  Давайте сложим два числа:\npublic class Main { public static void main(String[] args) { sum(2, 3); } private static int sum(int a, int b) { return a + b; } } Удобно находить сумму, но не очень. Ведь если надо найти сумму трёх чисел, надо писать другой метод:\npublic class Main { public static void main(String[] args) { sum(2, 3, 5); } private static int sum(int a, int b, int c) { return a + b + c; } } А если надо найти сумму трёх чисел? десяти? В конце месяца надо посчитать оплату за все рабочие дни. Дней каждый месяц разное количество, разное количество праздников, прогулов, больничных. Так что вопрос закономерный. Что делать, если мы не знаем сколько значений нам надо сложить?\nОтвет кроется в ключевом слове Varargs.\npublic class MyVarargs { public static void main(String[] args) { System.out.println(sum(2, 3, 4, 7, 9)); } private static int sum(int... allDigits) { int result = 0; for (int digit : allDigits) { result = result + digit; } return result; } } Метод sum принимает любое количество целочисленных переменных. Об этом нам говорит эта запись (**int\u0026hellip; allDigits **). И дальше мы можем работать с переменными, как будто у нас есть массив данных.\nЕсли хотите, то Varargs принимает распакованный массив как аргумент метода и подготавливает его для нас на лету.\n  — Может ли такой метод принимать другие данные?\n— Ответ да. Но с оговорками. Variable arguments могут быть приняты лишь единожды и они принимаются последними.\n  public class MyLovelyVarargs { public static void main(String[] args) { System.out.println(sum(\u0026#34;мой интересный массив\u0026#34;, 2, 3, 4, 7, 9)); } private static int sum(String arrayName, int... allDigits) { int result = 0; for (int digit : allDigits) { result = result + digit; } return result; } } Домашнее задание #   Напишите метод, который принимает динамичное количество городов Германии и выводит их столбиком. Создайте новый массив, в котором города записаны от коротких имён к длинным.  "});index.add({'id':36,'href':'/school/java/basic-course/021-java-multi-dimensional-array/','title':"021 Java Multi Dimensional Array",'content':"Многомерные массивы в Java — введение в Java 021 #  Давайте повторим, что такое массив\nМассив #  Массив — это совокупность однотипных переменных, для обращения к которым используется общее имя. Java допускает создание массивов любого типа, которые могут иметь одно или несколько измерений.\n  многомерный массив на примере февраля   static void month() { int[][] monthCalendar; monthCalendar = new int[4][7]; for (int outer = 0; outer \u0026lt; monthCalendar.length; outer++) { for (int inner = 0; inner \u0026lt; monthCalendar[outer].length; inner++) { monthCalendar[outer][inner] = outer*7 + inner + 1; System.out.println(monthCalendar[outer][inner]); } } System.out.println(\u0026#34;Plz Computer, print me element [1][3], I expect 11: \u0026#34; + monthCalendar[1][3]); } Я создал массив с четырьмя строчками и семью столбиками. Создал два фор цикла для инициализации массива. Во внешнем цикле я обхожу столбики, во внутреннем цикле я обхожу строчки. В программировании отсчёт начинается с нуля, а не с единицы и формула инициализации дней февраля равна порядковый номер строчки умноженный на семь плюс порядковый номер столбика.\nМожно создать трёхмерный и четырёхмерный массив. Если будете играться, то имейте в виду, что с увеличением многомерности вы увеличивайте потребляемые мощности. Для ознакомления с основами программирования достаточно двухмерного массива(уверенного использования) и понятия, что массив может состоять из массивов. И массивы могут быть разными, как и длина строчек и столбцов. По этому есть такое понятие как длина массива и длина измерения массива.\nДвумерный массив #  Двумерный массив - это массив одномерных массивов. Если вам нужен двумерный массив, то используйте пару квадратных скобок. Доступ к конкретному элементу массива осуществляется по его индексу.\nString[][] myArray = new String[5][3]; myArray[0][0] = \u0026#34;1\u0026#34;; myArray[0][1] = \u0026#34;Матвеев\u0026#34;; myArray[0][2] = \u0026#34;№01978434\u0026#34;; myArray[1][0] = \u0026#34;2\u0026#34;; myArray[1][1] = \u0026#34;Васечкин\u0026#34;; myArray[1][2] = \u0026#34;№21321434\u0026#34;; myArray[2][0] = \u0026#34;3\u0026#34;; myArray[2][1] = \u0026#34;Сидоров\u0026#34;; myArray[2][2] = \u0026#34;№412345678\u0026#34;; myArray[3][0] = \u0026#34;4\u0026#34;; myArray[3][1] = \u0026#34;Петечкин\u0026#34;; myArray[3][2] = \u0026#34;№587654321\u0026#34;; myArray[3][0] = \u0026#34;4\u0026#34;; myArray[3][1] = \u0026#34;Герасимов\u0026#34;; myArray[3][2] = \u0026#34;№79898321\u0026#34;;    ID ученика Фамилия ученика Номер паспорта     1 Матвеев №01978434   2 Васечкин №21321434   3 Сидоров №412345678   4 Петечкин №587654321   5 Герасимов №79898321    Трёхмерный массив фиксированной длины:\nint[][][] a1 = new int[10][20][30]; Многомерные и несимметричные массивы #  byte[][][] byteArray = { { {0, 1, 2}, {1, 2, 3}, {3, 4, 5} }, { {1, 2, 3}, {2, 3, 4}, {5, 6, 7} } }; int[][] a1 = new int[5][];// двумерный массив с 5 строками a1[0] = new int [1]; a1[1] = new int [2]; a1[2] = new int [3]; a1[3] = new int [4]; a1[4] = new int [5]; for (int[] array : a1) { for (int element : array) { System.out.print(element + \u0026#34; \u0026#34;); } System.out.println(); } 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 int[][] example = { {1}, {2, 2}, {3, 3, 3}, {4, 4, 4, 4}, {5, 5, 5, 5, 5} }; Класс java.util.Arrays содержит методы для работы с массивами.\n copyOf() − предназначен для копирования массива copyOfRange() − копирует часть массива toString() − позволяет получить все элементы в виде одной строки fill() − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива) equals() − проверяет на идентичность массивы deepEquals() − проверяет на идентичность массивы массивов  int arr[] = {2, 2, 1, 8, 3, 2, 2, 4, 2}; // To fill complete array with a particular value Arrays.fill(arr, 10); System.out.println(\u0026#34;Array completely filled with 10\\n\u0026#34; + Arrays.toString(arr)); System.out.printf(\u0026#34;Modified arr[] : %s\u0026#34;, Arrays.toString(arr)); Домашнее задание #   Создать таблицу умножения(Пифагора) для младших классов при помощи двумерного массива.   Таблица Пифагора    Создайте массив размерностью 5 на 6 и заполните его случайными числами (в диапазоне от 0 до 99 ). Выведите на консоль третью строку Просуммируйте все элементы двумерного массива. Дан двумерный массив, содержащий отрицательные и положительные числа. Выведете на экран номера тех ячеек массива, которые содержат отрицательные числа. Отсортируйте элементы в строках двумерного массива по возрастанию Даны матрицы С и D размерностью 3 на 3 и заполненные случайными числами в диапазоне от 0 до 99.  Выполните по отдельности сначала сложение, потом умножения матриц друг на друга. Выведете исходные матрицы и результат вычислений на консоль.    Дополнительные материалы #   Multi-Dimensional Arrays In Java  "});index.add({'id':37,'href':'/school/java/basic-course/022-java-public-static-void-main/','title':"022 Java Public Static Void Main",'content':"Что же это такое — public static void main(String[] args) — введение в Java 022 #  Давайте попробуем приподнять завесу тайны с метода, который мы писали чаще всего. Надо всё-таки понимать хоть немного, то что мы пишем.\nМы уже знаем, что такое main - точка входа в нашу программу. Мы знаем что такое void - это просто метод который выполняет код. Пришло время понять, что мы знаем, что String[] args это просто переменная args, которая является строковым массивом.\nДавайте попробуем программировать без IDE по олдскульному.\nСоздадим файл Main.java\npublic class Main { public static void main(String[] args) { for (String str : args) { System.out.println(\u0026#34;My arguments = \u0026#34; + str); } } } Надеюсь мы ещё помним цикл фор ич, с помощью которого я хочу распечатать массив args.\nВыйдем в консоль или терминал:\nСкомпилируем файл:\njavac Main.java и запустим:\njava Main ich lerne deutsch на экране мы получим:\nMy arguments = ich My arguments = lerne My arguments = deutsch   запуск программы в терминале   Теперь мы должны в принципе осознавать, что String[] это массив, args имя переменной массива. И что при запуске мы можем передать эти аргументы, и в теле метода обработать.\nЕщё раз. Наш метод принимает массив и выводит его на экран. При запуске программы в терминале мы передаём эти аргументы. Точно так же мы могли не вывести их на экран, а в зависимости от проверки выполнить команды. Например при передаче кодового слова кофе -\u0026gt; запустить метод готовки кофе.\nДомашнее задание #  Напишите программу, которая запускает метод готовки кофе, если переданный аргумент в командной строке \u0026ldquo;coffee\u0026rdquo; или \u0026ldquo;c\u0026rdquo;.\n"});index.add({'id':38,'href':'/school/java/basic-course/023-java-return-break-continue/','title':"023 Java Return Break Continue",'content':"Операторы перехода break, continue, return — введение в Java 023 #  Оператор break #    пример работы оператора break   С оператором break мы познакомились в шестом уроке во время знакомства с оператором выбора Switch. С помощью break мы выходим из вариантов выбора.\nПрерывание цикла #  С помощью break можно выходить из цикла.\npublic static void searchFor () { for (int i = 0; i \u0026lt;= 20; i++) { if (i == 4) { break; // выйти из цикла при i равной 4.  } System.out.println(\u0026#34;Значение i: \u0026#34; + i); } System.out.println(\u0026#34;Цикл завершен.\u0026#34;); } Я могу себе представить такой вариант выхода из бесконечных методов или рекурсивных, где через оператор break мы указываем условия выхода.\n// Использование break для выхода из while-цикла. import java.util.Scanner; class UserInputSum { public static void main(String[] args) { Double number, sum = 0.0; Scanner input = new Scanner(System.in); while (true) { System.out.print(\u0026#34;Enter a number: \u0026#34;); number = input.nextDouble(); if (number \u0026lt; 0.0) { break; } sum += number; } System.out.println(\u0026#34;Sum = \u0026#34; + sum); } } В языках постарше Java был оператор goto - перейти к определённой строчке. Break не должен и не может заменить оператор, который в Java не внесли создатели. Но зоны видимости и break позволяют делать интересные вещи:\npublic class MyBreak { static void quarantine(boolean quarantine) { // мы создаём зону \tquarantineZone: { if (quarantine) { break quarantineZone; // выход из зоны карантина \t} System.out.println(\u0026#34;Мы в картантине\u0026#34;); } } } Но я буду согласен с вами, если вы скажите, что решить вопрос с карантином можно было бы и через if-else.\nОператор continue #  Оператор continue имеет смысл и стоит использовать только в циклах. С его помощью можно завершить шаг и перейти к следующему кругу.\n// Демонстрирует continue. public class MyContinue { public static void main(String[] args) { for (int i = 0; i \u0026lt; 10; i++) { System.out.print(i + \u0026#34; \u0026#34;); if (i % 2 == 0) { continue; } System.out.println(\u0026#34;\u0026#34;); } } } /* Вывод в терминале 0 1 2 3 4 5 6 7 8 9 */ Оператор return #  Return мы знаем из урока номер 12 про методы.\nОператор return используют для выполнения явного выхода из метода. Оператор можно использовать в любом месте метода для возврата управления тому объекту, который вызвал данный метод. Таким образом, return прекращает выполнение метода, в котором он находится.\n// Демонстрирует return. public class Return { static void quarantine(Boolean quarantine) { quarantineZone: { if (quarantine) { return; // выход из программы \t} System.out.println(\u0026#34;Мы в картантине\u0026#34;); } } } Как мы видим return можно использовать и в исполняем методе, а не только в возвратном. Не уверен, что эти операторы с завтрашнего дня надо активно использовать, но знать их надо.\nМетки #  \u0026ldquo;quarantineZone:\u0026rdquo; в предыдущем коде - метка.\nДополнительные ссылки #   Операции с метками, branching statements The Java continue and break Keywords  Домашнее задание #   Напишите программу, которая выводит на консоль простые числа в промежутке от [2, 100].\nИспользуйте для решения этой задачи оператор \u0026ldquo;%\u0026rdquo; (остаток от деления) и циклы. Используйте циклы с метками.  "});index.add({'id':39,'href':'/school/java/basic-course/027-java-sorting-algorithms-01-bubblesort/','title':"027 Java Sorting Algorithms 01 Bubblesort",'content':"Алгоритмы сортировок, Bubble Sort — введение в Java 027 #    массив требующий сортировки   Представьте себе ситуацию, что вы просите свой компьютер отсортировать фотографии по размеру или занимаемому месту, товары на странице магазина по цене и новости на сайте по дате написания.\nВсе эти данные, массивы информации сортируются. Сейчас мы попробуем написать простейший алгоритм сортировки массива состоящего из чисел.\nПузырьковая сортировка #  В пузырьковой сортировке мы по очереди просматриваем попарно весь массив. Для визуализации можно ещэ раз посмотреть прекрасный танец.\nНазвана сортировка так потому, что цифры \u0026ldquo;всплывают\u0026rdquo; меняясь местами.\n  Пузырьковая сортировка или Bubble sort   Bubble Sort и рекурсия #  import java.util.Arrays; public class BubbleSort { static void bubbleSort(int[] arrUnsort) { int count = 0; for (int i = 0; i \u0026lt; arrUnsort.length - 1; i++) if (arrUnsort[i] \u0026gt; arrUnsort[i + 1]) { int temp = arrUnsort[i]; arrUnsort[i] = arrUnsort[i + 1]; arrUnsort[i + 1] = temp; count++; } if (count \u0026gt; 0) { bubbleSort(arrUnsort); } } public static void main(String[] args) { int[] myArr = {104, 64, 34, 25, 12, 22, 11, 90}; bubbleSort(myArr); System.out.println(Arrays.toString(myArr)); } } Bubble Sort без рекурсии #  public static void bubbleSort(int[] array) { boolean unsorted = true; int temp; while (unsorted) { unsorted = false; for (int i = 0; i \u0026lt; array.length - 1; i++) { if (array[i] \u0026gt; array[i + 1]) { temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; unsorted = true; } } } } Пузырьковая сортировка строковых значений по алфавиту #  import java.util.Arrays; public class Main { public static void main(String[] args) { String name = \u0026#34;Andrej\u0026#34;; String[] array = name.split(\u0026#34;\u0026#34;); System.out.println(Arrays.toString(bubbleSort(array))); } public static String[] bubbleSort(String[] array) { int count = 0; for (int i = 0; i \u0026lt; array.length - 1; i++) { if (array[i + 1].toLowerCase().compareTo(array[i].toLowerCase()) \u0026lt; 0) { String tempStr = array[i]; array[i] = array[i + 1]; array[i + 1] = tempStr; count++; } } if (count \u0026gt; 0) { bubbleSort(array); } return array; } } Дополнительные материалы #   https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8 https://habr.com/ru/post/275813/ эта ссылка и домашнее задание по рекурсиям https://habr.com/ru/post/337030/ Просто для ознакомления https://medium.com/nuances-of-programming/%D1%80%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-74c03b764d38 https://www.baeldung.com/java-recursion  Дополнительные материалы #    https://habr.com/ru/post/204600/\n  Алгоритм сортировки\n  [Сортировка пузырьком](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_ %D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC) https://en.wikipedia.org/wiki/Cocktail_shaker_sort\n  https://ru.wikipedia.org/wiki/%D0%91%D1%8B%D1%81%D1%82%D1%80%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0\n  https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D1%87%D0%BD%D0%B0%D1%8F_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0\n  Это особенно важный материал, с ним надо ознакомиться сейчас. Что бы когда мы его будем изучать все термины уже были в подкорке. Очень важно. https://ru.wikipedia.org/wiki/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%D0%B0\n  https://javarush.ru/groups/posts/mnogomernye-massivy\n   27 - Сортировки, Bubble Sort  "});index.add({'id':40,'href':'/school/java/exercises/01-exercises-java/','title':"01 Exercises Java",'content':"Задачи Java Boolean, введение — 01 #  Задачи на усвоение булевых значений в Java. Достаточно знать тип данных boolean, желательно(рекомендуется) знать условный оператор if-else.\n Родители Васи Сидорова купили умный сейф и запрограммировали его на выдачу денег по отпечатку пальцев одного из родителей. smartDepositBox(true, false) -\u0026gt; true smartDepositBox(false, true) -\u0026gt; true smartDepositBox(false, false) -\u0026gt; false  После покупки сейфа в семье начался разлад по поводу выделению сыну денег и родители решили сейф перепрограммировать, таким образом, что бы он выдавал деньги только при обоюдном согласии родителей. smartDepositBoxVersionTwo(true, false) -\u0026gt; false smartDepositBoxVersionTwo(false, true) -\u0026gt; false smartDepositBoxVersionTwo(false, false) -\u0026gt; false smartDepositBoxVersionTwo(true, true) -\u0026gt; true  К родителям Васи Сидорова приехала Бабушка и сказала, что родители не умеют воспитывать сына и она сама знает, когда давать ребёнку деньги. Напишите программу выдачи денег Васе, если бабушка выдаёт деньги независимо от решения родителей. verySmartDepositBox(mamaPermission, papaPermission, omaPermission)  Родители Василия добились успехов в программировании и смогли передать свои знания сыну. Василий вырос и запрограммировал систему аварийного уничтожения первых космических кораблей земли, улетевших в Альфа-Центавру. Система уничтожения реагирует на ввод команд двух старших офицеров корабля. bigBadaBoom(true, true) -\u0026gt; true bigBadaBoom(false, false) -\u0026gt; false bigBadaBoom(true, false) -\u0026gt; false  На даче у родителей Васи Сидорова решили поставить звонок, который должен звонить при нажатии на кнопку звонка у калитки или у двери дома. Если соседские дети начинают играться и нажимать на кнопки звонка одновременно и на калитке и на доме, звонок не должен реагировать. Напишите программу управления звонком. doorbell(true, true) -\u0026gt; false doorbell(false, false) -\u0026gt; false doorbell(true, false) -\u0026gt; true  Программирование всё больше захватывало семью Василия и они решили сделать полностью умный дом. Для начала они решили сделать входную дверь учитывая новые стандарты. Дверь больше нельзя открыть обычным ключом, пока в доме есть интернет и она подключена к электросети. Напишите тесты для программы smartDoorCheckKey. Заказчик(бабушка Василия), хочет, что бы мы проконтролировали работу сторонней фирмы. Сторонняя фирма не справилась с написанием программы. Напишите самостоятельно метод, который возвращает false, если дверь открыть ключом нельзя. Родители сделали в итоге самостоятельно всё программирование вокруг двери не дожидаясь нас. Попробуйте угадать как же работает метод, которрый позволяет Василию открыть дверь телефоном, отпечатком пальца или введённым с клавиатуры паролем. verySmartDoor(false, true, false) -\u0026gt; true verySmartDoor(false, false, true) -\u0026gt; true verySmartDoor(true, false, false) -\u0026gt; true verySmartDoor(false, false, false) -\u0026gt; false  В девятом классе Вася ездил со своим и параллельным классом в Париж. Известно, что на двоих учителей нельзя брать в поездку больше 25 детей. Напишите проверочный метод paris(11, 15) -\u0026gt; false paris(11, 5) -\u0026gt; true   "});index.add({'id':41,'href':'/school/java/exercises/02-exercises-java/','title':"02 Exercises Java",'content':"Закрепление пройденного материала, введение — 02 #   методы и классы в Java простые типы данных Switch  Задачи #   Даны два целых числа. Верните true, если одно из этих чисел находится в диапазоне от 10 до 20 включительно. Написать метод String getStringMonth(int month),который принимает номер месяца, а возвращает название. В main распечатать результат работы метода. Учитывая int n, возвращайте true, если он находится в пределах 10 от 100 или 200. Примечание: Math.abs(num) вычисляет абсолютное значение числа.  nearHundred(93) → true nearHundred(90) → true nearHundred(89) → false   Реализовать метод double getPercent(double amount, double interest) который считает указанный процент (interest) от указанного числа (amount ). Например getPercent (1000.0, 10.0), должно вернуть 100. В main распечатать результат работы метода. Реализовать метод, который принимает название валюты (например, \u0026ldquo;EUR\u0026rdquo;,\u0026ldquo;RUR\u0026rdquo;,\u0026ldquo;USD\u0026rdquo;,\u0026ldquo;GPB\u0026rdquo;) и выдает курс к доллару. Естественно, \u0026ldquo;USD\u0026rdquo; возвращает 1.0 Стоимость электроэнергии рассчитывается исходя из стоимости одного киловатт-часа в 20 центов.\nБазовая плата - 30€. В базовую плату входят 100 киловатт-часов. Напишите метод расчёта стоимости пользования электроэнергией.  Задачи с повышенным уровнем сложности #   Реализовать программу “конвертер валют”  Реализовать метод, который принимает название валюты (например, “EUR”,”RUR”,”USD”,”GPB”) и выдает курс к доллару. Естественно, “USD” возвращает 1.0 . Используя метод из предыдущего пункта написать метод, который принимает пару валют (“GPB”,”EUR”) и возвращает курс обмена. Используя метод из предыдущего пункта реализовать метод который получает пару валют и сумму в первой валюте, возвращает сумму во второй валюте.   В старых советских хрущёвках города № решили поменять деревянные окна и двери на пластиковые. Выяснилось, что все двери в хрущёвках одинакового размера 2м*90см, а окна разные, но в каждой квартире могут быть только одинаковые окна. Стоимость переделки окон рассчитывается из стоимости стекла - 100€ за квадратный метр и стоимости косяка - погонный метр 100€. Стоимость дверей рассчитывается исходя из стоимости косяка (как и у окна) и стоимости самой двери 120€ за квадратный метр. Напишите программу, которая поможет стройтресту №12 правильно выставлять счета. Школа приняла на работу молодую учительницу геометрии. И первым делом она решила привести кабинет точных наук в порядок. В подвале школы были найдены:  точная копия спутника земли ПС-1. Диаметр сферы 58см. жестяной куб со стороной 40см. правильная четырёхугольная пирамида \u0026ldquo;Хеопса\u0026rdquo; со стороной основания 20см и боковыми рёбрами 30см и чёрный ящик с размерами 80см * 30см * 20см.\nВсё было в достаточно запущенном состоянии и новая учительница решила всё покрасить в красный цвет.\nСколько денег на покраску нужно потратить если на один квадратный метр надо 560мл краски, а балончик с аэрозольной краской 400мл стоит 17€?    "});index.add({'id':42,'href':'/school/java/exercises/03-exercises-java/','title':"03 Exercises Java",'content':"Задачи для закрепления конструкции If, if else введение - 03 #  Требуется знание простых типов данных, String, if-else\n Даны два целых числа, верните большее из двух. Если числа равны, то верните ноль. moreOrLess(5, 6) -\u0026gt; 6 moreOrLess(5, 5) -\u0026gt; 0 moreOrLess(0, 100) -\u0026gt; 100  Даны три целых числа, верните их сумму. Если первое и третье числа равны друг другу, то верните второе, если сумма равна нулю, то верните -1. mySum(5, 6, 5) -\u0026gt; 6 mySum(5, 6, 7) -\u0026gt; 18 mySum(0, 0, 0) -\u0026gt; 0 mySum(0, -5, 5) -\u0026gt; -1  Дан строковый литерал. Верните его длину, если она больше 10. Если меньше десяти, то верните удвоенную длину строкового литерала, если длина равна нулю, то верните 100. findLength(\u0026quot;London is the capital\u0026quot;) -\u0026gt; 21 findLength(\u0026quot;\u0026quot;) -\u0026gt; 100 findLength(\u0026quot;Школа\u0026quot;) -\u0026gt; 10  Напишите программу действий для сотрудника дорожной полиции, который остановил машину:  при езде до 50 км/час нарушений нет; за езду от 50 км/час до 65 км/час — устное порицание и лекция на 5 минут; за превышение скорости от 16 км/час — 40 евро штрафа; за езду от 100 км/час до 130 км/час — штраф 500 евро; и за езду свыше 130 км/час — штраф в 1000 евро, конфискация прав на 3 года и конфискация транспортного средства.   Напишите программу, которая объяснит наступление определённых событий, в зависимости от выбора \u0026ldquo;витязя\u0026rdquo;. Напишите программу для машины на светофоре. Что делать, если горит красный, жёлтый или зелёный свет. Напишите программу выдачи денег работнику с учётом надбавки за стаж, если базовая зарплата 500$. За 3 года работы надбавка 10%, за 5 лет работы надбавка 50%, за 10 лет работы надбавка 100%, за 15 лет работы надбавка 150%. Метод вывода даты на экран монитора принимает 3 целочисленных значения(день, месяц, год) и разделитель (например \u0026ldquo;-\u0026quot;). Проверить значения данных на адекватность, и если надо дописать нули.\n- 5.6.2020 должно быть выведено на экран как \u0026ldquo;05-06-2020\u0026rdquo; - 50.40.2020 не должно быть выведено вообще  "});index.add({'id':43,'href':'/school/java/exercises/04-exercises-java/','title':"04 Exercises Java",'content':"Задачи для повторения и закрепления материала, введение — 04 #  Первая партия задач #   Давайте попробуем написать методы для вычисления площади и периметра фигур: квадрата, прямоугольника, треугольника, круга. И один раз напишем их исполняющими, а один раз возвратными. В обоих случаях методы должны принимать необходимые данные для вычисления: как радиус, длину сторон или прочее. Даны натуральные числа от a = 35 до b = 87. Вывести на консоль те из них, которые при делении на 7 дают остаток 1, 2 или 5. а и b должны приниматься методом. Напишите метод(ы)- программу с описанием человеческих действий через комментирование кода или через систему вывода сообщений на экран, из которой понятно как получить утреннюю чашку кофе, а в пятницу вечером бутылку холодного пива. Мастеру плиточнику Сергею Ивановичу Золотыеруки задают часто один и тот же вопрос. Сколько будет стоить положить плитку на определённом участке.   Нам известно, что в час он кладёт примерно один квадратный метр плитки. Его час стоит 27€ без НДС. Стандартная плитка 30 на 20 сантиметров.  Сергей Иванович обратился к нам за помощью и вам надо написать для него программу.\nКоторая будет принимать размеры стены/пола, стоимость плитки и выдавать:\n Количество требуемых плиток, как целых, так и тех которые надо будет резать. Учтите, что плитку можно класть как вдоль, так и поперёк и только на месте мастер узнает, как именно её надо класть. Стоимость материала Стоимость рабочего времени Итоговую ориентировочную стоимость  Вторая партия задач #   Дано два числа (a и b). Написать метод, который вернет сумму всех чисел между (a и b). Если a равно b, метод должен вернут a+b\nПример: sum(2,4) -\u0026gt; 9 Реализовать метод печатающий таблицу умножения для заданного числа Пример: multiplicationTable(3)-\u0026gt; 3x1=3 3x2=6 …. 3x10=30  Реализовать метод, печатающий все високосные годы в интервале от year1 до year2\nПример: printLeapYears(2000,2009) -\u0026gt; 2000 2004 2008  Реализовать метод, считающий все високосные годы в интервале от year1 до year2\nПример: countLeapYears(2000,2009) -\u0026gt; 3 Напишите метод, который выводит на экран квадрат с заданной стороной символами “*”\nПример: printSquare(4) -\u0026gt; **** **** **** ****  Реализовать метод, который принимает целое положительное число. Метод должен выводить на экран все положительные числа, на которые заданное число делится без остатка и отображает количество найденных делителей.\nПример: printDivisors(32) -\u0026gt; 32 16 8 4 2 1 Total divisors: 6  Дано два целых положительных числа от 1 до 99. Реализовать метод, который для каждого числа от a до b печатает строку вида “23 рубля”\nПример: printSumInRub(1,5) -\u0026gt; 1 рубль 2 рубля 3 рубля 4 рубля 5 рублей   "});index.add({'id':44,'href':'/school/java/exercises/05-exercises-java/','title':"05 Exercises Java",'content':"Задачи для закрепления цикла for, введение — 05 #  Задачи на закрепление основ программирования. Требуется знание простых типов данных, String, switch, if-else, for\nЗакрепление изученного #    Существует такая традиция: при приготовлении пельменей в один из них кладут монетку на счастье. Считается, что тому, кому попадется пельмень с монеткой, улыбнется удача.\n Представим, что у нас есть кастрюля, в которой лежит 10 пельменей. Один из них счастливый — а именно пятый пельмень. Давайте напишем программу, которая ищет счастливый пельмень. Программа перебирает пельмени в кастрюле по одному, и когда доходит до пятого пельменя — напишет \u0026ldquo;Вот счастливый пельмень!\u0026rdquo; и выходит из цикла.    Вывести на экран все числа от 1 до 100, которые делятся на 3 без остатка.\n  Необходимо, чтоб программа выводила на экран вот такую последовательность:\nmyLine(100) -\u0026gt; 7 14 21 28 35 42 49 56 63 70 77 84 91 98   Необходимо вывести на консоль такую последовательность чисел:\nmySecondLine(1000) -\u0026gt; 1 2 4 8 16 32 64 128 256 512   Вывести каждую букву американского алфавита от A-Z по 4 буквы в строке.\n  Выведите на экран первые 11 членов последовательности Фибоначчи.\n первый и второй члены последовательности равны единицам а каждый следующий — сумме двух предыдущих То есть числа Фибоначчи - это 1 1 2 3 5 8 13 21 34 55 89 и т.д.    Дано целое трехзначное число. Написать метод, который возвращает число, записанное в обратном порядке, например:\n123 -\u0026gt; 321 768 -\u0026gt; 867   Дано целое трехзначное число. Написать метод, который возвращает сумму разрядов этого числа, например:\n123 -\u0026gt; 6 (1+2+3) 768 -\u0026gt; 21 (7+6+8)   Найдите в заданном диапазоне хотя бы одно натуральное число, которое делится на 11, а при делении на 2, 3, 4, \u0026hellip;, 10 дает в остатке 1.\nfindDigits(99999, 11) -\u0026gt; 25201, 52921, 80641   Дано целое трехзначное число. Написать метод, который определит четность/ нечетность разрядов этого числа, например:\n123 -\u0026gt; 1 – нечет. 2- чет. 3-нечет. 768 -\u0026gt; 1 – нечет. 2- чет. 3-чет.   реализовать метод, который выводит на экран заданную строку N раз.\nprintLineNtimes(“hello”,3) -\u0026gt; hello hello hello   Реализовать метод “ Обратный отсчёт ” который выводит на экран цифры от n до 1, затем выводит строку „start“.\ncountdown(5) -\u0026gt; 5 4 3 2 1 start   реализовать метод “ Обратный отсчёт ” который выводит на экран цифры от 5 до 1 текстом, затем выводит строку „start“.\ncountdown() -\u0026gt; five four tree two one start   Написать свой метод проверки строки на палиндром. Учесть, что палиндром может быть предложением с пробелами. При решении задачи используйте цикл.\nНельзя использовать методы replace(), reverse() и конструкции, которые вы не учили.\ncheckPalindrom( \u0026quot;А роза упала на лапу Азора\u0026quot;) -\u0026gt; true checkPalindrom( \u0026quot;поп\u0026quot;) -\u0026gt; true checkPalindrom( \u0026quot;школа\u0026quot;) -\u0026gt; false   Разработайте шифровальную машину для нового клиента фирмы - Гая Юлия Цезаря.\nКлиент придумал шифровальный алгоритм и хочет, что бы мы реализовали его в методе.\nПример выполнения метода:\nenigmaCaesar(\u0026quot;Съешь же ещё этих мягких французских булок, да выпей чаю.\u0026quot;) -\u0026gt; \u0026quot;Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб.\u0026quot; О самом методе шифрования(шифр подстановки) написана подробная документация, которая доступна по ссылке.\n  Давайте напишем генератор паролей. Методу передаётся длина пароля. И метод генерирует пароль используя латиницу, цифры и некоторые спецсимволы(на ваш выбор). Подсказка - использовать только те знания, которые были уже изучены. Существует как минимум два(на самом деле 222) разных подхода к решению этой проблемы. Не бойтесь пробовать.\n  "});index.add({'id':45,'href':'/school/java/exercises/06-exercises-java/','title':"06 Exercises Java",'content':"Вложенные циклы (Nested Loops) и работа с данными, введение — 06 #  Прямоугольник #  При вызове метода rectangle(5, 7); на экране появился прямоугольник. Что написано в методе rectangle?\n******* ******* ******* ******* ******* Трое неизвестных #  нужно написать алгоритм вывода на экран всех возможных комбинаций 3-х натуральных чисел до 36 с определенными условиями:\n необходимо использовать вложенные циклы x \u0026lt;= y \u0026lt;= z xyz = 36  например:\n x=1, y=1, z=36 x=1; y=3; z=12  Шахматная доска #  Выведите на экран в шахматном порядке символы.\n*-*-*-*- -*-*-*-* *-*-*-*- -*-*-*-* *-*-*-*- -*-*-*-* *-*-*-*- -*-*-*-* Таблица умножения #  Выведите на экран таблицу умножения, как показано ниже.\n1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90100 Геометрические фигуры #   \u0026ldquo;Нарисуйте/выведите в консоль\u0026rdquo; треугольник из звёздочек используя только одну звёздочку и то что только что изучили:  * ** *** **** ***** ****** ******* ******** ********* **********  Предыдущая задача очень важна. И важно, что бы вы её могли решить самостоятельно. Если решили, то попробуйте усложнить требуемое и нарисуйте равнобедренный треугольник. А после все фигуры из рисунка снизу.    Треугольники   Треугольники из чисел #  Первый #  1 222 33333 4444444 555555555 66666666666 Второй #  1 212 32123 4321234 543212345 65432123456 Floyd`s triangle #  Треугольник Флойда является прямоугольным треугольником из натуральных чисел. Он назван в честь Роберта Флойда . Строки треугольника заполняются последовательными номерами, начиная с 1 в верхнем левом углу:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Снежинка #  Нарисуйте снежинку makeSnowflake(10)\nX X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X "});index.add({'id':46,'href':'/school/java/exercises/07-exercises-java/','title':"07 Exercises Java",'content':"Двоичные системы счисления, Modulo, введение — 07 #   В одном KByte(килобайт) - 1000 Byte(10^3). В одном KiB(кикибайт) - 1024 Byte(2^10).  Напишите программу, которая например из 100.000 байтов вычисляет сколько это целых KByte(килобайт) и оставшихся Byte. Напишите программу подсчёта (обмана) разницы маркетинговых гигабайт с гигабайтами. Сколько \u0026ldquo;программистских\u0026rdquo; или двоичных мебибайт в десятичных гигабайтах.   Написать программу, которая нам переводит любое десятичное число в двоичное. Напишите программу для перевода из двоичных в десятичные. Написать программу перевода десятичных чисел в восьмеричную систему. Напишите программу перевода чисел из любой(X) системы в любую(Y) систему. Сделайте ограничение для систем выше 16. Программу перевода десятичных чисел в двоичные, где пользователь вводит значения через клавиатуру.  "});index.add({'id':47,'href':'/school/java/exercises/08-exercises-java/','title':"08 Exercises Java",'content':"Массивы, введение — 08 #   Заполните массив случайным числами и выведете максимальное, минимальное и среднее значение. Для генерации случайного числа используйте метод Math.random(), который возвращает значение в промежутке [0, 1]. Напишите программу, которая выводит на консоль простые числа в промежутке от [2, 100]. Используйте для решения этой задачи оператор \u0026ldquo;%\u0026rdquo; (остаток от деления) и циклы. Перевести String с именем и фамилией в массив Char. Внести все чётные цифры от нуля до 100 в массив int. Создать заполненый массив с именем, фамилией, отчеством. Сгенерировать 100 раз случайное число от нуля до 100, записать их в массив.  Посчитать среднее значение элементов, узнать минимальное и максимальное значение в массиве. отсортировать по порядку все значения в массиве.   Как поменять элементы массива в обратном порядке? Поменяйте. Дан массив целых чисел и ещё одно целое число(передаётся аргументами). Удалите все вхождения этого числа из массива (пропусков быть не должно). Дано два массива int. Сложите по порядку элементы между собой и верните итоговый массив. Объявите массив char и заполните его кирилическим алфавитом. Создать метод, который принимает аргументами имя, фамилию, емайл и если эти поля не пустые, то выдают сообщение о том, что данные успешно записаны, в противном случае, что данных для записи недостаточно. Поле емайл проверить на наличие знака \u0026quot;@\u0026quot;-at, не собачка, а эт! и точки. Найти количество различных элементов массива. Пример: для 1 4 5 1 1 3 ответ 4. Дан массив. Перемешать его элементы случайным образом так, чтобы каждый элемент оказался на новом месте. Сгенерируйте массив со случайными числами. Как поменять элементы массива в обратном порядке? Поменяйте.  "});index.add({'id':48,'href':'/school/java/exercises/09-exercises-java/','title':"09 Exercises Java",'content':"Многомерные массивы, введение — 09 #   Перепишите метод monthCalendar используя метод цикл фор ич. Создать таблицу умножения(Пифагора) для младших классов.   Таблица Пифагора    Создать поле для игры в сапёров с типом данных на выбор. Например boolean со значениями false. Размером 100 на 100. И раставить 20 случайных бомб (true). Распечатайте координаты бомб. Создайте String массив случайного размера в диапазоне (10-100). Заполните его случайными строками(паролями?, логинами?, значениями?) длиной от 10 до 20. Найдите среднюю длину элемента. Отсортируйте элементы в массиве по длине.  "});index.add({'id':49,'href':'/school/java/exercises/10-exercises-java/','title':"10 Exercises Java",'content':"Задачи на закрепление всех основных конструкций, введение — 10 #   The parameter weekday is true if it is a weekday, and the parameter vacation is true if we are on vacation. We sleep in if it is not a weekday or we\u0026rsquo;re on vacation. Return true if we sleep in. sleepIn(false, false) → true sleepIn(true, false) → false sleepIn(false, true) → true  Given an int n, return the absolute difference between n and 21, except return double the absolute difference if n is over 21. diff21(19) → 2 diff21(10) → 11 diff21(21) → 0  Given an int n, return true if it is within 10 of 100 or 200. Note: Math.abs(num) computes the absolute value of a number. nearHundred(93) → true nearHundred(90) → true nearHundred(89) → false  Given a non-empty string and an int n, return a new string where the char at index n has been removed. The value of n will be a valid index of a char in the original string (i.e. n will be in the range 0..str.length()-1 inclusive). missingChar(\u0026quot;kitten\u0026quot;, 1) → \u0026quot;ktten\u0026quot; missingChar(\u0026quot;kitten\u0026quot;, 0) → \u0026quot;itten\u0026quot; missingChar(\u0026quot;kitten\u0026quot;, 4) → \u0026quot;kittn\u0026quot;  Given a string, take the last char and return a new string with the last char added at the front and back, so \u0026ldquo;cat\u0026rdquo; yields \u0026ldquo;tcatt\u0026rdquo;. The original string will be length 1 or more. backAround(\u0026quot;cat\u0026quot;) → \u0026quot;tcatt\u0026quot; backAround(\u0026quot;Hello\u0026quot;) → \u0026quot;oHelloo\u0026quot; backAround(\u0026quot;a\u0026quot;) → \u0026quot;aaa\u0026quot;  Given a string, return true if the string starts with \u0026ldquo;hi\u0026rdquo; and false otherwise. startHi(\u0026quot;hi there\u0026quot;) → true startHi(\u0026quot;hi\u0026quot;) → true startHi(\u0026quot;hello hi\u0026quot;) → false  We\u0026rsquo;ll say that a number is \u0026ldquo;teen\u0026rdquo; if it is in the range 13..19 inclusive. Given 3 int values, return true if 1 or more of them are teen. hasTeen(13, 20, 10) → true hasTeen(20, 19, 10) → true hasTeen(20, 10, 13) → true  Return true if the given string begins with \u0026ldquo;mix\u0026rdquo;, except the \u0026rsquo;m\u0026rsquo; can be anything, so \u0026ldquo;pix\u0026rdquo;, \u0026ldquo;9ix\u0026rdquo; .. all count. mixStart(\u0026quot;mix snacks\u0026quot;) → true mixStart(\u0026quot;pix snacks\u0026quot;) → true mixStart(\u0026quot;piz snacks\u0026quot;) → false  Given 2 int values, return whichever value is nearest to the value 10, or return 0 in the event of a tie. Note that Math.abs(n) returns the absolute value of a number. close10(8, 13) → 8 close10(13, 8) → 8 close10(13, 7) → 0  Return true if the given string contains between 1 and 3 \u0026lsquo;e\u0026rsquo; chars. stringE(\u0026quot;Hello\u0026quot;) → true stringE(\u0026quot;Heelle\u0026quot;) → true stringE(\u0026quot;Heelele\u0026quot;) → false  Given a non-empty string and an int N, return the string made starting with char 0, and then every Nth char of the string. So if N is 3, use char 0, 3, 6, \u0026hellip; and so on. N is 1 or more. everyNth(\u0026quot;Miracle\u0026quot;, 2) → \u0026quot;Mrce\u0026quot; everyNth(\u0026quot;abcdefg\u0026quot;, 2) → \u0026quot;aceg\u0026quot; everyNth(\u0026quot;abcdefg\u0026quot;, 3) → \u0026quot;adg\u0026quot;  We have two monkeys, a and b, and the parameters aSmile and bSmile indicate if each is smiling. We are in trouble if they are both smiling or if neither of them is smiling. Return true if we are in trouble. monkeyTrouble(true, true) → true monkeyTrouble(false, false) → true monkeyTrouble(true, false) → false  We have a loud talking parrot. The \u0026ldquo;hour\u0026rdquo; parameter is the current hour time in the range 0..23. We are in trouble if the parrot is talking and the hour is before 7 or after 20. Return true if we are in trouble. parrotTrouble(true, 6) → true parrotTrouble(true, 7) → false parrotTrouble(false, 6) → false  Given 2 int values, return true if one is negative and one is positive. Except if the parameter \u0026ldquo;negative\u0026rdquo; is true, then return true only if both are negative. posNeg(1, -1, false) → true posNeg(-1, 1, false) → true posNeg(-4, -5, true) → true  Given a string, return a new string where the first and last chars have been exchanged. frontBack(\u0026quot;code\u0026quot;) → \u0026quot;eodc\u0026quot; frontBack(\u0026quot;a\u0026quot;) → \u0026quot;a\u0026quot; frontBack(\u0026quot;ab\u0026quot;) → \u0026quot;ba\u0026quot;  Return true if the given non-negative number is a multiple of 3 or a multiple of 5. Use the % \u0026ldquo;mod\u0026rdquo; operator \u0026ndash; see Introduction to Mod or35(3) → true or35(10) → true or35(8) → false  Given two temperatures, return true if one is less than 0 and the other is greater than 100. icyHot(120, -1) → true icyHot(-1, 120) → true icyHot(2, 120) → false  We\u0026rsquo;ll say that a number is \u0026ldquo;teen\u0026rdquo; if it is in the range 13..19 inclusive. Given 2 int values, return true if one or the other is teen, but not both. loneTeen(13, 99) → true loneTeen(21, 19) → true loneTeen(13, 13) → false  Given a string, return a string made of the first 2 chars (if present), however include first char only if it is \u0026lsquo;o\u0026rsquo; and include the second only if it is \u0026lsquo;z\u0026rsquo;, so \u0026ldquo;ozymandias\u0026rdquo; yields \u0026ldquo;oz\u0026rdquo;. startOz(\u0026quot;ozymandias\u0026quot;) → \u0026quot;oz\u0026quot; startOz(\u0026quot;bzoo\u0026quot;) → \u0026quot;z\u0026quot; startOz(\u0026quot;oxx\u0026quot;) → \u0026quot;o\u0026quot;  Given 2 int values, return true if they are both in the range 30..40 inclusive, or they are both in the range 40..50 inclusive. in3050(30, 31) → true in3050(30, 41) → false in3050(40, 50) → true  Given two non-negative int values, return true if they have the same last digit, such as with 27 and 57. Note that the % \u0026ldquo;mod\u0026rdquo; operator computes remainders, so 17 % 10 is 7. lastDigit(7, 17) → true lastDigit(6, 17) → false lastDigit(3, 113) → true   Разминка номер два #   Given a string and a non-negative int n, return a larger string that is n copies of the original string. stringTimes(\u0026quot;Hi\u0026quot;, 2) → \u0026quot;HiHi\u0026quot; stringTimes(\u0026quot;Hi\u0026quot;, 3) → \u0026quot;HiHiHi\u0026quot; stringTimes(\u0026quot;Hi\u0026quot;, 1) → \u0026quot;Hi\u0026quot;  Given a string, return true if the first instance of \u0026ldquo;x\u0026rdquo; in the string is immediately followed by another \u0026ldquo;x\u0026rdquo;. doubleX(\u0026quot;axxbb\u0026quot;) → true doubleX(\u0026quot;axaxax\u0026quot;) → false doubleX(\u0026quot;xxxxx\u0026quot;) → true  Given a string, return the count of the number of times that a substring length 2 appears in the string and also as the last 2 chars of the string, so \u0026ldquo;hixxxhi\u0026rdquo; yields 1 (we won\u0026rsquo;t count the end substring). last2(\u0026quot;hixxhi\u0026quot;) → 1 last2(\u0026quot;xaxxaxaxx\u0026quot;) → 1 last2(\u0026quot;axxxaaxx\u0026quot;) → 2  Given a string, return a string made of the chars at indexes 0,1, 4,5, 8,9 \u0026hellip; so \u0026ldquo;kittens\u0026rdquo; yields \u0026ldquo;kien\u0026rdquo;. altPairs(\u0026quot;kitten\u0026quot;) → \u0026quot;kien\u0026quot; altPairs(\u0026quot;Chocolate\u0026quot;) → \u0026quot;Chole\u0026quot; altPairs(\u0026quot;CodingHorror\u0026quot;) → \u0026quot;Congrr\u0026quot;  Given a string and a non-negative int n, we\u0026rsquo;ll say that the front of the string is the first 3 chars, or whatever is there if the string is less than length 3. Return n copies of the front; frontTimes(\u0026quot;Chocolate\u0026quot;, 2) → \u0026quot;ChoCho\u0026quot; frontTimes(\u0026quot;Chocolate\u0026quot;, 3) → \u0026quot;ChoChoCho\u0026quot; frontTimes(\u0026quot;Abc\u0026quot;, 3) → \u0026quot;AbcAbcAbc\u0026quot;  Given a string, return a new string made of every other char starting with the first, so \u0026ldquo;Hello\u0026rdquo; yields \u0026ldquo;Hlo\u0026rdquo;. stringBits(\u0026quot;Hello\u0026quot;) → \u0026quot;Hlo\u0026quot; stringBits(\u0026quot;Hi\u0026quot;) → \u0026quot;H\u0026quot; stringBits(\u0026quot;Heeololeo\u0026quot;) → \u0026quot;Hello\u0026quot;  Given 2 strings, a and b, return the number of the positions where they contain the same length 2 substring. So \u0026ldquo;xxcaazz\u0026rdquo; and \u0026ldquo;xxbaaz\u0026rdquo; yields 3, since the \u0026ldquo;xx\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, and \u0026ldquo;az\u0026rdquo; substrings appear in the same place in both strings. stringMatch(\u0026quot;xxcaazz\u0026quot;, \u0026quot;xxbaaz\u0026quot;) → 3 stringMatch(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;) → 2 stringMatch(\u0026quot;abc\u0026quot;, \u0026quot;axc\u0026quot;) → 0  Suppose the string \u0026ldquo;yak\u0026rdquo; is unlucky. Given a string, return a version where all the \u0026ldquo;yak\u0026rdquo; are removed, but the \u0026ldquo;a\u0026rdquo; can be any char. The \u0026ldquo;yak\u0026rdquo; strings will not overlap. stringYak(\u0026quot;yakpak\u0026quot;) → \u0026quot;pak\u0026quot; stringYak(\u0026quot;pakyak\u0026quot;) → \u0026quot;pak\u0026quot; stringYak(\u0026quot;yak123ya\u0026quot;) → \u0026quot;123ya\u0026quot;  Count the number of \u0026ldquo;xx\u0026rdquo; in the given string. We\u0026rsquo;ll say that overlapping is allowed, so \u0026ldquo;xxx\u0026rdquo; contains 2 \u0026ldquo;xx\u0026rdquo;. countXX(\u0026quot;abcxx\u0026quot;) → 1 countXX(\u0026quot;xxx\u0026quot;) → 2 countXX(\u0026quot;xxxx\u0026quot;) → 3  Given a non-empty string like \u0026ldquo;Code\u0026rdquo; return a string like \u0026ldquo;CCoCodCode\u0026rdquo;. stringSplosion(\u0026quot;Code) → \u0026quot;CCoCodCode\u0026quot; stringSplosion(\u0026quot;abc\u0026quot;) → \u0026quot;aababc\u0026quot; stringSplosion(\u0026quot;ab\u0026quot;) → \u0026quot;aab\u0026quot;  Given a string, return a version where all the \u0026ldquo;x\u0026rdquo; have been removed. Except an \u0026ldquo;x\u0026rdquo; at the very start or end should not be removed. stringX(\u0026quot;xxHxix\u0026quot;) → \u0026quot;xHix\u0026quot; stringX(\u0026quot;abxxxcd\u0026quot;) → \u0026quot;abcd\u0026quot; stringX(\u0026quot;xabxxxcdx\u0026quot;) → \u0026quot;xabcdx\u0026quot;   FizzBuzz #   Program that prints the numbers from 1 to 100. But for multiples of three print \u0026ldquo;Fizz\u0026rdquo; instead of the number and for the multiples of five print \u0026ldquo;Buzz\u0026rdquo;. For numbers which are multiples of both three and five print \u0026ldquo;FizzBuzz\u0026rdquo;. fizzBuzz() → \u0026quot;Fizz\u0026quot; fizzBuzz() → \u0026quot;Buzz\u0026quot; fizzBuzz() → \u0026quot;FizzBuzz\u0026quot;   "});index.add({'id':50,'href':'/school/java/exercises/11-exercises-java/','title':"11 Exercises Java",'content':"Задачи на логику - уно #   When squirrels get together for a party, they like to have cigars. A squirrel party is successful when the number of cigars is between 40 and 60, inclusive. Unless it is the weekend, in which case there is no upper bound on the number of cigars. Return true if the party with the given values is successful, or false otherwise. cigarParty(30, false) → false cigarParty(50, false) → true cigarParty(70, true) → true  You are driving a little too fast, and a police officer stops you. Write code to compute the result, encoded as an int value: 0=no ticket, 1=small ticket, 2=big ticket. If speed is 60 or less, the result is 0. If speed is between 61 and 80 inclusive, the result is 1. If speed is 81 or more, the result is 2. Unless it is your birthday \u0026ndash; on that day, your speed can be 5 higher in all cases. caughtSpeeding(60, false) → 0 caughtSpeeding(65, false) → 1 caughtSpeeding(65, true) → 0  The number 6 is a truly great number. Given two int values, a and b, return true if either one is 6. Or if their sum or difference is 6. Note: the function Math.abs(num) computes the absolute value of a number. love6(6, 4) → true love6(4, 5) → false love6(1, 5) → true  Return true if the given non-negative number is 1 or 2 more than a multiple of 20. See also: Introduction to Mod more20(20) → false more20(21) → true more20(22) → true  Given a non-negative number \u0026ldquo;num\u0026rdquo;, return true if num is within 2 of a multiple of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2. See also: Introduction to Mod nearTen(12) → true nearTen(17) → false nearTen(19) → true  We are having a party with amounts of tea and candy. Return the int outcome of the party encoded as 0=bad, 1=good, or 2=great. A party is good (1) if both tea and candy are at least 5. However, if either tea or candy is at least double the amount of the other one, the party is great (2). However, in all cases, if either tea or candy is less than 5, the party is always bad (0). teaParty(6, 8) → 1 teaParty(3, 8) → 0 teaParty(20, 6) → 2  Given three ints, a b c, return true if it is possible to add two of the ints to get the third. twoAsOne(1, 2, 3) → true twoAsOne(3, 1, 2) → true twoAsOne(3, 2, 2) → false  Given three ints, a b c, return true if two or more of them have the same rightmost digit. The ints are non-negative. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder, e.g. 17 % 10 is 7. lastDigit(23, 19, 13) → true lastDigit(23, 19, 12) → false lastDigit(23, 19, 3) → true  Given two int values, return whichever value is larger. However if the two values have the same remainder when divided by 5, then the return the smaller value. However, in all cases, if the two values are the same, return 0. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder, e.g. 7 % 5 is 2. maxMod5(2, 3) → 3 maxMod5(6, 2) → 6 maxMod5(3, 2) → 3  You have a blue lottery ticket, with ints a, b, and c on it. This makes three pairs, which we\u0026rsquo;ll call ab, bc, and ac. Consider the sum of the numbers in each pair. If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum is exactly 10 more than either bc or ac sums, the result is 5. Otherwise the result is 0. blueTicket(9, 1, 0) → 10 blueTicket(9, 2, 0) → 0 blueTicket(6, 1, 4) → 10  You and your date are trying to get a table at a restaurant. The parameter \u0026ldquo;you\u0026rdquo; is the stylishness of your clothes, in the range 0..10, and \u0026ldquo;date\u0026rdquo; is the stylishness of your date\u0026rsquo;s clothes. The result getting the table is encoded as an int value with 0=no, 1=maybe, 2=yes. If either of you is very stylish, 8 or more, then the result is 2 (yes). With the exception that if either of you has style of 2 or less, then the result is 0 (no). Otherwise the result is 1 (maybe). dateFashion(5, 10) → 2 dateFashion(5, 2) → 0 dateFashion(5, 5) → 1  Given 2 ints, a and b, return their sum. However, sums in the range 10..19 inclusive, are forbidden, so in that case just return 20. sortaSum(3, 4) → 7 sortaSum(9, 4) → 20 sortaSum(10, 11) → 21  Given a number n, return true if n is in the range 1..10, inclusive. Unless outsideMode is true, in which case return true if the number is less or equal to 1, or greater or equal to 10. in1To10(5, false) → true in1To10(11, false) → false in1To10(11, true) → true  Return true if the given non-negative number is a multiple of 3 or 5, but not both. Use the % \u0026ldquo;mod\u0026rdquo; operator \u0026ndash; see Introduction to Mod old35(3) → true old35(10) → true old35(15) → false  Given 2 ints, a and b, return their sum. However, \u0026ldquo;teen\u0026rdquo; values in the range 13..19 inclusive, are extra lucky. So if either value is a teen, just return 19. teenSum(3, 4) → 7 teenSum(10, 13) → 19 teenSum(13, 2) → 19  Given a string str, if the string starts with \u0026ldquo;f\u0026rdquo; return \u0026ldquo;Fizz\u0026rdquo;. If the string ends with \u0026ldquo;b\u0026rdquo; return \u0026ldquo;Buzz\u0026rdquo;. If both the \u0026ldquo;f\u0026rdquo; and \u0026ldquo;b\u0026rdquo; conditions are true, return \u0026ldquo;FizzBuzz\u0026rdquo;. In all other cases, return the string unchanged. (See also: FizzBuzz Code) fizzString(\u0026quot;fig\u0026quot;) → \u0026quot;Fizz\u0026quot; fizzString(\u0026quot;dib\u0026quot;) → \u0026quot;Buzz\u0026quot; fizzString(\u0026quot;fib\u0026quot;) → \u0026quot;FizzBuzz\u0026quot;  Given three ints, a b c, return true if b is greater than a, and c is greater than b. However, with the exception that if \u0026ldquo;bOk\u0026rdquo; is true, b does not need to be greater than a. inOrder(1, 2, 4, false) → true inOrder(1, 2, 1, false) → false inOrder(1, 1, 2, true) → true  Given three ints, a b c, return true if one of them is 10 or more less than one of the others. lessBy10(1, 7, 11) → true lessBy10(1, 7, 10) → false lessBy10(11, 1, 7) → true  You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1, or 2. If they are all the value 2, the result is 10. Otherwise if they are all the same, the result is 5. Otherwise so long as both b and c are different from a, the result is 1. Otherwise the result is 0. redTicket(2, 2, 2) → 10 redTicket(2, 2, 1) → 0 redTicket(0, 0, 0) → 5  Given two ints, each in the range 10..99, return true if there is a digit that appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10, gives the left digit while the % \u0026ldquo;mod\u0026rdquo; n%10 gives the right digit.) shareDigit(12, 23) → true shareDigit(12, 43) → false shareDigit(12, 44) → false  The squirrels in Palo Alto spend most of the day playing. In particular, they play if the temperature is between 60 and 90 (inclusive). Unless it is summer, then the upper limit is 100 instead of 90. Given an int temperature and a boolean isSummer, return true if the squirrels play and false otherwise. squirrelPlay(70, false) → true squirrelPlay(95, false) → false squirrelPlay(95, true) → true  Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, \u0026hellip;6=Sat, and a boolean indicating if we are on vacation, return a string of the form \u0026ldquo;7:00\u0026rdquo; indicating when the alarm clock should ring. Weekdays, the alarm should be \u0026ldquo;7:00\u0026rdquo; and on the weekend it should be \u0026ldquo;10:00\u0026rdquo;. Unless we are on vacation \u0026ndash; then on weekdays it should be \u0026ldquo;10:00\u0026rdquo; and weekends it should be \u0026ldquo;off\u0026rdquo;. alarmClock(1, false) → \u0026quot;7:00\u0026quot; alarmClock(5, false) → \u0026quot;7:00\u0026quot; alarmClock(0, false) → \u0026quot;10:00\u0026quot;  We\u0026rsquo;ll say a number is special if it is a multiple of 11 or if it is one more than a multiple of 11. Return true if the given non-negative number is special. Use the % \u0026ldquo;mod\u0026rdquo; operator \u0026ndash; see Introduction to Mod specialEleven(22) → true specialEleven(23) → true specialEleven(24) → false  Return true if the given non-negative number is 1 or 2 less than a multiple of 20. So for example 38 and 39 return true, but 40 returns false. See also: Introduction to Mod less20(18) → true less20(19) → true less20(20) → false  Your cell phone rings. Return true if you should answer it. Normally you answer, except in the morning you only answer if it is your mom calling. In all cases, if you are asleep, you do not answer. answerCell(false, false, false) → true answerCell(false, false, true) → false answerCell(true, false, false) → false  Given an int n, return the string form of the number followed by \u0026ldquo;!\u0026rdquo;. So the int 6 yields \u0026ldquo;6!\u0026rdquo;. Except if the number is divisible by 3 use \u0026ldquo;Fizz\u0026rdquo; instead of the number, and if the number is divisible by 5 use \u0026ldquo;Buzz\u0026rdquo;, and if divisible by both 3 and 5, use \u0026ldquo;FizzBuzz\u0026rdquo;. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder after division, so 23 % 10 yields 3. What will the remainder be when one number divides evenly into another? (See also: FizzBuzz Code and Introduction to Mod) fizzString2(1) → \u0026quot;1!\u0026quot; fizzString2(2) → \u0026quot;2!\u0026quot; fizzString2(3) → \u0026quot;Fizz!\u0026quot;  Given three ints, a b c, return true if they are in strict increasing order, such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception that if \u0026ldquo;equalOk\u0026rdquo; is true, equality is allowed, such as 5 5 7 or 5 5 5. inOrderEqual(2, 5, 11, false) → true inOrderEqual(5, 7, 6, false) → false inOrderEqual(5, 5, 7, true) → true  Return the sum of two 6-sided dice rolls, each in the range 1..6. However, if noDoubles is true, if the two dice show the same value, increment one die to the next value, wrapping around to 1 if its value was 6. withoutDoubles(2, 3, true) → 5 withoutDoubles(3, 3, true) → 7 withoutDoubles(3, 3, false) → 6  You have a green lottery ticket, with ints a, b, and c on it. If the numbers are all different from each other, the result is 0. If all of the numbers are the same, the result is 20. If two of the numbers are the same, the result is 10. greenTicket(1, 2, 3) → 0 greenTicket(2, 2, 2) → 20 greenTicket(1, 1, 2) → 10  Given 2 non-negative ints, a and b, return their sum, so long as the sum has the same number of digits as a. If the sum has more digits than a, just return a without b. (Note: one way to compute the number of digits of a non-negative int n is to convert it to a string with String.valueOf(n) and then check the length of the string.) sumLimit(2, 3) → 5 sumLimit(8, 3) → 8 sumLimit(8, 1) → 9   "});index.add({'id':51,'href':'/school/java/exercises/12-exercises-java/','title':"12 Exercises Java",'content':"Задачи на логику - дос #   We want to make a row of bricks that is goal inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops. See also: Introduction to MakeBricks makeBricks(3, 1, 8) → true makeBricks(3, 1, 9) → false makeBricks(3, 2, 10) → true  Given 3 int values, a b c, return their sum. However, if any of the values is a teen \u0026ndash; in the range 13..19 inclusive \u0026ndash; then that value counts as 0, except 15 and 16 do not count as a teens. Write a separate helper \u0026ldquo;public int fixTeen(int n) {\u0026ldquo;that takes in an int value and returns that value fixed for the teen rule. In this way, you avoid repeating the teen code 3 times (i.e. \u0026ldquo;decomposition\u0026rdquo;). Define the helper below and at the same indent level as the main noTeenSum(). noTeenSum(1, 2, 3) → 6 noTeenSum(2, 13, 1) → 3 noTeenSum(2, 1, 14) → 3  Given 2 int values greater than 0, return whichever value is nearest to 21 without going over. Return 0 if they both go over. blackjack(19, 21) → 21 blackjack(21, 19) → 21 blackjack(19, 22) → 19  Given 3 int values, a b c, return their sum. However, if one of the values is the same as another of the values, it does not count towards the sum. loneSum(1, 2, 3) → 6 loneSum(3, 2, 3) → 2 loneSum(3, 3, 3) → 0  For this problem, we\u0026rsquo;ll round an int value up to the next multiple of 10 if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down to the previous multiple of 10 if its rightmost digit is less than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To avoid code repetition, write a separate helper \u0026ldquo;public int round10(int num) {\u0026rdquo; and call it 3 times. Write the helper entirely below and at the same indent level as roundSum(). roundSum(16, 17, 18) → 60 roundSum(12, 13, 14) → 30 roundSum(6, 4, 4) → 10  Given 3 int values, a b c, return their sum. However, if one of the values is 13 then it does not count towards the sum and values to its right do not count. So for example, if b is 13, then both b and c do not count. luckySum(1, 2, 3) → 6 luckySum(1, 2, 13) → 3 luckySum(1, 13, 3) → 1  Given three ints, a b c, return true if one of b or c is \u0026ldquo;close\u0026rdquo; (differing from a by at most 1), while the other is \u0026ldquo;far\u0026rdquo;, differing from both other values by 2 or more. Note: Math.abs(num) computes the absolute value of a number. closeFar(1, 2, 10) → true closeFar(1, 2, 3) → false closeFar(4, 1, 3) → true  We want make a package of goal kilos of chocolate. We have small bars (1 kilo each) and big bars (5 kilos each). Return the number of small bars to use, assuming we always use big bars before small bars. Return -1 if it can\u0026rsquo;t be done. makeChocolate(4, 1, 9) → 4 makeChocolate(4, 1, 10) → -1 makeChocolate(4, 1, 7) → 2  Given three ints, a b c, one of them is small, one is medium and one is large. Return true if the three values are evenly spaced, so the difference between small and medium is the same as the difference between medium and large. evenlySpaced(2, 4, 6) → true evenlySpaced(4, 6, 2) → true evenlySpaced(4, 6, 3) → false   "});index.add({'id':52,'href':'/school/java/exercises/java-introduction-exercises/','title':"Java Introduction Exercises",'content':"Задачи к курсу \u0026ldquo;Основы Java\u0026rdquo; #   Вполне возможно(точно), что не все задачи вы можете решите с Ява. Просто решите те, которые можете. Задания соотвествуют общей математической подготовке абитуриента и тем урокам, которые даны по курсу Java.\n В день хорошо бы решать по одной задачe. Я не знаю с каким темпом и возможностями вы будете заниматься. Но лучше один час каждый день, чем 8 часов на выходных.\n001 Привет мир #  Выведите на экран свои имя, фамилию, рост, вес.\n002-003 Простые числовые типы данных #   Найдите применение каждому типу данных из заголовка и напишите программу с использованием byte, short, int, long:  Найти периметр квадрата, прямоугольника, куба, количество зёрен на шахматной доске - Легенда   Посчитать количество дней до нового года и дня рождения Пушкина. Найти наибольший общий делитель для чисел 36, 60, 42. Найти наименьшее общее кратное чисел 20 и 30. Изготавливая по 42 детали в час, рабочий трудился 8 часов. Сколько времени ему понадобилось бы на эту же работу, если бы он делал в час по 48 деталей? Автомобиль проехал 310 км, истратив 25 л бензина. Какое расстояние может проехать автомобиль на полном баке, вмещающем 40л? В коробке 48 пачек чая по 250 г в каждой. Сколько получится из этого чая пачек по 150г На одной из сцепляющих шестерен 32 зубца, а на другой – 40. Сколько оборотов сделает вторая шестерня, в то время как первая сделает 215 оборотов? Через первую трубу бассейн можно наполнить за 20 ч, а через вторую — за 30 ч. За сколько часов наполнится бассейн через обе эти трубы? В гимназии учатся 200 учеников, нам известно, что каждый из них знает греческий или латынь, а некоторые даже оба. Известно, что 150 из них знают греческий язык и 130 знают латынь. Какая часть учащихся знает оба языка? Расчитать программу вычисления площади круга. Найти длину окружности. Написать формулу вычисления стоимости Евро, если курс Евро к Доллару 1,1. Найти соотношение площади Беларуси к площади Украины. Найти во сколько раз площадь Москвы больше площади Берлина.    Учитывая int n, возвращайте true, если он находится в пределах 10 от 100 или 200. Примечание: Math.abs(num) вычисляет абсолютное значение числа.  nearHundred(93) → true nearHundred(90) → true nearHundred(89) → false   Стоимость электроэнергии рассчитывается исходя из стоимости одного киловатт-часа в 20 центов. Базовая плата - 30€. В базовую плату входят 100 киловатт-часов. Напишите метод расчёта стоимости пользования электроэнергией. В старых советских хрущёвках города № решили поменять деревянные окна и двери на пластиковые. Выяснилось, что все двери в хрущёвках одинакового размера 2м*90см, а окна разные, но в каждой квартире могут быть только одинаковые окна. Стоимость переделки окон рассчитывается из стоимости стекла - 100€ за квадратный метр и стоимости косяка - погонный метр 100€. Стоимость дверей рассчитывается исходя из стоимости косяка (как и у окна) и стоимости самой двери 120€ за квадратный метр. Напишите программу, которая поможет стройтресту №12 правильно выставлять счета.  004 char и String #   Вывести на экран сообщение в кавычках. Например собственное имя + \u0026ldquo;профессия\u0026rdquo;. Вывести на экран построчно анкетные данные: Имя, Фамилия, Адрес, Улица и тд и тп. Пример вывода одной строчки: Имя пользователя: Андрей Вывести три рекламных слогана трёх крупных фирм. Добавить к слоганам знаки (char) копирайта, торговой марки. Добавить к решению задачи номер 13 из предыдущей главы знаки евро и доллара. Вырезать из выражения \u0026ldquo;Добро пожаловать\u0026rdquo; последние 7 символов и добавте \u0026ldquo;нельзя\u0026rdquo;.  005 Boolean #   Что выдаст программа, если запросить значения a,b,c,d,e,f? Посчитайте сначала в уме, проговорите в вслух что делает каждая строчка.  boolean a = (7+8)*5 \u0026gt; 7+8*5; boolean c = 3+4 \u0026gt; 9+1 \u0026amp; 16-5 \u0026gt; 3*4; boolean e = 16/2 \u0026lt; 6+2 | 4+5 \u0026lt;= 4*5; boolean f = !(3*4 \u0026lt; 7+8); Напишите программу и проверьте свои результаты. Сравните строчку вывода со своей:\nSystem.out.println(a + \u0026#34;\\n\u0026#34; + b + \u0026#34;\\n\u0026#34; +c + \u0026#34;\\n\u0026#34;+ d +\u0026#34;\\n\u0026#34;+ e +\u0026#34;\\n\u0026#34; + f); 006 Switch case #   Напишите программу действий кассира магазина. Если у него пытаются купить алкоголь следующие 5 покупателей: 10 лет, 17 лет, 18 лет, 20 лет и 30 лет. Напишите программу, которая определяет сезон года. Месяца указаны int переменными.  007 If, else #   Напишите программу действий для сотрудника дорожной полиции, который остановил машину.  При езде до 50км/час нарушений нет; за езду от 50км/час до 65км/час устное порицание и лекция на 5 минут; за превышение скорости от 16км/час - 40 евро штрафа; за езду от 100км/час до 130км/час - штраф 500 евро; и за езду свыше 130км/час - штраф в 1000 евро, забирание прав + на 3 года и конфискация транспортного средства.   Напишите программу для машин на светофорах одного перекрёстка. Что делать если горит красный, жёлтый, зелёный.  if and int #   Получив int n, верните абсолютную разницу между n и 21, за исключением если n больше 21, тогда верните двойную абсолютную разницу.   21(19) → 2 diff21(10) → 11 diff21(21) → 0  if #   Параметр weekday true, если это день недели, а параметр vacation true, если мы в отпуске. Мы спим, если это не рабочий день или мы в отпуске. Верните true, если мы спим. https://codingbat.com/prob/p187868  sleepIn(false, false) → true sleepIn(true, false) → false sleepIn(false, true) → true   Получив два значения int, верните их сумму. Если два значения не одинаковы, верните двойную сумму.  sumDouble(1, 2) → 3 sumDouble(3, 2) → 5 sumDouble(2, 2) → 8   Given a string, we\u0026rsquo;ll say that the front is the first 3 chars of the string. If the string length is less than 3, the front is whatever is there. Return a new string which is 3 copies of the front. https://codingbat.com/prob/p136351  front3(\u0026ldquo;Java\u0026rdquo;) → \u0026ldquo;JavJavJav\u0026rdquo; front3(\u0026ldquo;Chocolate\u0026rdquo;) → \u0026ldquo;ChoChoCho\u0026rdquo; front3(\u0026ldquo;abc\u0026rdquo;) → \u0026ldquo;abcabcabc\u0026rdquo;   Необходимо написать метод, который бы возвращал из 2 чисел меньшее число. Например, из двух чисел 7 и 3 метод должен вывести в консоль 3.  008 цикл FOR #   Написать программу расчёта роста денежного клада в банке. Сумма вклада 100€, время вклада 7 лет, процент дохода вклада 2,3%. Вывести результат на экран за каждый год в виде:  Сумма вклада в конце первого года = a Сумма вклада в конце второго года = b Сумма вклада в конце NN года = c Доход за Y лет составил = d При расчёте пользоваться float и ответить на следующие вопросы: Используя какие типы данных можно решить эту задачу? Почему? Что произойдёт при использовании типа данных byte?   Решите предыдущую задачу если банк выплачивает проценты на проценты. Определите на глаз, что будет выдано в консоли после запуска последнего куска кода? Даны целые числа A и B, где B \u0026gt; 0. Вывести B раз число A. Вывести в порядке возрастания все числа между А и Б, где а =5, а Б =17. Сколько раз будет выведено сообщение на экран?  for (int i = 3; i \u0026lt; 10; i ++){ System.out.println(i); } 011 Modulo #   Напишите программу, которая выясняет делится число на два или нет. Дано число меньше 3000. При делении числа на 32 получается остаток 30, при делении на 58 - остаток 44. Найдите число или числа. В одном KByte(килобайт) - 1000 Byte(10^3). В одном KiB(кикибайт) - 1024 Byte(2^10).  Напишите программу, которая например из 100.000 байтов вычисляет сколько это целых KByte(килобайт) и оставшихся Byte. Напишите программу подсчёта (обмана) разницы маркетинговых гигабайт с гигибайтами. Сколько \u0026ldquo;программистких\u0026rdquo; или двоичных мебибайт в десятичных гигабайтах.   Написать программу, которая нам переводит любое десятичное число в двоичное. Напишите программу для перевода из двоичных в десятичные. Написать программу перевода десятичных чисел в восьмиричную систему. Напишите программу перевода чисел из любой(X) системы в любую(Y) систему. Сделайте ограничение для систем выше 32.  012 Арифметические операторы #   Программа, которая находит високосный год. Решите задачу используя булевые операции и выражения.  016 Рекурсия #  Повторение #  Оно сегодня будет большим и не обязательно связанное с изученной темой. Она не так уж сложна. Давайте повоторим всё то, что мы учили.\n Компьютер загадывает число от 1 до n. У пользователя k попыток отгадать. После каждой неудачной попытки компьютер сообщает меньше или больше загаданное число. В конце игры текст с результатом (или “Вы угадали”, или “Попытки закончились”). Найти количество различных элементов массива. Пример: для 1 4 5 1 1 3 ответ 4. Дан массив. Перемешать его элементы случайным образом так, чтобы каждый элемент оказался на новом месте. Дано предложение. Заменить группы пробелов одиночными, крайние пробелы удалить. Все слова перевести в нижний регистр, первые буквы сделать заглавными. Уроки по математике проводятся через день. Если урок попадает на воскресенье, то переносится на понедельник. Пользователь вводит дату первого урока. Сгенерируйте расписание из дат на текущий месяц. Программа принимает строку и проверяет её на палиндромность. Результ проверки вывести на экран и в случае палиндромности подсчитать количество символов. Напишите задачу для магазина по продаже алкоголя с выводом проверки на экран монитора кассира. Возраст разрешения 18 лет. Используйте тернарный оператор. Президент приходит к власти если набрал 51% голосов избирателей. Создайте машину для ввода результатов выборов. Киловатчас стоит 35 евроцентов, среднемесячное потребление 200кв. Посчитайте годовую стоимость электричества. Решите задачу с високосными годами из 10-го урока с modulo другим способом. Подсказка - логические выражения. Что такое:  ANSI? Что такое ASCII? В чём их различие? UTF-8, UTF-16, UTF-32? ISO 8859-5, ISO 8859-1, Win 1251, CP866, KOI8? Попробуйте написать программу из перевода строки из одной(любой) кодировки в другую(любую).    "});index.add({'id':53,'href':'/school/java/exercises/solution/03-java-exercises-solution-string-01/','title':"03 Java Exercises Solution String 01",'content':""});index.add({'id':54,'href':'/school/java/exercises/solution/04-java-exercises-solution-string-02/','title':"04 Java Exercises Solution String 02",'content':""});index.add({'id':55,'href':'/school/java/exercises/solution/05-java-exercises-solution-string-03/','title':"05 Java Exercises Solution String 03",'content':"Добрый вечер, String - трес. Решение #  public class StringTresExercise { public static void main(String[] args) { System.out.println(countYZ(\u0026quot;fez day\u0026quot;)); // exp.2 System.out.println(countYZ(\u0026quot;day fez\u0026quot;)); // exp.2 System.out.println(countYZ(\u0026quot;day fyyyz\u0026quot;)); // exp.2 System.out.println(countYZ(\u0026quot;tel ran\u0026quot;)); // exp. 0 System.out.println(countYZ(\u0026quot;xyx,xzy\u0026quot;)); // exp. 1 System.out.println(countYZ(\u0026quot;London is the capital of Great Britain\u0026quot;)); // exp. 0 System.out.println(gHappy(\u0026quot;xxggxx\u0026quot;)); // exp. true System.out.println(gHappy(\u0026quot;xxgxx\u0026quot;)); // exp. false System.out.println(gHappy(\u0026quot;xxggyygxx\u0026quot;)); // exp. false } private static int countYZ(String s) { int wordsNumber = 0; for (int i = 1; i \u0026lt; s.length(); i++) { char tempChar = s.charAt(i); //if (s.charAt(i) == ' ' \u0026amp;\u0026amp; (s.charAt(i - 1) == 'y' || s.charAt(i - 1) == 'z')) { if (!Character.isLetter(tempChar) \u0026amp;\u0026amp; (s.charAt(i - 1) == 'y' || s.charAt(i - 1) == 'z')) { wordsNumber++; } } if (s.endsWith(\u0026quot;y\u0026quot;) || s.endsWith(\u0026quot;z\u0026quot;)) { wordsNumber++; } return wordsNumber; } private static boolean gHappy(String str) { int count = 0; int unhappyG = 0; for (int i = 0; i \u0026lt; str.length(); i++) { if (str.charAt(i) == 'g' \u0026amp;\u0026amp; (str.charAt(i - 1) == 'g' || str.charAt(i + 1) == 'g')) count++; else if (str.charAt(i) == 'g') unhappyG++; } if (count \u0026gt; 0 \u0026amp;\u0026amp; unhappyG == 0) return true; else if (count == 0 \u0026amp;\u0026amp; unhappyG \u0026gt; 0) return false; return false; } }"});index.add({'id':56,'href':'/school/java/exercises/temp-01-java-exercises/','title':"Temp 01 Java Exercises",'content':""});index.add({'id':57,'href':'/school/java/exercises/temp-03-java-exercises-string-01/','title':"Temp 03 Java Exercises String 01",'content':"Доброе утро, String - уно #   Given a string name, e.g. \u0026ldquo;Bob\u0026rdquo;, return a greeting of the form \u0026ldquo;Hello Bob!\u0026rdquo;. helloName(\u0026quot;Bob\u0026quot;) → \u0026quot;Hello Bob!\u0026quot; helloName(\u0026quot;Alice\u0026quot;) → \u0026quot;Hello Alice!\u0026quot; helloName(\u0026quot;X\u0026quot;) → \u0026quot;Hello X!\u0026quot;  Given an \u0026ldquo;out\u0026rdquo; string length 4, such as \u0026ldquo;\u0026laquo;\u0026raquo;\u0026rdquo;, and a word, return a new string where the word is in the middle of the out string, e.g. \u0026ldquo;\u0026laquo;word\u0026raquo;\u0026rdquo;. Note: use str.substring(i, j) to extract the String starting at index i and going up to but not including index j. makeOutWord(\u0026quot;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026quot;, \u0026quot;Yay\u0026quot;) → \u0026quot;\u0026lt;\u0026lt;Yay\u0026gt;\u0026gt;\u0026quot; makeOutWord(\u0026quot;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026quot;, \u0026quot;WooHoo\u0026quot;) → \u0026quot;\u0026lt;\u0026lt;WooHoo\u0026gt;\u0026gt;\u0026quot; makeOutWord(\u0026quot;[[]]\u0026quot;, \u0026quot;word\u0026quot;) → \u0026quot;[[word]]\u0026quot;  Given a string of even length, return the first half. So the string \u0026ldquo;WooHoo\u0026rdquo; yields \u0026ldquo;Woo\u0026rdquo;. firstHalf(\u0026quot;WooHoo\u0026quot;) → \u0026quot;Woo\u0026quot; firstHalf(\u0026quot;HelloThere\u0026quot;) → \u0026quot;Hello\u0026quot; firstHalf(\u0026quot;abcdef\u0026quot;) → \u0026quot;abc\u0026quot;  Given 2 strings, return their concatenation, except omit the first char of each. The strings will be at least length 1. nonStart(\u0026quot;Hello\u0026quot;, \u0026quot;There\u0026quot;) → \u0026quot;ellohere\u0026quot; nonStart(\u0026quot;java\u0026quot;, \u0026quot;code\u0026quot;) → \u0026quot;avaode\u0026quot; nonStart(\u0026quot;shotl\u0026quot;, \u0026quot;java\u0026quot;) → \u0026quot;hotlava\u0026quot;  Given a string, return a string length 1 from its front, unless front is false, in which case return a string length 1 from its back. The string will be non-empty. theEnd(\u0026quot;Hello\u0026quot;, true) → \u0026quot;H\u0026quot; theEnd(\u0026quot;Hello\u0026quot;, false) → \u0026quot;o\u0026quot; theEnd(\u0026quot;oh\u0026quot;, true) → \u0026quot;o\u0026quot;  Given a string, return true if it ends in \u0026ldquo;ly\u0026rdquo;. endsLy(\u0026quot;oddly\u0026quot;) → true endsLy(\u0026quot;y\u0026quot;) → false endsLy(\u0026quot;oddy\u0026quot;) → false  Given a string of odd length, return the string length 3 from its middle, so \u0026ldquo;Candy\u0026rdquo; yields \u0026ldquo;and\u0026rdquo;. The string length will be at least 3. middleThree(\u0026quot;Candy\u0026quot;) → \u0026quot;and\u0026quot; middleThree(\u0026quot;and\u0026quot;) → \u0026quot;and\u0026quot; middleThree(\u0026quot;solving\u0026quot;) → \u0026quot;lvi\u0026quot;  Given 2 strings, a and b, return a new string made of the first char of a and the last char of b, so \u0026ldquo;yo\u0026rdquo; and \u0026ldquo;java\u0026rdquo; yields \u0026ldquo;ya\u0026rdquo;. If either string is length 0, use \u0026lsquo;@\u0026rsquo; for its missing char. lastChars(\u0026quot;last\u0026quot;, \u0026quot;chars\u0026quot;) → \u0026quot;ls\u0026quot; lastChars(\u0026quot;yo\u0026quot;, \u0026quot;java\u0026quot;) → \u0026quot;ya\u0026quot; lastChars(\u0026quot;hi\u0026quot;, \u0026quot;\u0026quot;) → \u0026quot;h@\u0026quot;  Given a string, if the string begins with \u0026ldquo;red\u0026rdquo; or \u0026ldquo;blue\u0026rdquo; return that color string, otherwise return the empty string. seeColor(\u0026quot;redxx\u0026quot;) → \u0026quot;red\u0026quot; seeColor(\u0026quot;xxred\u0026quot;) → \u0026quot;\u0026quot; seeColor(\u0026quot;blueTimes\u0026quot;) → \u0026quot;blue\u0026quot;  Given a string, return a new string made of 3 copies of the first 2 chars of the original string. The string may be any length. If there are fewer than 2 chars, use whatever is there. extraFront(\u0026quot;Hello\u0026quot;) → \u0026quot;HeHeHe\u0026quot; extraFront(\u0026quot;ab\u0026quot;) → \u0026quot;ababab\u0026quot; extraFront(\u0026quot;H\u0026quot;) → \u0026quot;HHH\u0026quot;  Given a string and a second \u0026ldquo;word\u0026rdquo; string, we\u0026rsquo;ll say that the word matches the string if it appears at the front of the string, except its first char does not need to match exactly. On a match, return the front of the string, or otherwise return the empty string. So, so with the string \u0026ldquo;hippo\u0026rdquo; the word \u0026ldquo;hi\u0026rdquo; returns \u0026ldquo;hi\u0026rdquo; and \u0026ldquo;xip\u0026rdquo; returns \u0026ldquo;hip\u0026rdquo;. The word will be at least length 1. startWord(\u0026quot;hippo\u0026quot;, \u0026quot;hi\u0026quot;) → \u0026quot;hi\u0026quot; startWord(\u0026quot;hippo\u0026quot;, \u0026quot;xip\u0026quot;) → \u0026quot;hip\u0026quot; startWord(\u0026quot;hippo\u0026quot;, \u0026quot;i\u0026quot;) → \u0026quot;h\u0026quot;  Given two strings, a and b, return the result of putting them together in the order abba, e.g. \u0026ldquo;Hi\u0026rdquo; and \u0026ldquo;Bye\u0026rdquo; returns \u0026ldquo;HiByeByeHi\u0026rdquo;. makeAbba(\u0026quot;Hi\u0026quot;, \u0026quot;Bye\u0026quot;) → \u0026quot;HiByeByeHi\u0026quot; makeAbba(\u0026quot;Yo\u0026quot;, \u0026quot;Alice\u0026quot;) → \u0026quot;YoAliceAliceYo\u0026quot; makeAbba(\u0026quot;What\u0026quot;, \u0026quot;Up\u0026quot;) → \u0026quot;WhatUpUpWhat\u0026quot;  Given a string, return a new string made of 3 copies of the last 2 chars of the original string. The string length will be at least 2. extraEnd(\u0026quot;Hello\u0026quot;) → \u0026quot;lololo\u0026quot; extraEnd(\u0026quot;ab\u0026quot;) → \u0026quot;ababab\u0026quot; extraEnd(\u0026quot;Hi\u0026quot;) → \u0026quot;HiHiHi\u0026quot;  Given a string, return a version without the first and last char, so \u0026ldquo;Hello\u0026rdquo; yields \u0026ldquo;ell\u0026rdquo;. The string length will be at least 2. withoutEnd(\u0026quot;Hello\u0026quot;) → \u0026quot;ell\u0026quot; withoutEnd(\u0026quot;java\u0026quot;) → \u0026quot;av\u0026quot; withoutEnd(\u0026quot;coding\u0026quot;) → \u0026quot;odin\u0026quot;  Given a string, return a \u0026ldquo;rotated left 2\u0026rdquo; version where the first 2 chars are moved to the end. The string length will be at least 2. left2(\u0026quot;Hello\u0026quot;) → \u0026quot;lloHe\u0026quot; left2(\u0026quot;java\u0026quot;) → \u0026quot;vaja\u0026quot; left2(\u0026quot;Hi\u0026quot;) → \u0026quot;Hi\u0026quot;  Given a string, return a version without both the first and last char of the string. The string may be any length, including 0. withouEnd2(\u0026quot;Hello\u0026quot;) → \u0026quot;ell\u0026quot; withouEnd2(\u0026quot;abc\u0026quot;) → \u0026quot;b\u0026quot; withouEnd2(\u0026quot;ab\u0026quot;) → \u0026quot;\u0026quot;  Given a string and an int n, return a string made of the first and last n chars from the string. The string length will be at least n. nTwice(\u0026quot;Hello\u0026quot;, 2) → \u0026quot;Helo\u0026quot; nTwice(\u0026quot;Chocolate\u0026quot;, 3) → \u0026quot;Choate\u0026quot; nTwice(\u0026quot;Chocolate\u0026quot;, 1) → \u0026quot;Ce\u0026quot;  Given a string, return true if \u0026ldquo;bad\u0026rdquo; appears starting at index 0 or 1 in the string, such as with \u0026ldquo;badxxx\u0026rdquo; or \u0026ldquo;xbadxx\u0026rdquo; but not \u0026ldquo;xxbadxx\u0026rdquo;. The string may be any length, including 0. Note: use .equals() to compare 2 strings. hasBad(\u0026quot;badxx\u0026quot;) → true hasBad(\u0026quot;xbadxx\u0026quot;) → true hasBad(\u0026quot;xxbadxx\u0026quot;) → false  Given two strings, append them together (known as \u0026ldquo;concatenation\u0026rdquo;) and return the result. However, if the concatenation creates a double-char, then omit one of the chars, so \u0026ldquo;abc\u0026rdquo; and \u0026ldquo;cat\u0026rdquo; yields \u0026ldquo;abcat\u0026rdquo;. conCat(\u0026quot;abc\u0026quot;, \u0026quot;cat\u0026quot;) → \u0026quot;abcat\u0026quot; conCat(\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;) → \u0026quot;dogcat\u0026quot; conCat(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;) → \u0026quot;abc\u0026quot;  Given a string, return true if the first 2 chars in the string also appear at the end of the string, such as with \u0026ldquo;edited\u0026rdquo;. frontAgain(\u0026quot;edited\u0026quot;) → true frontAgain(\u0026quot;edit\u0026quot;) → false frontAgain(\u0026quot;ed\u0026quot;) → true  Given a string, if a length 2 substring appears at both its beginning and end, return a string without the substring at the beginning, so \u0026ldquo;HelloHe\u0026rdquo; yields \u0026ldquo;lloHe\u0026rdquo;. The substring may overlap with itself, so \u0026ldquo;Hi\u0026rdquo; yields \u0026ldquo;\u0026rdquo;. Otherwise, return the original string unchanged. without2(\u0026quot;HelloHe\u0026quot;) → \u0026quot;lloHe\u0026quot; without2(\u0026quot;HelloHi\u0026quot;) → \u0026quot;HelloHi\u0026quot; without2(\u0026quot;Hi\u0026quot;) → \u0026quot;\u0026quot;  Given a string, if the first or last chars are \u0026lsquo;x\u0026rsquo;, return the string without those \u0026lsquo;x\u0026rsquo; chars, and otherwise return the string unchanged. withoutX(\u0026quot;xHix\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX(\u0026quot;xHi\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX(\u0026quot;Hxix\u0026quot;) → \u0026quot;Hxi\u0026quot;  The web is built with HTML strings like \u0026ldquo;Yay\u0026rdquo; which draws Yay as italic text. In this example, the \u0026ldquo;i\u0026rdquo; tag makes and which surround the word \u0026ldquo;Yay\u0026rdquo;. Given tag and word strings, create the HTML string with tags around the word, e.g. \u0026ldquo;Yay\u0026rdquo;. makeTags(\u0026quot;i\u0026quot;, \u0026quot;Yay\u0026quot;) → \u0026quot;\u0026lt;i\u0026gt;Yay\u0026lt;/i\u0026gt;\u0026quot; makeTags(\u0026quot;i\u0026quot;, \u0026quot;Hello\u0026quot;) → \u0026quot;\u0026lt;i\u0026gt;Hello\u0026lt;/i\u0026gt;\u0026quot; makeTags(\u0026quot;cite\u0026quot;, \u0026quot;Yay\u0026quot;) → \u0026quot;\u0026lt;cite\u0026gt;Yay\u0026lt;/cite\u0026gt;\u0026quot;  Given a string, return the string made of its first two chars, so the String \u0026ldquo;Hello\u0026rdquo; yields \u0026ldquo;He\u0026rdquo;. If the string is shorter than length 2, return whatever there is, so \u0026ldquo;X\u0026rdquo; yields \u0026ldquo;X\u0026rdquo;, and the empty string \u0026quot;\u0026rdquo; yields the empty string \u0026ldquo;\u0026rdquo;. Note that str.length() returns the length of a string. firstTwo(\u0026quot;Hello\u0026quot;) → \u0026quot;He\u0026quot; firstTwo(\u0026quot;abcdefg\u0026quot;) → \u0026quot;ab\u0026quot; firstTwo(\u0026quot;ab\u0026quot;) → \u0026quot;ab\u0026quot;  Given 2 strings, a and b, return a string of the form short+long+short, with the shorter string on the outside and the longer string on the inside. The strings will not be the same length, but they may be empty (length 0). comboString(\u0026quot;Hello\u0026quot;, \u0026quot;hi\u0026quot;) → \u0026quot;hiHellohi\u0026quot; comboString(\u0026quot;hi\u0026quot;, \u0026quot;Hello\u0026quot;) → \u0026quot;hiHellohi\u0026quot; comboString(\u0026quot;aaa\u0026quot;, \u0026quot;b\u0026quot;) → \u0026quot;baaab\u0026quot;  Given a string, return a \u0026ldquo;rotated right 2\u0026rdquo; version where the last 2 chars are moved to the start. The string length will be at least 2. right2(\u0026quot;Hello\u0026quot;) → \u0026quot;loHel\u0026quot; right2(\u0026quot;java\u0026quot;) → \u0026quot;vaja\u0026quot; right2(\u0026quot;Hi\u0026quot;) → \u0026quot;Hi\u0026quot;  Given a string of even length, return a string made of the middle two chars, so the string \u0026ldquo;string\u0026rdquo; yields \u0026ldquo;ri\u0026rdquo;. The string length will be at least 2. middleTwo(\u0026quot;string\u0026quot;) → \u0026quot;ri\u0026quot; middleTwo(\u0026quot;code\u0026quot;) → \u0026quot;od\u0026quot; middleTwo(\u0026quot;Practice\u0026quot;) → \u0026quot;ct\u0026quot;  Given a string and an index, return a string length 2 starting at the given index. If the index is too big or too small to define a string length 2, use the first 2 chars. The string length will be at least 2. twoChar(\u0026quot;java\u0026quot;, 0) → \u0026quot;ja\u0026quot; twoChar(\u0026quot;java\u0026quot;, 2) → \u0026quot;va\u0026quot; twoChar(\u0026quot;java\u0026quot;, 3) → \u0026quot;ja\u0026quot;  Given a string, return a string length 2 made of its first 2 chars. If the string length is less than 2, use \u0026lsquo;@\u0026rsquo; for the missing chars. atFirst(\u0026quot;hello\u0026quot;) → \u0026quot;he\u0026quot; atFirst(\u0026quot;hi\u0026quot;) → \u0026quot;hi\u0026quot; atFirst(\u0026quot;h\u0026quot;) → \u0026quot;h@\u0026quot;  Given a string of any length, return a new string where the last 2 chars, if present, are swapped, so \u0026ldquo;coding\u0026rdquo; yields \u0026ldquo;codign\u0026rdquo;. lastTwo(\u0026quot;coding\u0026quot;) → \u0026quot;codign\u0026quot; lastTwo(\u0026quot;cat\u0026quot;) → \u0026quot;cta\u0026quot; lastTwo(\u0026quot;ab\u0026quot;) → \u0026quot;ba\u0026quot;  Given two strings, append them together (known as \u0026ldquo;concatenation\u0026rdquo;) and return the result. However, if the strings are different lengths, omit chars from the longer string so it is the same length as the shorter string. So \u0026ldquo;Hello\u0026rdquo; and \u0026ldquo;Hi\u0026rdquo; yield \u0026ldquo;loHi\u0026rdquo;. The strings may be any length. minCat(\u0026quot;Hello\u0026quot;, \u0026quot;Hi\u0026quot;) → \u0026quot;loHi\u0026quot; minCat(\u0026quot;Hello\u0026quot;, \u0026quot;java\u0026quot;) → \u0026quot;ellojava\u0026quot; minCat(\u0026quot;java\u0026quot;, \u0026quot;Hello\u0026quot;) → \u0026quot;javaello\u0026quot;  Given a string, return a version without the first 2 chars. Except keep the first char if it is \u0026lsquo;a\u0026rsquo; and keep the second char if it is \u0026lsquo;b\u0026rsquo;. The string may be any length. Harder than it looks. deFront(\u0026quot;Hello\u0026quot;) → \u0026quot;llo\u0026quot; deFront(\u0026quot;java\u0026quot;) → \u0026quot;va\u0026quot; deFront(\u0026quot;away\u0026quot;) → \u0026quot;aay\u0026quot;  Given a string, if one or both of the first 2 chars is \u0026lsquo;x\u0026rsquo;, return the string without those \u0026lsquo;x\u0026rsquo; chars, and otherwise return the string unchanged. This is a little harder than it looks. withoutX2(\u0026quot;xHi\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX2(\u0026quot;Hxi\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX2(\u0026quot;Hi\u0026quot;) → \u0026quot;Hi\u0026quot;   "});index.add({'id':58,'href':'/school/java/exercises/temp-04-java-exercises-string-02/','title':"Temp 04 Java Exercises String 02",'content':"Доброе день, String - дос #   Given a string, return a string where for every char in the original, there are two chars. doubleChar(\u0026quot;The\u0026quot;) → \u0026quot;TThhee\u0026quot; doubleChar(\u0026quot;AAbb\u0026quot;) → \u0026quot;AAAAbbbb\u0026quot; doubleChar(\u0026quot;Hi-There\u0026quot;) → \u0026quot;HHii--TThheerree\u0026quot;  Return the number of times that the string \u0026ldquo;code\u0026rdquo; appears anywhere in the given string, except we\u0026rsquo;ll accept any letter for the \u0026rsquo;d\u0026rsquo;, so \u0026ldquo;cope\u0026rdquo; and \u0026ldquo;cooe\u0026rdquo; count. countCode(\u0026quot;aaacodebbb\u0026quot;) → 1 countCode(\u0026quot;codexxcode\u0026quot;) → 2 countCode(\u0026quot;cozexxcope\u0026quot;) → 2  Return true if the given string contains a \u0026ldquo;bob\u0026rdquo; string, but where the middle \u0026lsquo;o\u0026rsquo; char can be any char. bobThere(\u0026quot;abcbob\u0026quot;) → true bobThere(\u0026quot;b9b\u0026quot;) → true bobThere(\u0026quot;bac\u0026quot;) → false  Given a string and an int n, return a string made of n repetitions of the last n characters of the string. You may assume that n is between 0 and the length of the string, inclusive. repeatEnd(\u0026quot;Hello\u0026quot;, 3) → \u0026quot;llollollo\u0026quot; repeatEnd(\u0026quot;Hello\u0026quot;, 2) → \u0026quot;lolo\u0026quot; repeatEnd(\u0026quot;Hello\u0026quot;, 1) → \u0026quot;o\u0026quot;  Given a string, consider the prefix string made of the first N chars of the string. Does that prefix string appear somewhere else in the string? Assume that the string is not empty and that N is in the range 1..str.length(). prefixAgain(\u0026quot;abXYabc\u0026quot;, 1) → true prefixAgain(\u0026quot;abXYabc\u0026quot;, 2) → true prefixAgain(\u0026quot;abXYabc\u0026quot;, 3) → false  Returns true if for every \u0026lsquo;*\u0026rsquo; (star) in the string, if there are chars both immediately before and after the star, they are the same. sameStarChar(\u0026quot;xy*yzz\u0026quot;) → true sameStarChar(\u0026quot;xy*zzz\u0026quot;) → false sameStarChar(\u0026quot;*xa*az\u0026quot;) → true  Return a version of the given string, where for every star () in the string the star and the chars immediately to its left and right are gone. So \u0026ldquo;abcd\u0026rdquo; yields \u0026ldquo;ad\u0026rdquo; and \u0026ldquo;ab**cd\u0026rdquo; also yields \u0026ldquo;ad\u0026rdquo;. starOut(\u0026quot;ab*cd\u0026quot;) → \u0026quot;ad\u0026quot; starOut(\u0026quot;ab**cd\u0026quot;) → \u0026quot;ad\u0026quot; starOut(\u0026quot;sm*eilly\u0026quot;) → \u0026quot;silly\u0026quot;  Return the number of times that the string \u0026ldquo;hi\u0026rdquo; appears anywhere in the given string. countHi(\u0026quot;abc hi ho\u0026quot;) → 1 countHi(\u0026quot;ABChi hi\u0026quot;) → 2 countHi(\u0026quot;hihi\u0026quot;) → 2  Given two strings, return true if either of the strings appears at the very end of the other string, ignoring upper/lower case differences (in other words, the computation should not be \u0026ldquo;case sensitive\u0026rdquo;). Note: str.toLowerCase() returns the lowercase version of a string. endOther(\u0026quot;Hiabc\u0026quot;, \u0026quot;abc\u0026quot;) → true endOther(\u0026quot;AbC\u0026quot;, \u0026quot;HiaBc\u0026quot;) → true endOther(\u0026quot;abc\u0026quot;, \u0026quot;abXabc\u0026quot;) → true  We\u0026rsquo;ll say that a String is xy-balanced if for all the \u0026lsquo;x\u0026rsquo; chars in the string, there exists a \u0026lsquo;y\u0026rsquo; char somewhere later in the string. So \u0026ldquo;xxy\u0026rdquo; is balanced, but \u0026ldquo;xyx\u0026rdquo; is not. One \u0026lsquo;y\u0026rsquo; can balance multiple \u0026lsquo;x\u0026rsquo;s. Return true if the given string is xy-balanced. xyBalance(\u0026quot;aaxbby\u0026quot;) → true xyBalance(\u0026quot;aaxbb\u0026quot;) → false xyBalance(\u0026quot;yaaxbb\u0026quot;) → false  Given a string and an int n, return a string made of the first n characters of the string, followed by the first n-1 characters of the string, and so on. You may assume that n is between 0 and the length of the string, inclusive (i.e. n \u0026gt;= 0 and n \u0026lt;= str.length()). repeatFront(\u0026quot;Chocolate\u0026quot;, 4) → \u0026quot;ChocChoChC\u0026quot; repeatFront(\u0026quot;Chocolate\u0026quot;, 3) → \u0026quot;ChoChC\u0026quot; repeatFront(\u0026quot;Ice Cream\u0026quot;, 2) → \u0026quot;IcI\u0026quot;  Given a string, does \u0026ldquo;xyz\u0026rdquo; appear in the middle of the string? To define middle, we\u0026rsquo;ll say that the number of chars to the left and right of the \u0026ldquo;xyz\u0026rdquo; must differ by at most one. This problem is harder than it looks. xyzMiddle(\u0026quot;AAxyzBB\u0026quot;) → true xyzMiddle(\u0026quot;AxyzBB\u0026quot;) → true xyzMiddle(\u0026quot;AxyzBBB\u0026quot;) → false  Given a string, compute a new string by moving the first char to come after the next two chars, so \u0026ldquo;abc\u0026rdquo; yields \u0026ldquo;bca\u0026rdquo;. Repeat this process for each subsequent group of 3 chars, so \u0026ldquo;abcdef\u0026rdquo; yields \u0026ldquo;bcaefd\u0026rdquo;. Ignore any group of fewer than 3 chars at the end. oneTwo(\u0026quot;abc\u0026quot;) → \u0026quot;bca\u0026quot; oneTwo(\u0026quot;tca\u0026quot;) → \u0026quot;cat\u0026quot; oneTwo(\u0026quot;tcagdo\u0026quot;) → \u0026quot;catdog\u0026quot;  Given a string and a non-empty word string, return a version of the original String where all chars have been replaced by pluses (\u0026ldquo;+\u0026rdquo;), except for appearances of the word string which are preserved unchanged. plusOut(\u0026quot;12xy34\u0026quot;, \u0026quot;xy\u0026quot;) → \u0026quot;++xy++\u0026quot; plusOut(\u0026quot;12xy34\u0026quot;, \u0026quot;1\u0026quot;) → \u0026quot;1+++++\u0026quot; plusOut(\u0026quot;12xy34xyabcxy\u0026quot;, \u0026quot;xy\u0026quot;) → \u0026quot;++xy++xy+++xy\u0026quot;  Return true if the string \u0026ldquo;cat\u0026rdquo; and \u0026ldquo;dog\u0026rdquo; appear the same number of times in the given string. catDog(\u0026quot;catdog\u0026quot;) → true catDog(\u0026quot;catcat\u0026quot;) → false catDog(\u0026quot;1cat1cadodog\u0026quot;) → true  Return true if the given string contains an appearance of \u0026ldquo;xyz\u0026rdquo; where the xyz is not directly preceeded by a period (.). So \u0026ldquo;xxyz\u0026rdquo; counts but \u0026ldquo;x.xyz\u0026rdquo; does not. xyzThere(\u0026quot;abcxyz\u0026quot;) → true xyzThere(\u0026quot;abc.xyz\u0026quot;) → false xyzThere(\u0026quot;xyz.abc\u0026quot;) → true  Given two strings, a and b, create a bigger string made of the first char of a, the first char of b, the second char of a, the second char of b, and so on. Any leftover chars go at the end of the result. mixString(\u0026quot;abc\u0026quot;, \u0026quot;xyz\u0026quot;) → \u0026quot;axbycz\u0026quot; mixString(\u0026quot;Hi\u0026quot;, \u0026quot;There\u0026quot;) → \u0026quot;HTihere\u0026quot; mixString(\u0026quot;xxxx\u0026quot;, \u0026quot;There\u0026quot;) → \u0026quot;xTxhxexre\u0026quot;  Given two strings, word and a separator sep, return a big string made of count occurrences of the word, separated by the separator string. repeatSeparator(\u0026quot;Word\u0026quot;, \u0026quot;X\u0026quot;, 3) → \u0026quot;WordXWordXWord\u0026quot; repeatSeparator(\u0026quot;This\u0026quot;, \u0026quot;And\u0026quot;, 2) → \u0026quot;ThisAndThis\u0026quot; repeatSeparator(\u0026quot;This\u0026quot;, \u0026quot;And\u0026quot;, 1) → \u0026quot;This\u0026quot;  A sandwich is two pieces of bread with something in between. Return the string that is between the first and last appearance of \u0026ldquo;bread\u0026rdquo; in the given string, or return the empty string \u0026quot;\u0026rdquo; if there are not two pieces of bread. getSandwich(\u0026quot;breadjambread\u0026quot;) → \u0026quot;jam\u0026quot; getSandwich(\u0026quot;xxbreadjambreadyy\u0026quot;) → \u0026quot;jam\u0026quot; getSandwich(\u0026quot;xxbreadyy\u0026quot;) → \u0026quot;\u0026quot;  Look for patterns like \u0026ldquo;zip\u0026rdquo; and \u0026ldquo;zap\u0026rdquo; in the string \u0026ndash; length-3, starting with \u0026lsquo;z\u0026rsquo; and ending with \u0026lsquo;p\u0026rsquo;. Return a string where for all such words, the middle letter is gone, so \u0026ldquo;zipXzap\u0026rdquo; yields \u0026ldquo;zpXzp\u0026rdquo;. zipZap(\u0026quot;zipXzap\u0026quot;) → \u0026quot;zpXzp\u0026quot; zipZap(\u0026quot;zopzop\u0026quot;) → \u0026quot;zpzp\u0026quot; zipZap(\u0026quot;zzzopzop\u0026quot;) → \u0026quot;zzzpzp\u0026quot;  Given a string and a non-empty word string, return a string made of each char just before and just after every appearance of the word in the string. Ignore cases where there is no char before or after the word, and a char may be included twice if it is between two words. wordEnds(\u0026quot;abcXY123XYijk\u0026quot;, \u0026quot;XY\u0026quot;) → \u0026quot;c13i\u0026quot; wordEnds(\u0026quot;XY123XY\u0026quot;, \u0026quot;XY\u0026quot;) → \u0026quot;13\u0026quot; wordEnds(\u0026quot;XY1XY\u0026quot;, \u0026quot;XY\u0026quot;) → \u0026quot;11\u0026quot;   "});index.add({'id':59,'href':'/school/java/exercises/temp-05-java-exercises-string-03/','title':"Temp 05 Java Exercises String 03",'content':"Добрый вечер, String - трес #   Given a string, count the number of words ending in \u0026lsquo;y\u0026rsquo; or \u0026lsquo;z\u0026rsquo; \u0026ndash; so the \u0026lsquo;y\u0026rsquo; in \u0026ldquo;heavy\u0026rdquo; and the \u0026lsquo;z\u0026rsquo; in \u0026ldquo;fez\u0026rdquo; count, but not the \u0026lsquo;y\u0026rsquo; in \u0026ldquo;yellow\u0026rdquo; (not case sensitive). We\u0026rsquo;ll say that a y or z is at the end of a word if there is not an alphabetic letter immediately following it. (Note: Character.isLetter(char) tests if a char is an alphabetic letter.) countYZ(\u0026quot;fez day\u0026quot;) → 2 countYZ(\u0026quot;day fez\u0026quot;) → 2 countYZ(\u0026quot;day fyyyz\u0026quot;) → 2  We\u0026rsquo;ll say that a lowercase \u0026lsquo;g\u0026rsquo; in a string is \u0026ldquo;happy\u0026rdquo; if there is another \u0026lsquo;g\u0026rsquo; immediately to its left or right. Return true if all the g\u0026rsquo;s in the given string are happy. gHappy(\u0026quot;xxggxx\u0026quot;) → true gHappy(\u0026quot;xxgxx\u0026quot;) → false gHappy(\u0026quot;xxggyygxx\u0026quot;) → false  Given a string, return the longest substring that appears at both the beginning and end of the string without overlapping. For example, sameEnds(\u0026ldquo;abXab\u0026rdquo;) is \u0026ldquo;ab\u0026rdquo;. sameEnds(\u0026quot;abXYab\u0026quot;) → \u0026quot;ab\u0026quot; sameEnds(\u0026quot;xx\u0026quot;) → \u0026quot;x\u0026quot; sameEnds(\u0026quot;xxx\u0026quot;) → \u0026quot;x\u0026quot;  Given a string, return the sum of the numbers appearing in the string, ignoring all other characters. A number is a series of 1 or more digit chars in a row. (Note: Character.isDigit(char) tests if a char is one of the chars \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, .. \u0026lsquo;9\u0026rsquo;. Integer.parseInt(string) converts a string to an int.) sumNumbers(\u0026quot;abc123xyz\u0026quot;) → 123 sumNumbers(\u0026quot;aa11b33\u0026quot;) → 44 sumNumbers(\u0026quot;7 11\u0026quot;) → 18  Given two strings, base and remove, return a version of the base string where all instances of the remove string have been removed (not case sensitive). You may assume that the remove string is length 1 or more. Remove only non-overlapping instances, so with \u0026ldquo;xxx\u0026rdquo; removing \u0026ldquo;xx\u0026rdquo; leaves \u0026ldquo;x\u0026rdquo;. withoutString(\u0026quot;Hello there\u0026quot;, \u0026quot;llo\u0026quot;) → \u0026quot;He there\u0026quot; withoutString(\u0026quot;Hello there\u0026quot;, \u0026quot;e\u0026quot;) → \u0026quot;Hllo thr\u0026quot; withoutString(\u0026quot;Hello there\u0026quot;, \u0026quot;x\u0026quot;) → \u0026quot;Hello there\u0026quot;  We\u0026rsquo;ll say that a \u0026ldquo;triple\u0026rdquo; in a string is a char appearing three times in a row. Return the number of triples in the given string. The triples may overlap. countTriple(\u0026quot;abcXXXabc\u0026quot;) → 1 countTriple(\u0026quot;xxxabyyyycd\u0026quot;) → 3 countTriple(\u0026quot;a\u0026quot;) → 0  Given a string, look for a mirror image (backwards) string at both the beginning and end of the given string. In other words, zero or more characters at the very begining of the given string, and at the very end of the string in reverse order (possibly overlapping). For example, the string \u0026ldquo;abXYZba\u0026rdquo; has the mirror end \u0026ldquo;ab\u0026rdquo;. mirrorEnds(\u0026quot;abXYZba\u0026quot;) → \u0026quot;ab\u0026quot; mirrorEnds(\u0026quot;abca\u0026quot;) → \u0026quot;a\u0026quot; mirrorEnds(\u0026quot;aba\u0026quot;) → \u0026quot;aba\u0026quot;  Given a string, return a string where every appearance of the lowercase word \u0026ldquo;is\u0026rdquo; has been replaced with \u0026ldquo;is not\u0026rdquo;. The word \u0026ldquo;is\u0026rdquo; should not be immediately preceeded or followed by a letter \u0026ndash; so for example the \u0026ldquo;is\u0026rdquo; in \u0026ldquo;this\u0026rdquo; does not count. (Note: Character.isLetter(char) tests if a char is a letter.) notReplace(\u0026quot;is test\u0026quot;) → \u0026quot;is not test\u0026quot; notReplace(\u0026quot;is-is\u0026quot;) → \u0026quot;is not-is not\u0026quot; notReplace(\u0026quot;This is right\u0026quot;) → \u0026quot;This is not right\u0026quot;  Given a string, return true if the number of appearances of \u0026ldquo;is\u0026rdquo; anywhere in the string is equal to the number of appearances of \u0026ldquo;not\u0026rdquo; anywhere in the string (case sensitive). equalIsNot(\u0026quot;This is not\u0026quot;) → false equalIsNot(\u0026quot;This is notnot\u0026quot;) → true equalIsNot(\u0026quot;noisxxnotyynotxisi\u0026quot;) → true  Given a string, return the sum of the digits 0-9 that appear in the string, ignoring all other characters. Return 0 if there are no digits in the string. (Note: Character.isDigit(char) tests if a char is one of the chars \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, .. \u0026lsquo;9\u0026rsquo;. Integer.parseInt(string) converts a string to an int.) sumDigits(\u0026quot;aa1bc2d3\u0026quot;) → 6 sumDigits(\u0026quot;aa11b33\u0026quot;) → 8 sumDigits(\u0026quot;Chocolate\u0026quot;) → 0  Given a string, return the length of the largest \u0026ldquo;block\u0026rdquo; in the string. A block is a run of adjacent chars that are the same. maxBlock(\u0026quot;hoopla\u0026quot;) → 2 maxBlock(\u0026quot;abbCCCddBBBxx\u0026quot;) → 3 maxBlock(\u0026quot;\u0026quot;) → 0   "});index.add({'id':60,'href':'/school/java/exercises/temp-07-java-exercises-recursion-01/','title':"Temp 07 Java Exercises Recursion 01",'content':"Задачи для курса Java-basic - рекурсия #   Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) \u0026hellip; 1. Compute the result recursively (without loops).\nДано N большее либо равное 1. Вернуть факториал N = n * (n-1) * (n-2) \u0026hellip;. 1. Вычислить результат рекурсивно (без циклов). factorial(1) → 1 factorial(2) → 2 factorial(3) → 6  We have bunnies standing in a line, numbered 1, 2, \u0026hellip; The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we\u0026rsquo;ll say have 3 ears, because they each have a raised foot. Recursively return the number of \u0026ldquo;ears\u0026rdquo; in the bunny line 1, 2, \u0026hellip; n (without loops or multiplication).\nУ нас есть очередь из кроликов и мы получаем количество стоящих в этой очереди кроликов. У нечётных кроликов по два уха. А у чётных кроликов вроде как по три уха. Это из-за того, что они все подняли ногу. Посчитайте количество видимых нами \u0026ldquo;ушей\u0026rdquo;. Не использовать циклы или умножение. bunnyEars2(0) → 0 bunnyEars2(1) → 2 bunnyEars2(2) → 5  Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). Дано положительное целочисленное N. Верните количество семёрок в числе. 717 - вернёт 2. Обратите внимание, что модуло 10 даёт вам правую цифру(126 % 10 равно 6), а деление на 10 удалит правую цифру(126 / 10 равно 12). Авторы задачи были к нам слишком добры и практически решили её прямов условии. count7(717) → 2 count7(7) → 1 count7(123) → 0  Given a string, compute recursively (no loops) the number of lowercase \u0026lsquo;x\u0026rsquo; chars in the string.\nПолучив строку, вычислите рекурсивно (без циклов) количество строчных символов \u0026lsquo;x\u0026rsquo; в строке. countX(\u0026quot;xxhixx\u0026quot;) → 4 countX(\u0026quot;xhixhix\u0026quot;) → 3 countX(\u0026quot;hi\u0026quot;) → 0  Given a string, compute recursively (no loops) a new string where all appearances of \u0026ldquo;pi\u0026rdquo; have been replaced by \u0026ldquo;3.14\u0026rdquo;.\nПолучив строку, вычислите рекурсивно (без циклов) новую строку, в которой все появления \u0026ldquo;pi\u0026rdquo; были заменены на \u0026ldquo;3.14\u0026rdquo;. changePi(\u0026quot;xpix\u0026quot;) → \u0026quot;x3.14x\u0026quot; changePi(\u0026quot;pipi\u0026quot;) → \u0026quot;3.143.14\u0026quot; changePi(\u0026quot;pip\u0026quot;) → \u0026quot;3.14p\u0026quot;  Given an array of ints, compute recursively the number of times that the value 11 appears in the array. We\u0026rsquo;ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array11([1, 2, 11], 0) → 1 array11([11, 11], 0) → 2 array11([1, 2, 3, 4], 0) → 0  Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a \u0026ldquo;*\u0026rdquo;. pairStar(\u0026quot;hello\u0026quot;) → \u0026quot;hel*lo\u0026quot; pairStar(\u0026quot;xxyy\u0026quot;) → \u0026quot;x*xy*y\u0026quot; pairStar(\u0026quot;aaaa\u0026quot;) → \u0026quot;a*a*a*a\u0026quot;  Count recursively the total number of \u0026ldquo;abc\u0026rdquo; and \u0026ldquo;aba\u0026rdquo; substrings that appear in the given string. countAbc(\u0026quot;abc\u0026quot;) → 1 countAbc(\u0026quot;abcxxabc\u0026quot;) → 2 countAbc(\u0026quot;abaxxaba\u0026quot;) → 2  Given a string, compute recursively the number of times lowercase \u0026ldquo;hi\u0026rdquo; appears in the string, however do not count \u0026ldquo;hi\u0026rdquo; that have an \u0026lsquo;x\u0026rsquo; immedately before them. countHi2(\u0026quot;ahixhi\u0026quot;) → 1 countHi2(\u0026quot;ahibhi\u0026quot;) → 2 countHi2(\u0026quot;xhixhi\u0026quot;) → 0  Given a string and a non-empty substring sub, compute recursively the number of times that sub appears in the string, without the sub strings overlapping. strCount(\u0026quot;catcowcat\u0026quot;, \u0026quot;cat\u0026quot;) → 2 strCount(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;) → 1 strCount(\u0026quot;catcowcat\u0026quot;, \u0026quot;dog\u0026quot;) → 0  We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication). bunnyEars(0) → 0 bunnyEars(1) → 2 bunnyEars(2) → 4  We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows. triangle(0) → 0 triangle(1) → 1 triangle(2) → 3  Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). count8(8) → 1 count8(818) → 2 count8(8818) → 4  Given a string, compute recursively (no loops) the number of times lowercase \u0026ldquo;hi\u0026rdquo; appears in the string. countHi(\u0026quot;xxhixx\u0026quot;) → 1 countHi(\u0026quot;xhixhix\u0026quot;) → 2 countHi(\u0026quot;hi\u0026quot;) → 1  Given a string, compute recursively a new string where all the \u0026lsquo;x\u0026rsquo; chars have been removed. noX(\u0026quot;xaxb\u0026quot;) → \u0026quot;ab\u0026quot; noX(\u0026quot;abc\u0026quot;) → \u0026quot;abc\u0026quot; noX(\u0026quot;xx\u0026quot;) → \u0026quot;\u0026quot;  Given a string, compute recursively a new string where all the lowercase \u0026lsquo;x\u0026rsquo; chars have been moved to the end of the string. endX(\u0026quot;xxre\u0026quot;) → \u0026quot;rexx\u0026quot; endX(\u0026quot;xxhixx\u0026quot;) → \u0026quot;hixxxx\u0026quot; endX(\u0026quot;xhixhix\u0026quot;) → \u0026quot;hihixxx\u0026quot;  Given a string, compute recursively (no loops) the number of \u0026ldquo;11\u0026rdquo; substrings in the string. The \u0026ldquo;11\u0026rdquo; substrings should not overlap. count11(\u0026quot;11abc11\u0026quot;) → 2 count11(\u0026quot;abc11x11x11\u0026quot;) → 3 count11(\u0026quot;111\u0026quot;) → 1  Given a string that contains a single pair of parenthesis, compute recursively a new string made of only of the parenthesis and their contents, so \u0026ldquo;xyz(abc)123\u0026rdquo; yields \u0026ldquo;(abc)\u0026rdquo;. parenBit(\u0026quot;xyz(abc)123\u0026quot;) → \u0026quot;(abc)\u0026quot; parenBit(\u0026quot;x(hello)\u0026quot;) → \u0026quot;(hello)\u0026quot; parenBit(\u0026quot;(xy)1\u0026quot;) → \u0026quot;(xy)\u0026quot;  Given a string and a non-empty substring sub, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative. strCopies(\u0026quot;catcowcat\u0026quot;, \u0026quot;cat\u0026quot;, 2) → true strCopies(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;, 2) → false strCopies(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;, 1) → true  The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence. fibonacci(0) → 0 fibonacci(1) → 1 fibonacci(2) → 1  Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). sumDigits(126) → 9 sumDigits(49) → 13 sumDigits(12) → 3  Given base and n that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared). powerN(3, 1) → 3 powerN(3, 2) → 9 powerN(3, 3) → 27  Given a string, compute recursively (no loops) a new string where all the lowercase \u0026lsquo;x\u0026rsquo; chars have been changed to \u0026lsquo;y\u0026rsquo; chars. changeXY(\u0026quot;codex\u0026quot;) → \u0026quot;codey\u0026quot; changeXY(\u0026quot;xxhixx\u0026quot;) → \u0026quot;yyhiyy\u0026quot; changeXY(\u0026quot;xhixhix\u0026quot;) → \u0026quot;yhiyhiy\u0026quot;  Given a string, compute recursively a new string where all the adjacent chars are now separated by a \u0026ldquo;*\u0026rdquo;. allStar(\u0026quot;hello\u0026quot;) → \u0026quot;h*e*l*l*o\u0026quot; allStar(\u0026quot;abc\u0026quot;) → \u0026quot;a*b*c\u0026quot; allStar(\u0026quot;ab\u0026quot;) → \u0026quot;a*b\u0026quot;  We\u0026rsquo;ll say that a \u0026ldquo;pair\u0026rdquo; in a string is two instances of a char separated by a char. So \u0026ldquo;AxA\u0026rdquo; the A\u0026rsquo;s make a pair. Pair\u0026rsquo;s can overlap, so \u0026ldquo;AxAxA\u0026rdquo; contains 3 pairs \u0026ndash; 2 for A and 1 for x. Recursively compute the number of pairs in the given string. countPairs(\u0026quot;axa\u0026quot;) → 1 countPairs(\u0026quot;axax\u0026quot;) → 2 countPairs(\u0026quot;axbx\u0026quot;) → 1  Given a string, return recursively a \u0026ldquo;cleaned\u0026rdquo; string where adjacent chars that are the same have been reduced to a single char. So \u0026ldquo;yyzzza\u0026rdquo; yields \u0026ldquo;yza\u0026rdquo;. stringClean(\u0026quot;yyzzza\u0026quot;) → \u0026quot;yza\u0026quot; stringClean(\u0026quot;abbbcdd\u0026quot;) → \u0026quot;abcd\u0026quot; stringClean(\u0026quot;Hello\u0026quot;) → \u0026quot;Helo\u0026quot;  Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like \u0026ldquo;(())\u0026rdquo; or \u0026ldquo;((()))\u0026rdquo;. Suggestion: check the first and last chars, and then recur on what\u0026rsquo;s inside them. nestParen(\u0026quot;(())\u0026quot;) → true nestParen(\u0026quot;((()))\u0026quot;) → true nestParen(\u0026quot;(((x))\u0026quot;) → false  Given a string and a non-empty substring sub, compute recursively the largest substring which starts and ends with sub and return its length. strDist(\u0026quot;catcowcat\u0026quot;, \u0026quot;cat\u0026quot;) → 9 strDist(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;) → 3 strDist(\u0026quot;cccatcowcatxx\u0026quot;, \u0026quot;cat\u0026quot;) → 9   Рекурсия с массивами #   Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We\u0026rsquo;ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array220([1, 2, 20], 0) → true array220([3, 30], 0) → true array220([3], 0) → false  Given an array of ints, compute recursively if the array contains a 6. We\u0026rsquo;ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array6([1, 6, 4], 0) → true array6([1, 4], 0) → false array6([6], 0) → true   "});index.add({'id':61,'href':'/school/java/exercises/temp-08-java-exercises-loop-01/','title':"Temp 08 Java Exercises Loop 01",'content':"Задачи на циклы #    Существует такая традиция: при приготовлении пельменей в один из них кладут монетку на счастье. Считается, что тому, кому попадется пельмень с монеткой, улыбнется удача.\n Представим, что у нас есть кастрюля, в которой лежит 10 пельменей. Один из них счастливый — а именно пятый пельмень. Давайте напишем программу, которая ищет счастливый пельмень. Программа перебирает пельмени в кастрюле по одному, и когда доходит до пятого пельменя — напишет \u0026ldquo;Вот счастливый пельмень!\u0026rdquo; и выходит из цикла.    Вывести на экран все числа от 1 до 100, которые делятся на 3 без остатка.\n  Необходимо, чтоб программа выводила на экран вот такую последовательность:\nmyLine(100) -\u0026gt; 7 14 21 28 35 42 49 56 63 70 77 84 91 98   Необходимо вывести на консоль такую последовательность чисел:\nmySecondLine(1000) -\u0026gt; 1 2 4 8 16 32 64 128 256 512   Вывести алфавит от A-Z по 4 шт. в строку\n  Выведите на экран первые 11 членов последовательности Фибоначчи.\n первый и второй члены последовательности равны единицам а каждый следующий — сумме двух предыдущих То есть числа Фибоначчи - это 1 1 2 3 5 8 13 21 34 55 89 и т.д.    Дано целое число. Написать метод, который возвращает число, записанное в обратном порядке:\n1234 -\u0026gt; 4321 768 -\u0026gt; 867   Дано целое число. Написать метод, который возвращает сумму разрядов этого числа:\n1234 -\u0026gt; 10 (1+2+3+4) 768 -\u0026gt; 21 (7+6+8)   Найдите в заданном диапазоне хотя бы одно натуральное число, которое делится на 11, а при делении на 2, 3, 4, \u0026hellip;, 10 дает в остатке 1.\nfindDigits(99999, 11) -\u0026gt; 25201, 52921, 80641   Дано целое число. Написать метод, который определит чётность/ нечётность разрядов этого числа:\n123 -\u0026gt; 1 – нечет. 2- чёт. 3-нечет, 4 - чёт. 768 -\u0026gt; 1 – нечет. 2- чёт. 3-чёт.   Написать свой метод проверки строки на палиндром. Учесть, что палиндром может быть предложением с пробелами. При решении задачи используйте цикл.\nНельзя использовать методы replace(), reverse() и конструкции, которые вы не учили.\ncheckPalindrom( \u0026quot;А роза упала на лапу Азора\u0026quot;) -\u0026gt; true checkPalindrom( \u0026quot;поп\u0026quot;) -\u0026gt; true checkPalindrom( \u0026quot;школа\u0026quot;) -\u0026gt; false   Нарисуйте все эти фигуры по очереди.\n  Очень высокий(невероятно) уровень сложности, массивы #   Нарисуйте снежинку makeSnowflake(10)  X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X   "});index.add({'id':62,'href':'/school/java/exercises/temp-09-java-exercises-arrays-01/','title':"Temp 09 Java Exercises Arrays 01",'content':"Закрепление массивов, Java-Basic #    Given an array of ints, return true if 6 appears as either the first or last element in the array. The array will be length 1 or more.\nДан массив int. Верните true, если цифра 6 является значением в первом или последнем элементе массива. Массив будет длиной больше, либо равной единице.\nfirstLast6([1, 2, 6]) → true firstLast6([6, 1, 2, 3]) → true firstLast6([13, 6, 1, 2, 3]) → false   Given 2 arrays of ints, a and b, return true if they have the same first element or they have the same last element. Both arrays will be length 1 or more.\nПолучив 2 массива int[], a и b, возвращаем true, если они имеют один и тот же первый или последний элемент. Оба массива будут длиной больше, либо равной единице.\ncommonEnd([1, 2, 3], [7, 3]) → true commonEnd([1, 2, 3], [7, 3, 2]) → false commonEnd([1, 2, 3], [1, 3]) → true   Given an array of ints length 3, return a new array with the elements in reverse order, so {1, 2, 3} becomes {3, 2, 1}.\nДан массив длиной 3, верните новый массив с элементами в обратном порядке, например {1, 2, 3} становится {3, 2, 1}.\nreverse3([1, 2, 3]) → [3, 2, 1] reverse3([5, 11, 9]) → [9, 11, 5] reverse3([7, 0, 0]) → [0, 0, 7]   Given 2 int arrays, a and b, each length 3, return a new array length 2 containing their middle elements.\nДаны 2 массива int, a и b, каждый длиной 3, верните новый массив с длиной 2, содержащего среднее арифметическое элементов первоначальных массивов.\nmiddleWay([1, 2, 3], [4, 5, 6]) → [2, 5] middleWay([7, 7, 7], [3, 8, 0]) → [7, 8] middleWay([5, 2, 9], [1, 4, 5]) → [2, 4]   Given an int array length 2, return true if it does not contain a 2 or 3.\nno23([4, 5]) → true no23([4, 2]) → false no23([3, 5]) → false   Given an int array length 3, if there is a 2 in the array immediately followed by a 3, set the 3 element to 0. Return the changed array.\nfix23([1, 2, 3]) → [1, 2, 0] fix23([2, 3, 5]) → [2, 0, 5] fix23([1, 2, 1]) → [1, 2, 1]   Given an array of ints of even length, return a new array length 2 containing the middle two elements from the original array. The original array will be length 2 or more.\nmakeMiddle([1, 2, 3, 4]) → [2, 3] makeMiddle([7, 1, 2, 3, 4, 9]) → [2, 3] makeMiddle([1, 2]) → [1, 2]   Given an array of ints of odd length, return a new array length 3 containing the elements from the middle of the array. The array length will be at least 3.\nmidThree([1, 2, 3, 4, 5]) → [2, 3, 4] midThree([8, 6, 7, 5, 3, 0, 9]) → [7, 5, 3] midThree([1, 2, 3]) → [1, 2, 3]   We\u0026rsquo;ll say that a 1 immediately followed by a 3 in an array is an \u0026ldquo;unlucky\u0026rdquo; 1. Return true if the given array contains an unlucky 1 in the first 2 or last 2 positions in the array.\nunlucky1([1, 3, 4, 5]) → true unlucky1([2, 1, 3, 4, 5]) → true unlucky1([1, 1, 1]) → false   Given an array of ints, return true if the array is length 1 or more, and the first element and the last element are equal.\nsameFirstLast([1, 2, 3]) → false sameFirstLast([1, 2, 3, 1]) → true sameFirstLast([1, 2, 1]) → true   Given an array of ints length 3, return the sum of all the elements.\nsum3([1, 2, 3]) → 6 sum3([5, 11, 2]) → 18 sum3([7, 0, 0]) → 7   Given an array of ints length 3, figure out which is larger, the first or last element in the array, and set all the other elements to be that value. Return the changed array.\nmaxEnd3([1, 2, 3]) → [3, 3, 3] maxEnd3([11, 5, 9]) → [11, 11, 11] maxEnd3([2, 11, 3]) → [3, 3, 3]   Given an array of ints, return a new array length 2 containing the first and last elements from the original array. The original array will be length 1 or more.\nmakeEnds([1, 2, 3]) → [1, 3] makeEnds([1, 2, 3, 4]) → [1, 4] makeEnds([7, 4, 6, 2]) → [7, 2]   Given an int array, return a new array with double the length where its last element is the same as the original array, and all the other elements are 0. The original array will be length 1 or more. Note: by default, a new int array contains all 0\u0026rsquo;s.\nmakeLast([4, 5, 6]) → [0, 0, 0, 0, 0, 6] makeLast([1, 2]) → [0, 0, 0, 2] makeLast([3]) → [0, 3]   Start with 2 int arrays, a and b, of any length. Return how many of the arrays have 1 as their first element.\nstart1([1, 2, 3], [1, 3]) → 2 start1([7, 2, 3], [1]) → 1 start1([1, 2], []) → 1   Given 2 int arrays, each length 2, return a new array length 4 containing all their elements.\nplusTwo([1, 2], [3, 4]) → [1, 2, 3, 4] plusTwo([4, 4], [2, 2]) → [4, 4, 2, 2] plusTwo([9, 2], [3, 4]) → [9, 2, 3, 4]   Given an array of ints of odd length, look at the first, last, and middle values in the array and return the largest. The array length will be a least 1.\nmaxTriple([1, 2, 3]) → 3 maxTriple([1, 5, 3]) → 5 maxTriple([5, 2, 3]) → 5   Given 2 int arrays, a and b, return a new array length 2 containing, as much as will fit, the elements from a followed by the elements from b. The arrays may be any length, including 0, but there will be 2 or more elements available between the 2 arrays.\nmake2([4, 5], [1, 2, 3]) → [4, 5] make2([4], [1, 2, 3]) → [4, 1] make2([], [1, 2]) → [1, 2]   Return an int array length 3 containing the first 3 digits of pi, {3, 1, 4}.\nmakePi() → [3, 1, 4]   Given an array of ints length 3, return an array with the elements \u0026ldquo;rotated left\u0026rdquo; so {1, 2, 3} yields {2, 3, 1}.\nrotateLeft3([1, 2, 3]) → [2, 3, 1] rotateLeft3([5, 11, 9]) → [11, 9, 5] rotateLeft3([7, 0, 0]) → [0, 0, 7]   Given an array of ints, return the sum of the first 2 elements in the array. If the array length is less than 2, just sum up the elements that exist, returning 0 if the array is length 0.\nsum2([1, 2, 3]) → 3 sum2([1, 1]) → 2 sum2([1, 1, 1, 1]) → 2   Given an int array length 2, return true if it contains a 2 or a 3.\nhas23([2, 5]) → true has23([4, 3]) → true has23([4, 5]) → false   Given an int array, return true if the array contains 2 twice, or 3 twice. The array will be length 0, 1, or 2.\ndouble23([2, 2]) → true double23([3, 3]) → true double23([2, 3]) → false   Start with 2 int arrays, a and b, each length 2. Consider the sum of the values in each array. Return the array which has the largest sum. In event of a tie, return a.\nbiggerTwo([1, 2], [3, 4]) → [3, 4] biggerTwo([3, 4], [1, 2]) → [3, 4] biggerTwo([1, 1], [1, 2]) → [1, 2]   Given an array of ints, swap the first and last elements in the array. Return the modified array. The array length will be at least 1.\nswapEnds([1, 2, 3, 4]) → [4, 2, 3, 1] swapEnds([1, 2, 3]) → [3, 2, 1] swapEnds([8, 6, 7, 9, 5]) → [5, 6, 7, 9, 8]   Given an int array of any length, return a new array of its first 2 elements. If the array is smaller than length 2, use whatever elements are present.\nfrontPiece([1, 2, 3]) → [1, 2] frontPiece([1, 2]) → [1, 2] frontPiece([1]) → [1]   Given 2 int arrays, a and b, of any length, return a new array with the first element of each array. If either array is length 0, ignore that array.\nfront11([1, 2, 3], [7, 9, 8]) → [1, 7] front11([1], [2]) → [1, 2] front11([1, 7], []) → [1]   "});index.add({'id':63,'href':'/school/java/exercises/temp-10-java-exercises-arrays-02/','title':"Temp 10 Java Exercises Arrays 02",'content':"Закрепление массивов, Java-Basic #   Return the number of even ints in the given array. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder, e.g. 5 % 2 is 1. countEvens([2, 1, 2, 3, 4]) → 3 countEvens([2, 2, 0]) → 3 countEvens([1, 3, 5]) → 0  Return the sum of the numbers in the array, returning 0 for an empty array. Except the number 13 is very unlucky, so it does not count and numbers that come immediately after a 13 also do not count. sum13([1, 2, 2, 1]) → 6 sum13([1, 1]) → 2 sum13([1, 2, 2, 1, 13]) → 6  Given an array of ints, return true if the array contains no 1\u0026rsquo;s and no 3\u0026rsquo;s. lucky13([0, 2, 4]) → true lucky13([1, 2, 3]) → false lucky13([1, 2, 4]) → false  Given a number n, create and return a new int array of length n, containing the numbers 0, 1, 2, \u0026hellip; n-1. The given n may be 0, in which case just return a length 0 array. You do not need a separate if-statement for the length-0 case; the for-loop should naturally execute 0 times in that case, so it just works. The syntax to make a new int array is: new int[desired_length] (See also: FizzBuzz Code) fizzArray(4) → [0, 1, 2, 3] fizzArray(1) → [0] fizzArray(10) → [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  Given an array of ints, return true if it contains no 1\u0026rsquo;s or it contains no 4\u0026rsquo;s. no14([1, 2, 3]) → true no14([1, 2, 3, 4]) → false no14([2, 3, 4]) → true  Given arrays nums1 and nums2 of the same length, for every element in nums1, consider the corresponding element in nums2 (at the same index). Return the count of the number of times that the two elements differ by 2 or less, but are not equal. matchUp([1, 2, 3], [2, 3, 10]) → 2 matchUp([1, 2, 3], [2, 3, 5]) → 3 matchUp([1, 2, 3], [2, 3, 3]) → 2  Given an array of ints, return true if the array contains either 3 even or 3 odd values all next to each other. modThree([2, 1, 3, 5]) → true modThree([2, 1, 2, 5]) → false modThree([2, 4, 2, 5]) → true  Return true if the group of N numbers at the start and end of the array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are the same for n=0 and n=2, and false for n=1 and n=3. You may assume that n is in the range 0..nums.length inclusive. sameEnds([5, 6, 45, 99, 13, 5, 6], 1) → false sameEnds([5, 6, 45, 99, 13, 5, 6], 2) → true sameEnds([5, 6, 45, 99, 13, 5, 6], 3) → false  Return an array that is \u0026ldquo;left shifted\u0026rdquo; by one \u0026ndash; so {6, 2, 5, 3} returns {2, 5, 3, 6}. You may modify and return the given array, or return a new array. shiftLeft([6, 2, 5, 3]) → [2, 5, 3, 6] shiftLeft([1, 2]) → [2, 1] shiftLeft([1]) → [1]  Given a non-empty array of ints, return a new array containing the elements from the original array that come after the last 4 in the original array. The original array will contain at least one 4. Note that it is valid in java to create an array of length 0. post4([2, 4, 1, 2]) → [1, 2] post4([4, 1, 4, 2]) → [2] post4([4, 4, 1, 2, 3]) → [1, 2, 3]  Return a version of the given array where all the 10\u0026rsquo;s have been removed. The remaining elements should shift left towards the start of the array as needed, and the empty spaces a the end of the array should be 0. So {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given array or make a new array. withoutTen([1, 10, 10, 2]) → [1, 2, 0, 0] withoutTen([10, 2, 10]) → [2, 0, 0] withoutTen([1, 99, 10]) → [1, 99, 0]  This is slightly more difficult version of the famous FizzBuzz problem which is sometimes given as a first problem for job interviews. (See also: FizzBuzz Code.) Consider the series of numbers beginning at start and running up to but not including end, so for example start=1 and end=5 gives the series 1, 2, 3, 4. Return a new String[] array containing the string form of these numbers, except for multiples of 3, use \u0026ldquo;Fizz\u0026rdquo; instead of the number, for multiples of 5 use \u0026ldquo;Buzz\u0026rdquo;, and for multiples of both 3 and 5 use \u0026ldquo;FizzBuzz\u0026rdquo;. In Java, String.valueOf(xxx) will make the String form of an int or other type. This version is a little more complicated than the usual version since you have to allocate and index into an array instead of just printing, and we vary the start/end instead of just always doing 1..100. //02-12\u0026mdash;Это немного более сложная версия известной проблемы FizzBuzz, // которую иногда называют первой проблемой для собеседований. (См. Также: Код FizzBuzz.) // Рассмотрим последовательность чисел, начинающуюся с начала и продолжающуюся до, // но не включающую конец, поэтому, например, start = 1 и end = 5 дают серии 1, 2, 3, 4. // Возвращаем новую строку [] массив, содержащий строковую форму этих чисел, // за исключением кратных 3, используйте «Fizz» вместо числа, для кратных 5 используйте «Buzz», // а для кратных 3 и 5 используйте «FizzBuzz». В Java String.valueOf (xxx) // сделает строковую форму типа int или другого типа. Эта версия немного сложнее, чем обычная версия, // так как вам нужно выделять и индексировать массив, // а не просто печатать, и мы меняем начало / конец вместо того, чтобы всегда делать 1..100. fizzBuzz(1, 6) → [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;] fizzBuzz(1, 8) → [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;7\u0026quot;] fizzBuzz(1, 11) → [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;Buzz\u0026quot;]  Given an array length 1 or more of ints, return the difference between the largest and smallest values in the array. Note: the built-in Math.min(v1, v2) and Math.max(v1, v2) methods return the smaller or larger of two values. bigDiff([10, 3, 5, 6]) → 7 bigDiff([7, 2, 10, 9]) → 8 bigDiff([2, 10, 7, 2]) → 8  Return the sum of the numbers in the array, except ignore sections of numbers starting with a 6 and extending to the next 7 (every 6 will be followed by at least one 7). Return 0 for no numbers. sum67([1, 2, 2]) → 5 sum67([1, 2, 2, 6, 99, 99, 7]) → 5 sum67([1, 1, 6, 7, 2]) → 4  Given an array of ints, return true if the sum of all the 2\u0026rsquo;s in the array is exactly 8. sum28([2, 3, 2, 2, 4, 2]) → true sum28([2, 3, 2, 2, 4, 2, 2]) → false sum28([1, 2, 3, 4]) → false  Given an array of ints, return true if every element is a 1 or a 4. only14([1, 4, 1, 4]) → true only14([1, 4, 2, 4]) → false only14([1, 1]) → true  We\u0026rsquo;ll say that a value is \u0026ldquo;everywhere\u0026rdquo; in an array if for every pair of adjacent elements in the array, at least one of the pair is that value. Return true if the given value is everywhere in the array. isEverywhere([1, 2, 1, 3], 1) → true isEverywhere([1, 2, 1, 3], 2) → false isEverywhere([1, 2, 1, 3, 4], 1) → false  Given an array of ints, return true if the array contains two 7\u0026rsquo;s next to each other, or there are two 7\u0026rsquo;s separated by one element, such as with {7, 1, 7}. has77([1, 7, 7]) → true has77([1, 7, 1, 7]) → true has77([1, 7, 1, 1, 7]) → false  Given an array of ints, return true if the value 3 appears in the array exactly 3 times, and no 3\u0026rsquo;s are next to each other. haveThree([3, 1, 3, 1, 3]) → true haveThree([3, 1, 3, 3]) → false haveThree([3, 4, 3, 3, 4]) → false  Return true if the array contains, somewhere, three increasing adjacent numbers like \u0026hellip;. 4, 5, 6, \u0026hellip; or 23, 24, 25. tripleUp([1, 4, 5, 6, 2]) → true tripleUp([1, 2, 3]) → true tripleUp([1, 2, 4]) → false  For each multiple of 10 in the given array, change all the values following it to be that multiple of 10, until encountering another multiple of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}. tenRun([2, 10, 3, 4, 20, 5]) → [2, 10, 10, 10, 20, 20] tenRun([10, 1, 20, 2]) → [10, 10, 20, 20] tenRun([10, 1, 9, 20]) → [10, 10, 10, 20]  We\u0026rsquo;ll say that an element in an array is \u0026ldquo;alone\u0026rdquo; if there are values before and after it, and those values are different from it. Return a version of the given array where every instance of the given value which is alone is replaced by whichever value to its left or right is larger. notAlone([1, 2, 3], 2) → [1, 3, 3] notAlone([1, 2, 3, 2, 5, 2], 2) → [1, 3, 3, 5, 5, 2] notAlone([3, 4], 3) → [3, 4]  Return a version of the given array where each zero value in the array is replaced by the largest odd value to the right of the zero in the array. If there is no odd value to the right of the zero, leave the zero as a zero. zeroMax([0, 5, 0, 3]) → [5, 5, 3, 3] zeroMax([0, 4, 0, 3]) → [3, 4, 3, 3] zeroMax([0, 1, 0]) → [1, 1, 0]  Return the \u0026ldquo;centered\u0026rdquo; average of an array of ints, which we\u0026rsquo;ll say is the mean average of the values, except ignoring the largest and smallest values in the array. If there are multiple copies of the smallest value, ignore just one copy, and likewise for the largest value. Use int division to produce the final average. You may assume that the array is length 3 or more. centeredAverage([1, 2, 3, 4, 100]) → 3 centeredAverage([1, 1, 5, 5, 10, 8, 7]) → 5 centeredAverage([-10, -4, -2, -4, -2, 0]) → -3  Given an array of ints, return true if the array contains a 2 next to a 2 somewhere. has22([1, 2, 2]) → true has22([1, 2, 1, 2]) → false has22([2, 1, 2]) → false  Given an array of ints, return true if the number of 1\u0026rsquo;s is greater than the number of 4\u0026rsquo;s more14([1, 4, 1]) → true more14([1, 4, 1, 4]) → false more14([1, 1]) → true  Given a number n, create and return a new string array of length n, containing the strings \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; .. through n-1. N may be 0, in which case just return a length 0 array. Note: String.valueOf(xxx) will make the String form of most types. The syntax to make a new string array is: new String[desired_length] (See also: FizzBuzz Code) fizzArray2(4) → [\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;] fizzArray2(10) → [\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;6\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;9\u0026quot;] fizzArray2(2) → [\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;]  Given an array of ints, return true if the array contains a 2 next to a 2 or a 4 next to a 4, but not both. either24([1, 2, 2]) → true either24([4, 4, 1]) → true either24([4, 4, 1, 2, 2]) → false  Given an array of ints, return true if there is a 1 in the array with a 2 somewhere later in the array. has12([1, 3, 2]) → true has12([3, 1, 2]) → true has12([3, 1, 4, 5, 2]) → true  Given an array of ints, return true if every 2 that appears in the array is next to another 2. twoTwo([4, 2, 2, 3]) → true twoTwo([2, 2, 4]) → true twoTwo([2, 2, 4, 2]) → false  Given start and end numbers, return a new array containing the sequence of integers from start up to but not including end, so start=5 and end=10 yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the start number. Note that a length-0 array is valid. (See also: FizzBuzz Code) fizzArray3(5, 10) → [5, 6, 7, 8, 9] fizzArray3(11, 18) → [11, 12, 13, 14, 15, 16, 17] fizzArray3(1, 3) → [1, 2]  Given a non-empty array of ints, return a new array containing the elements from the original array that come before the first 4 in the original array. The original array will contain at least one 4. Note that it is valid in java to create an array of length 0. pre4([1, 2, 4, 1]) → [1, 2] pre4([3, 1, 4]) → [3, 1] pre4([1, 4, 4]) → [1]  Return an array that contains the exact same numbers as the given array, but rearranged so that all the zeros are grouped at the start of the array. The order of the non-zero numbers does not matter. So {1, 0, 0, 1} becomes {0 ,0, 1, 1}. You may modify and return the given array or make a new array. zeroFront([1, 0, 0, 1]) → [0, 0, 1, 1] zeroFront([0, 1, 1, 0, 1]) → [0, 0, 1, 1, 1] zeroFront([1, 0]) → [0, 1]  Return an array that contains the exact same numbers as the given array, but rearranged so that all the even numbers come before all the odd numbers. Other than that, the numbers can be in any order. You may modify and return the given array, or make a new array. evenOdd([1, 0, 1, 0, 0, 1, 1]) → [0, 0, 0, 1, 1, 1, 1] evenOdd([3, 3, 2]) → [2, 3, 3] evenOdd([2, 2, 2]) → [2, 2, 2]   "});index.add({'id':64,'href':'/school/java/exercises/temp-11-java-exercises-arrays-03/','title':"Temp 11 Java Exercises Arrays 03",'content':"Закрепление массивов, Java-Basic #   Consider the leftmost and righmost appearances of some value in an array. We\u0026rsquo;ll say that the \u0026ldquo;span\u0026rdquo; is the number of elements between the two inclusive. A single value has a span of 1. Returns the largest span found in the given array. (Efficiency is not a priority.) maxSpan([1, 2, 1, 1, 3]) → 4 maxSpan([1, 4, 2, 1, 4, 1, 4]) → 6 maxSpan([1, 4, 2, 1, 4, 4, 4]) → 6  Given a non-empty array, return true if there is a place to split the array so that the sum of the numbers on one side is equal to the sum of the numbers on the other side. canBalance([1, 1, 1, 2, 1]) → true canBalance([2, 1, 1, 2, 1]) → false canBalance([10, 10]) → true  Given n\u0026gt;=0, create an array with the pattern {1, 1, 2, 1, 2, 3, \u0026hellip; 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length of the array will be 1 + 2 + 3 \u0026hellip; + n, which is known to sum to exactly n*(n + 1)/2. seriesUp(3) → [1, 1, 2, 1, 2, 3] seriesUp(4) → [1, 1, 2, 1, 2, 3, 1, 2, 3, 4] seriesUp(2) → [1, 1, 2]  Return an array that contains exactly the same numbers as the given array, but rearranged so that every 3 is immediately followed by a 4. Do not move the 3\u0026rsquo;s, but every other number may move. The array contains the same number of 3\u0026rsquo;s and 4\u0026rsquo;s, every 3 has a number after it that is not a 3, and a 3 appears in the array before any 4. fix34([1, 3, 1, 4]) → [1, 3, 4, 1] fix34([1, 3, 1, 4, 4, 3, 1]) → [1, 3, 4, 1, 1, 3, 4] fix34([3, 2, 2, 4]) → [3, 4, 2, 2]  Given two arrays of ints sorted in increasing order, outer and inner, return true if all of the numbers in inner appear in outer. The best solution makes only a single \u0026ldquo;linear\u0026rdquo; pass of both arrays, taking advantage of the fact that both arrays are already in sorted order. linearIn([1, 2, 4, 6], [2, 4]) → true linearIn([1, 2, 4, 6], [2, 3, 4]) → false linearIn([1, 2, 4, 4, 6], [2, 4]) → true  We\u0026rsquo;ll say that a \u0026ldquo;mirror\u0026rdquo; section in an array is a group of contiguous elements such that somewhere in the array, the same group appears in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest mirror section found in the given array. maxMirror([1, 2, 3, 8, 9, 3, 2, 1]) → 3 maxMirror([1, 2, 1, 4]) → 3 maxMirror([7, 1, 2, 9, 7, 2, 1]) → 2  (This is a slightly harder version of the fix34 problem.) Return an array that contains exactly the same numbers as the given array, but rearranged so that every 4 is immediately followed by a 5. Do not move the 4\u0026rsquo;s, but every other number may move. The array contains the same number of 4\u0026rsquo;s and 5\u0026rsquo;s, and every 4 has a number after it that is not a 4. In this version, 5\u0026rsquo;s may appear anywhere in the original array. fix45([5, 4, 9, 4, 9, 5]) → [9, 4, 5, 4, 5, 9] fix45([1, 4, 1, 5]) → [1, 4, 5, 1] fix45([1, 4, 1, 5, 5, 4, 1]) → [1, 4, 5, 1, 1, 4, 5]  Given n\u0026gt;=0, create an array length n*n with the following pattern, shown here for n=3 : {0, 0, 1, 0, 2, 1, 3, 2, 1} (spaces added to show the 3 groups). squareUp(3) → [0, 0, 1, 0, 2, 1, 3, 2, 1] squareUp(2) → [0, 1, 2, 1] squareUp(4) → [0, 0, 0, 1, 0, 0, 2, 1, 0, 3, 2, 1, 4, 3, 2, 1]  Say that a \u0026ldquo;clump\u0026rdquo; in an array is a series of 2 or more adjacent elements of the same value. Return the number of clumps in the given array. countClumps([1, 2, 2, 3, 4, 4]) → 2 countClumps([1, 1, 2, 1, 1]) → 2 countClumps([1, 1, 1, 1, 1]) → 1   "});index.add({'id':65,'href':'/school/java/exercises/temp-12-java-exercises-recursion-02/','title':"Temp 12 Java Exercises Recursion 02",'content':"Задачи для курса Java-basic - рекурсия #   Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target? This is a classic backtracking recursion problem. Once you understand the recursive backtracking strategy in this problem, you can use the same pattern for many problems to search a space of choices. Rather than looking at the whole array, our convention is to consider the part of the array starting at index start and continuing to the end of the array. The caller can specify the whole array simply by passing start as 0. No loops are needed \u0026ndash; the recursive calls progress down the array. groupSum(0, [2, 4, 8], 10) → true groupSum(0, [2, 4, 8], 14) → true groupSum(0, [2, 4, 8], 9) → false  Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with these additional constraints: all multiples of 5 in the array must be included in the group. If the value immediately following a multiple of 5 is 1, it must not be chosen. (No loops needed.)  groupSum5(0, [2, 5, 10, 4], 19) → true groupSum5(0, [2, 5, 10, 4], 17) → true groupSum5(0, [2, 5, 10, 4], 12) → false  Given an array of ints, is it possible to divide the ints into two groups, so that the sum of one group is a multiple of 10, and the sum of the other group is odd. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitOdd10(). (No loops needed.) splitOdd10([5, 5, 5]) → true splitOdd10([5, 5, 6]) → false splitOdd10([5, 5, 6, 1]) → true  Given an array of ints, is it possible to choose a group of some of the ints, beginning at the start index, such that the group sums to the given target? However, with the additional constraint that all 6\u0026rsquo;s must be chosen. (No loops needed.) groupSum6(0, [5, 6, 2], 8) → true groupSum6(0, [5, 6, 2], 9) → false groupSum6(0, [5, 6, 2], 7) → false  Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target, with this additional constraint: if there are numbers in the array that are adjacent and the identical value, they must either all be chosen, or none of them chosen. For example, with the array {1, 2, 2, 2, 5, 2}, either all three 2\u0026rsquo;s in the middle must be chosen or not, all as a group. (one loop can be used to find the extent of the identical values). groupSumClump(0, [2, 4, 8], 10) → true groupSumClump(0, [1, 2, 4, 8, 1], 14) → true groupSumClump(0, [2, 4, 4, 8], 14) → false  Given an array of ints, is it possible to divide the ints into two groups, so that the sum of the two groups is the same, with these constraints: all the values that are multiple of 5 must be in one group, and all the values that are a multiple of 3 (and not a multiple of 5) must be in the other. (No loops needed.) split53([1, 1]) → true split53([1, 1, 1]) → false split53([2, 4, 2]) → true  Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with this additional constraint: If a value in the array is chosen to be in the group, the value immediately following it in the array must not be chosen. (No loops needed.) groupNoAdj(0, [2, 5, 10, 4], 12) → true groupNoAdj(0, [2, 5, 10, 4], 14) → false groupNoAdj(0, [2, 5, 10, 4], 7) → false  Given an array of ints, is it possible to divide the ints into two groups, so that the sums of the two groups are the same. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitArray(). (No loops needed.) splitArray([2, 2]) → true splitArray([2, 3]) → false splitArray([5, 2, 3]) → true   "});index.add({'id':66,'href':'/school/tools/01-git/','title':"01 Git",'content':"Git #  Не буду скрывать, Git это та технология, которая не так легко даётся.\nПринципиально, написано достаточно книг, которые всё объясняют намного лучше, чем я когда либо смогу. Именно по этому я написал просто короткую инструкцию для начинающих , где описаны основные приказы, которые тебе понадобятся первое время.\nЕдинственное, что я бы хотел добавить к книгам, которые вам всё равно обязательно надо прочитать, всего несколько предложений.\n Git - это система контроля версий в разработке. Разработка может быть программным кодом, а может быть романом или сценарием к фильму. Не имеет особого значения, что именно мы разрабатываем. В технологии Git используются две важные особенности ветки и коммиты. Коммиты - это точки во временном континууме, которые вы создаёте, для того, что бы была возможность к ним вернуться, если всё пойдёт не так. Что-то вроде сохранения, перед биг-боссом в конце игровой стадии. Ветки - это линии времени, которые может прожить ваш проект или вы с ним. Эти линии можно сводить в одну. А можно развести в любой точке. А можно вести параллельно две или даже три линии и смотреть как получается.  Всё.\nНадеюсь эти аллегории вас не запутали ещё больше.\nПолезные материалы #   Ссылка на методичку в pdf формате  Лайфхак. #  Другие программисты или администраторы у вас будут спрашивать SSH-ключи.\nДля входа на сервер например, что бы внести вас в администраторы или просто дать доступ. Очень хитрый способ предоставления ключей в любой момент с помощью гитхаба\nhttps://github.com/andron13.keys - ник на гитхабе точка keys и там те ключи, которые вы внесли фля работы с ним. с вероятностью в 99% это то, что у вас спрашивают.\n"});index.add({'id':67,'href':'/school/tools/02-github-basic/','title':"02 Github Basic",'content':"Методичка по работе с Git #  Терминология #     Термин Ссылка Пояснение     Git https://git-scm.com/downloads Git - это очень популярная технология контроля версий, используемая при разработке програмного обеспечения и веб-приложений. Онлайн инструкция на русском языке - https://git-scm.com/book/ru/v2/   Github https://github.com/ Популярный сервис для хранения Git-репозиториев. С 2018 года принадлежит Microsoft   Bitbucket https://bitbucket.org/ Популярный сервис для хранения Git-репозиториев. Принадлежит Atlassian и очень тесно интегрирован с популярными IT-приложениями этой фирмы как Trello или Jira   Gitlab https://gitlab.com/ Альтернативный сервис для хранения Git-репозиториев.    Очень важно понимать, что Git и Github не одно и то же. Дополнительные материалы, книги и ссылки следует обязательно прочитать самому. И прежде всего стоит начать с https://git-scm.com/book/ru/v2/\nПолезная информация #  Для работы новичку достаточно знать несколько приказов и установить саму программу https://git-scm.com/downloads. Все команды ниже надо вводить в окно терминала/консоли. Я использую Git Bash\nСоздание SSH ключа для работы с git сервисами #  Для полноценной работы с git-репозиториями требуется SSH-ключ. У Google можно спросить как его получить - \u0026ldquo;how to generate a new ssh key\u0026rdquo;. Или просто ввести команду ниже, если подробности создания уже известны:\nssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; Инициализация проекта #  Часто новичкам удобнее создавать проект в пустой папке:\nmkdir newProjectname cd newProjectname git init Добавление в репозиторий файлов #  Добавление в репозиторий файла index.html:\ngit add index.html Добавление в репозиторий всех файлов в папке:\ngit add . Часто эта команда приводит к плохим последствиям. Потому что добавляет не только файлы разработки, но и временные файлы программы и инструментов, в которых работает программист. Рекомендуется добавлять в репозиторий файлы осознанно и поимённо.\nКоммит #  Фиксирование изменений, ещё несколько лет назад именно так переводили этот термин в литературе. Сегодня этот англицизм плотно вошёл во всю техничискую литературу мирa без перевода.\ngit commit -m \u0026#34;комментарий к коммиту, который объясняет изменения\u0026#34; Ветки #  По умолчанию работа ведётся в ветке мастер. Выйти из ветки мастер и войти в новосоздаваемую ветку одним приказом:\ngit checkout -b newBranchName Выйти/вернуться в ветку, которая на проекте уже была создана\ngit checkout master Удалённый репозиторий и работа с ним #  Origin - это адрес вашего репозитория на одном из git-сервисов, которые вы выбрали. К примеру - Gitlab, Bitbucket или Github. Теоретически можно изменить имя удалёного репозитория на любое другое. Но у новичков достаточно путанницы в терминах и командах, чтобы дополнительно усложнять себе жизнь.\nСинхронизировать ветку мастер на локальном компьютере и origin #  Отправить изменения в интернет:\ngit push origin master Обновить локальный репозиторий:\ngit pull origin master Проверить состояние репозитория или лог изменений в ветке:\ngit status git log Дополнительные материалы #  Ask Google - \u0026ldquo;git book online\u0026rdquo;\n"});index.add({'id':68,'href':'/school/tools/03-boolean-algebra/','title':"03 Boolean Algebra",'content':"Булева алгебра #  Булева алгебра, ударение на первый слог. БУлева.\nПрограммисты учат её в институте. Люди, которые не учились в институте должны будут понять её самостоятельно.\nПри этом всё не так уж и сложно.\nДавайте я попробую на пальцах рассказать основы и то, что нам понадобится на минимальном уровне.\nДизъюнкция #   Когда мама ИЛИ папа дают мне деньги на карманные расходы, то я бегу и покупаю себе мороженное.\n Знакомая ситуация, деньги можно получить в трёх случах из четырёх. В одном случае деньги может дать и мама, и папа, тогда и друга можно угостить мороженным.\nЭто дизъюнкция.\nДизъюнкция - логическое сложение, логическое ИЛИ, включающее или, просто \u0026ldquo;или\u0026rdquo;(англ. OR; нем. ODER) В Java операторы \u0026ldquo;|\u0026rdquo; и \u0026ldquo;||\u0026rdquo;\nboolean a = false, b = true, c; c = a | b; Пример в технике; дублирование выключателя или кнопки, дверной звонок и звонок у калитки вызывают одну и туже реакцию - включается мелодия звонка.\nКонъюнкция #  Конъюнкция - логическое \u0026ldquo;И\u0026rdquo;, логическое умножение, просто \u0026ldquo;И\u0026rdquo;, \u0026ldquo;AND\u0026rdquo;, \u0026quot;\u0026amp;\u0026quot;.\nВ Java оператор \u0026quot;\u0026amp;\u0026quot; и \u0026quot;\u0026amp;\u0026amp;\u0026quot;.\nboolean a = false, b = true, c; c = a \u0026amp; b;  Если светит солнце \u0026ldquo;И\u0026rdquo; у меня выходной, то я иду купаться на озеро.\n Пример из жизни. Ядерный чемоданчик могут активировать только два офицера одновременно. По отдельности чемодан остаётся неактивным.\nАнтиваленц #  \u0026ldquo;XOR\u0026rdquo;, эксклюзивное или, \u0026ldquo;EOR\u0026rdquo;, \u0026ldquo;EXOR\u0026rdquo;. В Java оператор \u0026ldquo;^\u0026rdquo;.\nboolean a = false, b = true, c; c = a ^ b;  Только на горных лыжах в Австрии или на лошадях у бабушки в деревне я забываю про свою работу.\n  Или ты садишься за математику или я расскажу всё отцу.\n ИЛИ - ИЛИ. Исключительное или.\nЛампочка в больнице может работать от городского электричества или от дизельного генератора в подвале. Но не от двух источников одновременно.\nОтрицание #  Negation. NOT. В Java оператор \u0026rdquo;!\u0026quot;.\nboolean a = false, b; b = !a; Давайте представим огромный станок по продольной распилке леса. В цеху есть две кнопки. Зелёная и красная. При включении зелёной пила должна работать. При нажатии на красную пила должна остановится.\nДополнительные материалы #   Прекрасный сайт симулятор для электротехников. Помогает в живую понять основы(и не только) булевой алгебры. http://simulator.io . В последнее время ходили слухи, что проект закроют. Будет невероятно жаль, если сайт не спасут.  Домашнее задание: #  Задача. Петя, Вася и Маша остались дома одни. Кто-то из них ел варенье. На вопрос мамы, кто это сделал, они сказали: а) Петя: \u0026ldquo;Я не ел. Маша тоже не ела.\u0026rdquo; б) Вася: \u0026ldquo;Маша действительно не ела. Это сделал Петя\u0026rdquo; в) Маша: \u0026ldquo;Вася врет. Это он съел.\u0026rdquo;\nВыясните, кто ел варенье, если известно, что двое из них оба раза сказали правду, а третий один раз соврал, а один раз сказал правду.\n"});})();