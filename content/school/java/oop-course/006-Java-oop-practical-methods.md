# Глава, где мы попытаемся разобраться методами

>__Практическая реализация пройденного материала__

Мы изучили процедурное(императивное) программирование и прошли уже пару глав объектно-ориентированного программирования. И это примерно то место, где мы должны сравнить и обобщить методы из одной парадигмы с другой. Есть ли между ними разница?

Если мы хотим найти сумму двух чисел, то в императивной парадигме метод выглядел примерно вот так:

```Java
    public static int addition(int a, int b) {
        return a + b;
    }
```

В ООП наш метод может выглядеть вот так:

```Java
    public int addition(int a, int b) {
        return a + b;
    }
```

Или скорее на практике вот так:

```Java
public class BankAccount {
private int balance;

    public void deposit(int money) {
        balance = balance + money;
    }
}
```

У нас уже была определённая сумма в поле нашего объекта, а именно баланс денег на банковском счёте. И к существующему значение мы прибавили то значение, которое нам передали в метод. 

## Различие первое

Принципиально статический метод достаточно абстрактно складывает два любых значения. Метод объекта BankAccount работает только с определёнными значениями в одном очень практическом примере. В этом и состоит "наглядная разница" между ООП и процедурным программированием

## Различие второе

**Static**. На самом деле нелегко вдруг отказаться от слова статик особенно если не очень понятно, что оно значит. **Static** используется в первую очередь компилятором Java. Компилятор пробегается по нашему коду, находит все статические методы и после окончания его работы мы можем пользоваться нашим приложением и всеми статическими методами сразу. 

Не статические методы класса появляются в нашем приложении только после того, как мы создадим объект(инстанцию класса). Хочу заметить, что объекты могут быть созданы не нами и не в нашем коде, а добавлены во время работы. Например добавление новой статьи на сайте, пользователя в базу данных, нового учебного класса первого сентября. Очевидно, что мы не знаем всех значение этого класса, который будет создан через годы, после того, как мы "выкатим" приложение. 

## Различие третье

Его нет. ООП это только рецепт выражения наших идей, который получил синтаксический сахар. Принципиально программирование всегда остаётся программированием. Методы(функции) принимают значение или значения и выполняют какую-то бизнес-логику. Здесь я использовал английское слово бизнес, которое не очень связано с русским словом бизнес. Если оно вас смущает, то просто говорите "логика приложения".

## Одно важное общее правило

__Избегай повторения кода.__ Что это значит?

Давай рассмотрим на примере. Мы программируем работу кофе-автомата и у нас около 10 различных кофейных напитков.

{{< figure src="/img/res/java-oop/006/coffee-types.jpg" alt="различные типы наследования в Java" >}}

Для примера все напитки вверху. 20 наименований. 20 рецептов. 20 методов. 

Мы написали эти методы. И через некоторое время владелец автомата просит нас изменить рецептуру и добавить больше воды и меньше кофе. По причине того, что новый сорт кофе сильнее, а старого больше нет в свободной продаже. 

Нам надо в 18 методах изменить бизнес-логику приложения и везде на 5% изменить порции. 

У потребителя может изменится время взбивания молока и нам надо помнить где именно мы использовали взбитие молока и потом несколько раз изменять эти рецептуры.

Методы бывают посложнее, а другой раз их бывает и побольше в какой-то момент мы должны придумать как уменьшить количество той работы, которой нам надо сделать, что бы заработать единицу денежек. 

Оптимизация кода состоит в том, что бы переиспользовать методы. 

### Один вопрос ->> одно действие -->> один ответ

Мы можем сделать метод __coffeeBasic__ и принимать количество кофе в граммах. Сделать метод milk и отдельно метод milkFoam, и конечно же метод добавления кипятка. 

```Java
    public static void hotWatter(int gram) {
            // бизнес-логика по насыпанию кофе и добавления кипятка
    }
    public static void coffeeBasic(int gram) {
        // бизнес-логика по насыпанию кофе и добавления кипятка
        // и кстати в этом методе мы вызываем кипяток
        hotWatter(gram);
    }
    public static void milk(int gram) {
        // бизнес-логика по насыпанию кофе и добавления кипятка
    }
    public static void milkFoam(int gram) {
        // бизнес-логика по насыпанию кофе и добавления кипятка
        // а здесь мы добавляем молоко, а потом взбиваем его
        milk(gram); 
        //и кстати взбитые сливки теперь делаются в одном месте.
    }
```

И теперь что бы сделать "FlatWhite", "WhiteCoffee" или "WithADashOfMilk" мы пишем три метода, которые переиспользую методы написанные выше.

```Java
    public static void flatWhite(int gramm) {
        milk(gramm * (3/4));
        coffeeBasic(gramm *(1/4));
    }
    public static void whiteCoffee(int gram) {
        milk(gramm * (1/2));
        coffeeBasic(gramm *(1/2));
    }
    public static void withADashOfMilk(int gram) {
        milk(gramm * (1/4));
        coffeeBasic(gramm *(3/4));
    }
```

При вызове этих методов мы просто говорим о величине порции. Будет это маленькая кружка, средняя или большая нас особо не интересует. Мы не пишем под каждый вариант собственный метод. 

То же самое мы можем сделать и с остальными методами. Но это пожалуй и будет домашним заданием. 

## Домашнее задание

1. Напиши программу обслуживания кофе-автомата. Не используй ООП. 
2. Подумай каким образом это можно было бы написать в ООП и опиши действие своими словами. 
3. Мы вернёмся к этой задаче после изучения абстракции, но никто тебе не мешает уже сейчас почитать о шаблоне проектирования "Декоратор".

## Дополнительные ссылки

1. [Шаблон проектирования](https://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
2. О книге [Design Patterns](https://ru.wikipedia.org/wiki/Design_Patterns). Авторов книги часто называют "банда четырёх".
3. Шаблон проектирования [Декоратор](https://refactoring.guru/ru/design-patterns/decorator/java/example)