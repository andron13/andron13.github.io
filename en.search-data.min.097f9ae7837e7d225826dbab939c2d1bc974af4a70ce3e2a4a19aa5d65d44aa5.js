'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/school/java/','title':"Java",'content':"Java #  К данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки.  "});index.add({'id':1,'href':'/school/','title':"С чего начать",'content':"Какой же язык программирования лучше изучать первым #  Перед тем как выучить основы программирования в своём первом выученном языке, я задавал этот вопрос десятки раз. И лучше всего мне ответили единожды. Ответом был — английский. На самом деле доля правда в этом есть.\nСовременные языки так сильно пытаются упростить вхождение в основы, что написанный код читается уже почти как нормальный произносимый английский: \u0026ldquo;Возьми переменную а, и пока она меньше 10, прибавляй к ней переменную б.\u0026rdquo; Без английского очень часто никак и никуда. Если говорить о современных компьютерных реалиях, то лично моё мнение далеко не однозначно.\nСписок языков, разметок, скриптов и технологий с которыми стоит ознакомиться:\n Java C# Python PHP Javascript HTML CSS XML Word Excel PowerPoint Access Реляционные базы данных, например MySQL, SQL или Derby PowerShell Swift UML Реляционная алгебра Булева алгебра Теория множеств Тестирование программного обеспечения Разработка программного обеспечения  Поверьте мне, что любой программист раскритикует данный список в пух и прах и предоставит свой. Но позвольте я сначала объясню, что я подразумеваю под каждым пунктом.\nJava #  Java — высокоуровневый объектно-ориентированный язык программирования со строгой типизацией переменных. Программы на этом языке работают практически везде, на мой взгляд, это математически хорошо структурированный язык, с прекрасной обучающей документацией и на русском языке. Разработчики и программы на Джаве нужны практически везде: в банковском секторе, на заводах, в медицине и вебдевелопменте(например, поиск). Программы на андроид используют Джаву. Определённо, человек осиливший джаву, не испугается необходимости обучению ещё одному языку. Джава достаточно, если не очень, сложна в обучении и требует хорошего абстрактного мышления. Пример применения в играх — Майнкрафт. Именно с этого языка началось моё знакомство с программированием и, несмотря на все тяжести обучения, я даже полюбил этот язык. Немножко. :)\nC# #  C# — почти всё, что было сказано про Джаву можно сказать и про Сишарп. Майкрософт попытался сделать свою Java и, конечно, языки очень похоже и внешне. Прежде всего, оба языка называются си-подобными. Разница между Си и Джавой с Сишарпом только в уровне. Си низкоуровневый язык, что значит доступ \u0026ldquo;к железу\u0026rdquo; напрямую. А Джава и Сишарп — высокоуровневые, что значит доступ \u0026ldquo;к железу\u0026rdquo; через прослойку в виде операционной системы. Это не плохо и не хорошо. Это просто особенности языков со своими плюсами и минусами, которые следует учитывать при разработке. Если говорить только о Сишарпе, то стоит сказать, что очень многие приложения для смартфонов сделаны на Unity3d, что в свою очередь использует C# и Javascript. Мораль. Если вам интересна десткопная разработка под Windows10 и позже, то скорее всего, вам стоит посмотреть в сторону C# внимательнее. Изучение основ Джавы или Си перед изучением C# совсем не помешает.\nPython #  Python — помимо того, что Питон (или Пайтон) современный и объектно-ориентированный, он ещё и достаточно широко используется. Питон по легенде придуман после попытки выучить Java. Задача стояла сделать синтаксис языка как можно проще, меньше и понятнее. Частично это удалось и, на мой взгляд, Питон — самый распространённый язык среди таких не профессиональных программистов, как бигдата-аналитиков, систем-администраторов, математиков и прочих. С этого языка определённо можно начать знакомство с миром машин. Существует масса уроков онлайн и поддержка комьюнити.\nPHP #  PHP — среди \u0026ldquo;настоящих\u0026rdquo; программистов ходят шуточки про PHP-кодеров. Суть их сводится к тому, что PHP ненастоящий, несерьёзный язык, в нём нет, к примеру, чёткой типизации данных и нет объектов. И, исходя из этого, в PHP кодят те, кто не осилил \u0026ldquo;нормальный\u0026rdquo; язык, как Си, Java, Python и тд. На самом деле, частично всё так. В PHP очень много случайных людей, они пилят свои маленькие псевдосайтики и у них самые маленькие зарплаты в отрасли. Но такое наблюдается практически только среди джунов и, частично, мидлов. Опытные разработчики прекрасно разбираются в архитектуре, проектировании и объектах. И зарплаты у опытных спецов ничем не хуже, чем у коллег из смежных специальностей. Помимо того, уже сейчас в новых версиях PHP активно используется ООП и новые версии фрейморков, например Drupal, вовсю используют \u0026ldquo;сложные\u0026rdquo; технологии, которые раньше в вебдеве были только в энтерпрайзе. Я считаю, что в коммерческой веб-разработке без знания PHP сложно. И можно записать в список изучения PHP, если вы хотите добиться успехов. Именно список. К английскому и PHP добавятся ещё некоторые вещи.\nJavascript #  Javascript — история наименования языка показывает, что нейминг — далеко не бесполезная наука. На данный момент Javascript не менее популярен, чем Java. Javascript используется в вебразработке и уже при создании почти всего. Браузеры же есть везде, а там где есть браузеры, может быть использован и Яваскрипт. Уже упомянутый выше фреймворк Unity3d использует и наш Javascript. И, несмотря на это, я бы его внёс в список изучения не на первом месте. Но всё же обязательным к изучению для всех. Потому что интернетом пользуются все, а интернет и Яваскрипт сегодня \u0026ldquo;неотделимы\u0026rdquo;.\nHTML #  HTML — Hypertext Markup Language. Не язык. Вообще никак не язык. Это просто разметка страницы. Знание основ Hypertext Markup Language входит уже в общее образование, как знание геометрии. Поэтому уговаривать его учить смысла нет. Если вы ещё не знаете, как выглядит HTML-страница изнутри — учите!\nCSS #  CSS — Cascading Style Sheets. Это стили, помогающие отобразить информацию в HTML-документе корректно. Без CSS современная веб-разработка уже невозможна. Первоначально служило дополнением к HTML. На сегодняшний день применяется много шире. К примеру GUI (графический интерфейс) Java в последней версии — JAVAFX использует элементы CSS для отображения информации. В связи с этим, кем бы вы не хотели стать, для чего бы вы не использовали навыки кодирования, скорее всего вам пригодятся знания каскадных стилей. Основы HTML и CSS неподготовленному студенту-филологу можно выучить за 5-10 полноценных учебных дней.\nXML #  XML — ещё один тип разметки, eXtensible Markup Language. Интересен для изучения тем, что разобраться с ним можно за несколько часов, максимум за пару дней. А вкупе с HTML помогает понять, что разметки не такие уж и сложные, и каждая следующая будет даваться легче и легче. Например MD — Markdown, который всё чаще встречается вместо привычного txt-формата. Следует осознать, что иксмл используется везде. В Java, Андроид-разработке, веб-разработке, в создании маленьких \u0026ldquo;домашних\u0026rdquo; \u0026ldquo;баз данных\u0026rdquo;. Если хотите, то это то, что надо выучить первым. И перенести всю коллекцию фильмов в формат XML.\nWord #  Word — в бытность шефом одной небольшой веб-студии, мне очень хотелось скинуть часть скучных обязанностей на своих сотрудников. Не получилось. В совершенстве ни вордом, ни экселем, ни поверпойнтом не владел никто. В итоге был вынужден заняться самообучением и выучить пакет MS Office самостоятельно. И поверьте мне, там есть что учить. В среднем, продвинутым пользователем в ворде можно стать за две-четыре недели обучения. И это пригодится, тем более, программисту. Как вы думаете в какой программе вы будете делать 100-страничную документацию к бухгалтерской программе и вебсайту для средней пиццерии? Что, серьёзно, не задумывались, что всё это кому-то надо делать? Ещё раз - ВОРД!!! Полноценное образование без ворда невозможно.\nExcel #  Excel — MS Excel или Google Spreadsheet. Это то, что надо выучить. Вместо \u0026ldquo;или\u0026rdquo; можно поставить \u0026ldquo;и\u0026rdquo;, и добавить Libre Office. Уверенно чувствовать себя надо везде. Сложные формулы в Google Spreadsheet пишутся кстати на Яваскрипте, а в Екселе на VBS. VBS учить не рекомендую вообще. Малоперспективный скрипт, который забыт даже производителем. MS Excel — это наиболее широко используемая система функционального программирования и помимо того, что помогает в профессиональном плане, никогда не будет лишним и в повседневной жизни.\nPowerPoint #  PowerPoint — или любая другая программа для составления презентаций. В данном случае производитель абсолютно не имеет значения. Но я Виндовс-пользователь и мне проще говорить о продуктах Майкрософт. Я немало поездил по отраслевым конференциям и могу сказать, что далеко не все спикеры умеют выжимать из презентационных материалов максимум возможностей. Умение доступно выражать свои мысли, в том числе, перед коллегами и клиентами поможет в работе неимоверно.\nAccess #  Access — работа с базами данных. В сети достаточно материалов по всем продуктам майкрософта и обучение с Access тем легче, что зачастую он уже есть на компьютере и ничего не надо ставить дополнительно. Программисты хранят данные в базах данных. Системные администраторы администрируют, в том числе, и базы данных. А проектировщики должны, в том числе, понимать, что такое проектирование базы данных. Суть — надо, но, может, всё-таки не в самом начале списка.\nРеляционные базы данных #  Реляционные базы данных, например MySQL, SQL или Derby — существуют различные системы управлениям базами. Ударение стоит сделать на реляционных базах данных. И на MySQL. Но всё же большей разницы, на самом деле, нет. После полноценного изучения MySQL (2-4 недели) каждая следующая система учится за день-два. Если вы учите Java, то вам интересна Дерби и MySQL, если вы хотите учить PHP, то мимо MySQL вам не пройти. Самое главное — научиться проектировать базы, приводить их в нормальную форму и научиться составлять запросы. За месяц-два обучения можно стать очень хорошим специалистом.\nPowerShell #  PowerShell — в своё время я администрировал компы, и именно тогда я возненавидел VBS. Он мне встречался ещё при создании макросов для MS Office. VBS — очень страшная вещь, которая может отбить охоту программировать навсегда. PowerShell — это замена ненавистному скрипту. И, на удивление, замечательная замена. Если у вас Win10, то можете прямо сейчас начать изучать PowerShell и его возможности. С ним можно достичь великих целей. И это совсем не шутка. Администрирование парка машин на Win10 без знания PowerShell невозможно.\nSwift #  Swift — язык, на котором Apple рекомендует писать приложения для OSx. В том числе, и айфонов. Для этих целей я бы рекомендовал именно его тоже.\nUML #  UML — Unified Modeling Language. Язык, который практически не используется в Рунете и, тем более, в вебразработке Рунета. А зря. С помощью этого языка можно нарисовать всё, что угодно: дом, взаимодействие с новой программой, новую базу данных с отношениями и атрибутами, классы и методы с параметрами и без. Всё что угодно. И умея UML и C#, и Java, и Swift, и MySQL дадутся намного легче. Если вообще их можно выучить без знания UML.\nБулева алгебра #  Реляционная алгебра, Булева алгебра, Теория множеств — три крайне важные темы в математике, которые вам понадобятся при обучении языков программирования. Понятно, что в жизни вам может и не понадобятся знания XOR, AND, NOT или OR; но не в обучении. Без понятия булевой алгебры будет очень тяжело. 95% программ не требуют досконального знания двоичной системы, сдвигов влево и вправо, умения в уме складывать и перемножать true и false, но и скрипичный ключ, с войной и миром мне в повседневной жизни не сильно нужен. Это базовые знания. Учить. По-любому.\nМораль #  Морали нет. Путей развития множество:\n Работая в аналитике больших данных, вам никак нельзя без знания алгебры и высшей математики и, скорее всего, будет достаточно Python. Занимаясь веб-разработкой, даже такой \u0026ldquo;простой CMS\u0026rdquo;, как WordPress или Drupal вам понадобятся знания — PHP, HTML, CSS, Javascript, MySQL. Работая Windows-системным администратором, вам понадобится знание всего пакета MS Office, PowerShell, HTML, CSS, XML и алгебры. Разрабатывая под Андроид, понадобится так же немало — Java, HTML, CSS, XML, MySQL.  И, конечно же, всем нужны полноценные знания в MS Office или его аналогам, как минимум, на уровне пользователя.\nМой личный совет — составить план, где урок алгебры чередуется с уроком по Офису и программированием. И мой минимальный список изучения для Windows пользователя:\nПлан Минимум #   Реляционная алгебра, булева алгебра,теория множеств MS Office Markdown XML HTML, CSS Git Java UML Реляционные базы данных, на примере MySQL, Acces Регулярные выражения Javascript  Если вы думаете, что это много, то не забывайте, что вам, скорее всего (возможно), придётся ещё вплотную разбираться с докером, векторной графикой, фотошопом, видео- и аудио- кодеками, апи- фейсбука, инстаграмма, вконтакте, телеграма и тд, и тп.\nПенсионеры #  \u0026ldquo;Ух какой список для пенсионеров!\u0026rdquo;,- заметил мой друг забежав на мой сайт. Этому списку всего 4 года, а уже я бы что-то добавил и убрал.\nПоявились и утвердились на рынке прекрасные языки GO, Kotlin, Dart. Влияние C# на рынок стало меньше. Влияние Windows на разработку уменьшается и PowerShell вряд ли стоит ставить в список обязательно изучаемых вещей.\nТак что скорее мораль - список устарел. А писать его каждый пол-года заново дело малоблагодарное.\n"});index.add({'id':2,'href':'/school/java/basic-course/','title':"01 - Базовый курс Java",'content':"Базовый курс Java online #  Курсы программирования по java, без sms и регистраций. Совершенно бесплатно\nБазовый курс Java включает в себя императивное программирование на Java. Курс включает в себя азы Java, простые типы данных, строковые значения, массивы, задачи и алгоритмы их решения.\nУроки ориентированы на начинающих.\nДля успешного освоения желательно знать школьный курс математики, иметь желание, абстрактное мышление и время. В среднем один урок - 2-5 часов освоения и 3-5 часов самостоятельное закрепление материала.\nУроки регулярно дополняются.\nК данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки. Скоро будет ссылка.  И конечно же задачник #   01 - Логика 02 - Switch 03 - Если, то 04 - Повторение основ 05 - Цикл for 06 - Nested Loops 07 - Modulo 08 - Массивы 09 - Массивы - 2 10 - Разминка 11 - Logic-01 12 - Logic-02 13 - String-01 14 - String-02 15 - String-03 16 - Recursion-01 17 - Recursion-02 18 - Arrays-01 19 - Arrays-02 20 - Arrays-03 21 - Факультатив  Сами уроки #   Java  Басовый курс  01 - Java setup 02 - Целые числа 03 - Десятичные дроби 04 - Символы и строки 05 - Булевые данные 06 - Switch - case 07 - If - else 08 - Modulo 09 - Операторы 10 - Цикл for 11 - Casting литералов 12 - Методы 13 - Цикл while 14 - Ввод данных Scanner 15 - Системы счисления 16 - Тернарный оператор 17 - Рекурсия, введение 18 - Массивы знакомство 19 - Цикл foreach 20 - Varargs 21 - Многомерные arrays 22 - Таинственный main 23 - Операторы перехода 24 - Обмен значений 25 - IDEA - настройка [26 - StringBuffer] 27 - Bubble sort 28 - Comb и cocktail 29 - Insertionsort \u0026hellip; 34 - Try Catch 35! - Создание Jar 36 - Ресурсы        Java   "});index.add({'id':3,'href':'/school/java/basic-course/001-java-setup/','title':"Бесплатные уроки Java online. 01 - Установка JDK и рабочего окружения",'content':"HelloWorld.java — первая программа на Java — введение в Java 001 #  Короткая инструкция, для тех кто нетерпелив #  Для работы с Java в моём курсе нам понадобится:\n JDK - Java Development Kit. Без этого Java-код на компьютере не запускается. IntelliJ IDEA Community Edition. Та программа, в которой я пишу код.  Подробности в длинной инструкции.\nУстановка JDK #  В интернете существуют тысячи инструкций по установке рабочего окружения для работы в Java.\nЯ уверен, что вы сможете вбить в Google запрос на английском: \u0026ldquo;How to Install Java Development Kit\u0026rdquo; или на русском: \u0026ldquo;Установка JDK\u0026rdquo;. Java принадлежит фирме Oracle и можно сразу скачать Java с её страниц, скачав просто JDK, скачав Netbeans вместе с JDK или скачав открытую AdoptOpenJDK (предпочтительнее для новичков).\nЕсли нет, то я попробую рассказать основное: что нам надо, и где это взять.\nJava Development Kit #  JDK — это программа, которая будет переводить написанный вами код в понятный для машин. На вашей машине может быть установлено несколько разных версий Java. Одной из них желательно должна быть Java 8.x. Это та версия, на которой базируются все современные версии, и для изучения основ языка и ООП именно оно нам и \u0026ldquo;нада\u0026rdquo;.\nСкачать JDK можно с AdoptOpenJDK:   Скачать AdoptOpenJDK   Скачать JDK можно с Oracle:   JDK download Oracle   Уверен, вы справитесь с установкой этой программы самостоятельно или с помощью Google.\nРабота с Java #  Работа с Java \u0026ldquo;по старинке\u0026rdquo;.\nВо всех языках программирования стало стандартом первым уроком выводить на экране строчки \u0026ldquo;HelloWorld!\u0026rdquo;.\nКто я такой, что бы идти против правил? Сегодня мы напишем нашу первую программу и выведем на экран \u0026ldquo;Привет Мир!\u0026rdquo;.\nМы создаём файл в редакторе(эдиторе) и сохраняем его под названием HelloWorld.java\n/** * Created by www.andron13.de on 27.12.2016. **/ public class HelloWorld { // Начало нашего класса HelloWorld  public static void main(String[] args) { // Начинаем наш метод, главный метод (мэйн)  System.out.print(\u0026#34;Привет \u0026#34;); System.out.println(\u0026#34;Мир! :-)\u0026#34;); System.out.println(\u0026#34;\\t Hello World!!!\u0026#34;); } // Закрываем главный метод } // Закрываем класс Сразу обращаем внимание на два слеша (слэш, слеш, а также slash, с англ. — «разрез, порез», «резкий удар», «косая черта»), которыми в конце строки можно отделить пометки в тексте. Также комментировать код можно, выделив его с двух сторон звёздочкой и слешем вот так: /* комментарий тут */. Комментарии в коде очень важны. Уже пару дней спустя не всегда очевидны некоторые решения и названия переменных. В иной программе может быть с десяток классов и в каждом — по несколько переменных. И все они что-то там считают, куда-то там что-то передают и зачем-то все вот прям здесь, и \u0026ldquo;кто это вообще написал\u0026rdquo;. Не стесняйтесь комментировать свой код и свои решения. Привычка писать \u0026ldquo;понятный\u0026rdquo; код поможет вам и в учёбе, и в работе.\nЗапускаем терминал или командную строку под Windows: Cтарт-\u0026gt; CMD-\u0026gt; Выполнить.\nКомпилируем и запускаем код:\njavac HelloWorld.java // или javac -encoding utf8 HelloWorld.java // и запускаем с помощью java HelloWorld Внимание - параметр -encoding сработал не во всех версиях JDK на 2.07.2020. Версии от Oracle поддерживают код выше.\n  терминал   С помощью javac мы создаём из нашей программы код, понятный машине. Не считаю нужным углубляться в детали этого процесса, но и ничто не мешает вам почитать о:\n байт-коде, компиляторе, JVM, SDK, JDK  на других полезных ресурсах. История JVM (Java Virtual Machine) очень интересна, ведь ей уже более 20 лет.\nПри запуске мы увидим все системные сообщения на экране. Изменяя параметры программы, мы изменяем результаты. Это и есть программирование. И мы только что написали нашу первую программу.\nЕсли у вас не прошла компиляция, как у меня, попробуйте скомпилировать с помощью учёта кодировки. Кириллица до сих пор не всегда хорошо работает в терминалах Windows. Если у вас не прошла компиляция вообще, то проверьте параметры настроек Java под Windows.\nНе забывайте, что вы должны находиться в той папке, которая внесена в настройках в рабочие Java_Home.\nВ AdoptOpenJDK можно при инсталляции пакета указать на установку Java_Home.\nУстановка Adopt Open JDK:   установка AdoptOpenJDK   Если у вас всё получилось — поздравляю! Вы только что поняли, как именно работали первые Java-кодеры.\nЕсли у вас не всё получилось — не расстраивайтесь. В следующих уроках я подробнее расскажу, как удобнее работать с программами без командной строки и ручной компиляции. Вы можете спокойно переходить ко второму и третьему уроку. С ними всё встанет на свои места.\nСреда разработки Java — выбираем IDE программирования #  Среда разработки Java: Android Studio, IntelliJ IDEA, NetBeans IDE, Eclipse Java Neon\u0026hellip;\nПервую программу на Java я написал в обычном эдиторе на Solaris. Потом компилировал \u0026ldquo;ручками\u0026rdquo;. И запускал тоже ручками, примерно так, как было описано выше. И радовался тогда, очень радовался, если компилятор не выдавал ошибки и, уж тем более, испытывал настоящий восторг, если приложение делало, то что я и хотел. Позже я помню дотошную настройку под Windows 95. С внесением рабочей Java-папки в переменную среду пользователя.Поверьте на слово, порой я настраивал эти переменные среды часами.\nБыло много чего испробовано:\n UltraEdit Notepad и Notepad++ PHP Expert Editor Visual Studio Code Sublime Text и многие другие  Но время редакторов и даже очень хороших редакторов прошло, и если для очень быстрых вещей, особенно за чужим компьютером, я с удовольствием использую портабельный \u0026ldquo;Notepad++\u0026rdquo; с флэшки, то дома я работаю в другой среде. Не в редакторе. А именно среде. И с объяснения термина \u0026ldquo;интегрированная среда разработки\u0026rdquo; мы и начнём.\nИнтегрированная среда разработки - IDE #  Программа для написания кода должна упрощать жизнь программиста и ускорять его работу, например:\n \u0026ldquo;подсвечивать\u0026rdquo; нужные фрагменты, скобки, переменные и т.д. и давать возможность настроить или отключить часть подсветки; подсказывать или \u0026ldquo;автозаполнять\u0026rdquo; код программисту, угадывать, если хотите, что именно он хочет написать; возможность менять дизайн отображения кода; быстро и чётко показывать результат; быстро переключаться между проектами; \u0026ldquo;самостоятельно\u0026rdquo; контролировать версии (например закидывать всё на GIT); помогать найти ошибки в коде и, тем более, синтаксические и орфографические ошибки; и многое другое.  Понятно, что всё это не про Notepad и даже не про Notepad++, хотя с подсветкой справляются многие \u0026ldquo;мелкие\u0026rdquo; редакторы. На рынке сейчас есть несколько крупных программ, которые заявляют себя как JAVA-IDE: это Eclipse (Eclipse Java Neon), IntelliJ IDEA (от JetBrains), NetBeans IDE (от Oracle), Android Studio (от Google \u0026amp; JetBrains).\nДавайте я скажу по \u0026ldquo;два слова\u0026rdquo; о каждой из них:\nAndroid Studio #  Android Studio — основан на IntelliJ IDEA с добавлениями, которые нужны при работе с android приборами. И, на самом деле, это среда разработки под Android на Java. И, говоря о плюсах или минусах, мы всё равно обсуждаем IntelliJ IDEA.\nNetBeans IDE #  NetBeans IDE — рабочая среда от владельцев Java. Можно программировать, есть подсказка, есть подсветка. С моей точки зрения, это очень тяжёлый Notepad++ со встроенным компилятором. Но, на самом деле, NetBeans совсем не так уж плох. И не надо забывать, что он бесплатный и предоставляется компанией, которой принадлежат права на Java.\nIntelliJ IDEA #  IntelliJ IDEA — редактор, утверждающий, что это IDE для Java и всех JVM-языков. Вполне возможно, что это так. Есть бесплатная версия и платная расширенная версия для Java EE (Java Platform, Enterprise Edition). Думаю, что многим будет важно узнать, что программу делают русскоязычные ребята.\nEclipse #  Eclipse — среда разработки для всего. Всех языков, всех платформ. Очень старая программа. Примерно треть всех разработчиков Java сидят в этой программе. Программа выросла из внутренних разработок фирмы IBM и, действительно, известна всем. На мой взгляд, главный конкурент любой среде разработки.\nVisual Studio Code #  Visual Studio Code — изначально этот эдитор не был описан в этой статье. Однако, со временем, я всё чаще и чаще писал программы и документацию именно в нём. Мощный эдитор с огромным комъюнити и огромнейшим количеством полезных плагинов для всех видов разработки.\nЯ использую на работе NetBeans IDE, а дома IntelliJ IDEA и, на самом деле, вы не всегда можете контролировать то, в какой среде вы будете работать. Бывают ситуации, когда работать приходится просто в блокноте. Я веду к тому, что ознакомиться стоит со всеми программами и быть готовым к тому, что их придётся использовать.\nПрежде чем выбирать окончательное решение, стоит поставить, может быть, все IDE и решить самому. Я лично надеюсь, что и Eclipse, и IntelliJ IDEA, NetBeans IDE будут чувствовать себя хорошо и жить долго, чтобы мы могли наслаждаться качеством конкуренции.\nЯ считаю, что в 2020-м году стоит начать с адекватной программы, и мой выбор падает на бесплатную intellij idea community edition, именно в ней будут даны первые уроки.\nУстановка и настройка IntelliJ IDEA для работы в Java #  IntelliJ IDEA — среда разработки программного обеспечения, сделанная в Кронштадте Санкт-Петербурге. Отличие среды разработки(IDE) от редакторов в том, что среда разработки должна \u0026ldquo;предугадывать\u0026rdquo; мысли и действия программиста. Можно, пожалуй, сравнить обычную бумажную записную книжку с телефонами друзей и электронную в телефоне. Удобство пользования электронной намного выше.\nПовторюсь, что, прежде всего, у разработчика должна быть установлена на компьютере восьмая и/или актуальная версия JDK. На данный момент за Java Development Kit отвечает Oracle и у него можно скачать актуальную версию тут. На момент написания статьи это была версия 8.02, и скачать её можно было как отдельно от NetBeans IDE 8.2, так и вместе. Я выбрал JDK 8u111 with NetBeans 8.2. Я очень надеюсь, что будущему разработчику не надо объяснять, какой кнопочкой скачивать из интернета. После установки JDK можно перейти к IntelliJ IDEA.\nIntelliJ IDEA можно скачать на сайте www.jetbrains.com/idea/. Пожалуй, стоит знать, что там же качается и PhpStorm для php и PyCharm для Python.\nIntelliJ IDEA есть в двух версиях — в бесплатной Community и платной Ultimate. Обе версии бывают только на одном языке, и это не русский. Для введения в Java бесплатная версия ничем не хуже платной. Различия в версиях можно посмотреть на сайте производителя перед скачиванием.\nЕсли вам жизненно необходима Ультимативная версия, то не скачивайте \u0026ldquo;лекарство\u0026rdquo;, не ломайте софт и не прописывайте левый сервер в лицензиях. Вы не сможете обновиться, а обновления бывают достаточно часто. Просто скачайте ультимативную версию и закажите себе бесплатные студенческие логины. Подробности студенческой лицензии тут — www.jetbrains.com/student/. IDEA нет на русском языке. Если русский язык очень важен, то у вас есть возможность работать с русским интерфейсом на NetBeans.\nПри установке можно для начала согласиться со всеми настройками по умолчанию и дойти до создания нового проекта. Проектов может быть множество. Например, игра для андроид-приборов или прошивка для \u0026ldquo;умного холодильника\u0026rdquo;. Предположу, что вы не знаете, как будет называться ваша первая программа, поэтому можете назвать проект \u0026ldquo;myFirstJavaProject\u0026rdquo;, \u0026ldquo;JavaBeginner\u0026rdquo; или \u0026ldquo;JavaFromAndron13\u0026rdquo;. Название можно поменять позже, проект можно удалить или перенести файлы из проекта в проект, и поэтому над названием можно особо долго не думать. Желательно, что б оно было говорящее само за себя. На случай если у вас будет 20-30 или даже 1000 проектов.\nДомашнее задание #   Поиграйтесь с выводом строчек в своей среде разработки и попробуйте написать нормальное предложение.  Пример выполненного домашнего задания:  public class HelloWorld { // Начало нашего класса HelloWorld  public static void main(String[] args) { // Начинаем наш метод, главный метод (мэйн)  System.out.print(\u0026#34;Привет \u0026#34;); System.out.println(\u0026#34;Мир! :-)\u0026#34;); System.out.println(\u0026#34;\\t Hello World!!!\u0026#34;); System.out.print(\u0026#34;\\t И ещё строчка :-)\u0026#34;); System.out.print(\u0026#34;Это моя первая программа \\n\u0026#34; ); System.out.print(\u0026#34;\\u0423\\u0440\\u0430 \\n\u0026#34;); System.out.println(\u0026#34;- Mein erstes Programm :-)\u0026#34;); //моя первая программа  } // Закрываем главный метод } // Закрываем класс  Удалите все комментарии из кода и запустите снова. Научитесь быстро находить и печатать следующие символы(они все нам понадобятся при изучении Java) - \u0026#34;() {} [] ^^ || \u0026amp;\u0026amp; %% __ -- ++ ** // \\\\ \u0026#39;\u0026#39; ~~ ;; :: ,, .. \u0026lt;\u0026gt; == !=\u0026#34;  В строке выше 22 пары символов. У вас 22 секунды на написание этой строки самостоятельно.  Дополнительные материалы #  List of Unicode characters - https://en.wikipedia.org/wiki/List_of_Unicode_characters\nСкачать статью в pdf-формате - тут\n"});index.add({'id':4,'href':'/school/frontend/html/02-html-hello-world/','title':"02 Html Hello World",'content':"Теперь мы попробуем приветствовать мир.\nПрежде чем мы действительно начнём изучение следующей главы нам надо решить один вопрос. Терминология:\n Сайт, вебсайт Страница, вебстраница Одностраничник, многостраничник Вебпроект, вебприложение Лэндинг, Landing page Сайт визитка Корпоротивный сайт Вебмагазин Онлайн СМИ Вебпортал Вебресурс  Это всё возможные синонимы, которые можно употребить к тому или иному веб-проекту.\nК множеству подстраниц на одном ресурсе я буду стараться применять сайт, ресурс. К одной единственной странице на сайте я буду обращаться как страница, документ или страница сайта.\nПривет-мир #   Создаём рабочую папку В папке создаём файл \u0026ldquo;first-page.html\u0026rdquo;  Если у вас проблемы с созданием файла с расширением html, то попробуйте создать этот файл с помощью запроса в google \u0026ldquo;как создать html файл\u0026rdquo;. Рекомендую параллельно к этому пособию вообще нагугливать термины и объяснения из альтернативных источников. А вдруг я не прав, а вдруг всё уже поменялось?   Открываем в редакторе вашего выбора наш файл. И пишем в нём ручками код.   helloworld   Что бы привести код в порядок и красиво его отформатировать - мы можем спросить у google как - \u0026ldquo;How do you format code in Visual Studio Code\u0026rdquo;. На первом месте (скорее всего) у вас будет сайт stackoverflow.com. Этот сайт помог не одному программисту в тяжёлой ситуации. Не стесняйтесь им пользоваться. Просто иногда задавайтесь вопросом: \u0026ldquo;Кто вы без этого сайта и сможете ли вы без него повторить то, что узнали?\u0026rdquo;  Сохраняем наш файл и открываем с помощью браузера. Если всё пошло так, то мы в Chromo-подобном браузере мы увидим:\n  helloworld в хромиуме   А в интернет эксплорере скорее всего:\n  helloworld в IE   И мы сразу же можем начинать ругать IE потому что он неправильно отображает страницы. Ну или дядю Андрея, потому что он специально не дал ещё одну строчку.\n\u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; Мы добавляем её так, что бы она оказалась седьмой. Вот так:\n  helloworld с UTF   Сохраняемся и проверяем в Интернет Эксплорере наш файл заново:\n  Проверка страницы в IE   Так что же мы написали #  Давайте начнём с конца. \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; это то, что должно стоять в вашем HTML коде всегда. Это указание браузеру, что на странице используется не только английская кодировка. Существует множество разных кодировок кроме utf-8. Пока можете не углублять свои познания и просто пишите это строчку всегда.\nТо что IE-7 в итоге отобразил нашу страшненькую страницу, не значит, что мы его простили. Я держу его только для того, что бы посмотреть время от времени какой oн ужасный. Раз мы уже коснулись браузеров - вам придётся поставить маленький зоопарк: Chrome, Firefox, Safari, Opera. Хотя с большего и хром, и опера, и фаерфокс это один и тот же браузер. Ну почти. Движок у них общий - chromium. этот зоопарк нужен для проверки работоспособности ваших приложений(web-apps) в различных ситуациях.\n\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; - это на самом деле 3 указания. Во-первых, мета обозначает, что сейчас пойдёт указание для браузера, которое не видно пользователю. Чисто техническая информация. Во-вторых, идёт указание о роде технической информации - charset. И, в-третьих, уже значение чарсета utf-8.\nНо вернёмся к написанному.\nDTD - Document Type Definition #  \u0026lt;!DOCTYPE html\u0026gt; - говорит браузеру, что сейчас начнётся документ написанный в HTML5. Браузер не обладает интеллектом и ему надо говорить, что он должен делать. И именно доктайп говорит, что сейчас надо отображать документ формата HTML, HTML5. Да именно в версии 5. Существуют различные доктайпы. Вот так мог выглядеть доктайп для четвёртого хтмл \u0026lt;!DOCTYPE HTML PUBLIC \u0026quot;-//W3C//DTD HTML 4.01//EN\u0026quot;.\n\u0026lt;!DOCTYPE html\u0026gt; - всегда будет для вас (мастеров HTML5) одинаков, неизменяем и всегда пишется в первой строке.\nHTML #  \u0026lt;html\u0026gt; один раз открывает код страницы и \u0026lt;/html\u0026gt; один раз закрывает. Между открывающим и закрывающим тегом html мы и пишем весь код нашей страницы.\nСам html разбит на две части head и body - голова и тело.\nМы будем возвращаться к голове и телу ещё не один раз. Ну, во-первых, без них нельзя сделать ни одну страницу. А во-вторых некоторые последующие теги привязаны только к \u0026ldquo;голове\u0026rdquo; или только \u0026ldquo;телу\u0026rdquo;.\nЗакрытие и открытие этих тегов проходит, как и у тега html. И мы можем учить новое слово Структурные элементы страницы. Их много больше, одни можно вкладывать в другие, так же как подъезд дома вложен в сам дом, а этаж в подъезд, а квартира вложена в этаж. Комната в квартиру, стол в комнате, а компьютер на столе, при этом стол не может быть в проходе, либо в рабочий кабинет, либо в коридоре, нельзя его оставить в дверях.\nАбсолютно точно так же как и эта аллегория работает структура веб страницы эдакая матрёшка. Один элемент вложен в другой.\nДолжен признать. Я вас обманул. Всё это не так просто. Но вот до этой строчки был порог вхождения. Если вы всё поняли, представили и разобрались до этого момента, то дальше точно будет легко и просто. Обещаю!\nКупились? Не будет. Нет ничего лёгкого даже в этом языке разметки. Мир меняется каждый день, все новые приборы, безбарьерный интернет, новые технологии - всё это накладывает отпечаток на наши веб страницы. Этих элементов и правда не много - сотня. Ещё с какое-то количество атрибутов к ним, ну как charset и их значений. Но с каждым из них реально надо разобраться, посмотреть примеры, применить в практике и запомнить. Не слушайте тех, кто скажет, что редакторам или блогерам HTML не нужен - это миф. Это как фехтовальщику не нужна техника владения мечом - просто руби сверху вниз. Каждый кто связан по работе с веб страницами - обязан хотя бы один раз ознакомится с возможностями этого самого HTML.\nНо мы отвлеклись - едем дальше!\nHead #  Голова, то есть head в него мы вложили ещё title. У тайтла тоже есть открывающий и закрывающий тег. И внутри него мы разместили текст.\n Этот текст отображается в самом тайтле браузера или в закладке браузера, где открыта наша страница. Если закладок много, то текста пользователь скорее всего не увидит. Но это тот же текст, который по дефoлту(default - стандартно) подставляется при внесении страницы в закладки. Попробуйте. Это тот текст, который может быть виден пользователю в результатах поиска в Google.  Отсюда мораль - тайтл должен быть продуманным, если это рецепт борща, то я бы рекомендовал написать там \u0026ldquo;Рецепт борща - 12 шагов\u0026rdquo;. Если это первая страничка на уроке HTML - то наверное есть смысл написать там \u0026ldquo;My first HTML-page - HelloWorld !\u0026rdquo;. Или то что считаете нужным, например \u0026ldquo;qwerty\u0026rdquo; вы же теперь вебмастер знающий основы HTML - вам и решать.\nTitle #  Title размещается только внутри тега head. Title поддерживает \u0026ldquo;Global Attributes\u0026rdquo; - глобальные атрибуты (мне надо было похвалиться своим прекрасным знанием английского языка). Ссылку на список этих атрибутов я приведу внизу статьи, но самостоятельно вы его можете нагуглить уже сейчас, например этой магической фразой \u0026ldquo;global attributes w3c\u0026rdquo;. W3C - это консорциум всемирной паутины, проще говоря боги этого вашего интернета. Про них можно нагуглить в Википедии. Я вас всё время куда-то посылаю не потому что мне лень об этом написать. Просто если я буду писать про все детали - я никогда не закончу. Моя задача научить вас HTML-грамоте. Дополнительные, интересные и полезные материалы часто будут как ссылка в гугл.\nНо давайте сконцентрируемся и перейдём к тому, что мы написали в body, мы открываем и закрываем теги 4 раза: H1, _ article_, _p_ и _q_.\nHTML-тег H1 #  H1 - это заголовок всей страницы видимой пользователю. Очень часто H1 это название самого сайта или название статьи на нём (рецепта, видео, заметки). Вы заметили, что я написал H1 с большой? Мы ведь договорились писать всё с маленькой. Не забываем быть последовательными. h1 - браузеру всё равно, а вот читающему код человеку не всегда.\nHTML-тег article #  article - вся статья помещается внутри этого тега. Если на странице две статьи, то article будет или должен быть использован дважды. Как вы понимаете, желаемое и действительное не всегда одно и то же.\nHTML-тег p(paragraph) #  p - отмечает начало и конец абзаца. Зачем? Ну например, что бы текст начинался с красной строки или каждый нечётный абзац помечался бы другим оттенком, или\u0026hellip; или\u0026hellip; Вариантов использования для чего множество. Например транслировать на сайте в блоке \u0026ldquo;Интересные мысли\u0026rdquo; случайные абзацы редакторов сайта.\nHTML-тег q (HTML Quote Element) #  q - короткая цитата или прямая речь. Очень удобно красиво выделять мысли в тексте. И кстати именно это пример малоизвестного тега, который входит в список \u0026ldquo;ай зачем их всех учить\u0026rdquo;. Забегая вперёд скажу, что если есть короткая цитата, то будет и длинная :).\nЧто мы должны были заметить кроме этого, что вложенный тег должен сначала закрыться сам, прежде чем можно закрывать тег родитель.\n\u0026lt;p\u0026gt;Щас скажу \u0026lt;q\u0026gt;прямую речь\u0026lt;/p\u0026gt; только абзац новый начну\u0026lt;/q\u0026gt; - так не правильно.\nСначала мы должны закончить прямую речь и закрыть тег q и только потом закрыть родительский тег. Смотрим как мы это сделали в примере.\n\u0026lt;p\u0026gt;Щас скажу \u0026lt;q\u0026gt;прямую речь\u0026lt;/q\u0026gt; только абзац новый начну\u0026lt;/p\u0026gt;\nПринципиально, азы HTML мы только что прошли. На самом деле теперь вы можете всем говорить, что вы знаете и понимаете структуру HTML. Вот тот пример мы теперь всё время и будем изменять. Добавлять все новые теги в него и смотреть как он изменяется. Каждый тег мы сейчас будем проходить как маленькую главу и рассматривать примеры применения. Но сначала я вам расскажу про CSS.\nCSS #  Сначала будем делать руками, потом я попробую объяснить, что мы сделали.\n  Создаём в той же папке, где у нас лежит наш хтмл исходник, новый файл с названием style.css\n  Редактируем наш html файл и добавляем туда строчку \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;style.css\u0026quot;\u0026gt;. Строчка должна быть вложена в head страницы, так как это информация не для человека, а для браузера. Этим самым мы говорим, где считывать стили страницы.\n  В сам css файл вносим:\nbody { background-color: #2D2D2D; } h1 { color: saddlebrown; font-size: 30px; font-family: Menlo, Monaco, fixed-width, serif; } p { color: white; font-family: \u0026#34;Source Code Pro\u0026#34;, Menlo, Monaco, fixed-width, serif; } q { color: yellow; }   Сохраняемся и проверяем наш результат в браузере. У нас должно было получится примерно следующее:\n    опера css   Ещё раз код и текст, который лежит в нашей html странице\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;!-- Это моя первая страница. Создана 12 октября 2018 года --\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Привет мир\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;style.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;article\u0026gt; \u0026lt;p\u0026gt; Это моя первая web-страница и я очень волнуюсь: \u0026lt;q\u0026gt;получится ли у меня?\u0026lt;/q\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/article\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Что мы написали в стилях #  Мы указали каждый тег в стилях и сказали как его отображать.\nДля всего body в фигурных { } скобках мы указали цвет бэкграунда. Цвет мы указали в общепринятой 16-ричной системе исчисления. Эту систему обозначают буквами HEX - hexadecimal или система исчисления с базисом 16. Если вы не знаете, что это такое, то коротко скажу, что мы используем систему с базисом 10 и считаем до десяти, вебдизайнеры считают до 16. Подробнее про неё можно (но не обязательно) загуглить в Яндексе - \u0026ldquo;Шестнадцатеричная система счисления\u0026rdquo;.\nДля заголовка(h1) мы указали цвет букв, размер букв и тип и свойства шрифта.\nДля абзаца(p) мы провели такую же операцию только с другими значениями, как и для тайтла. И обратите внимание, и там и там мы указали цвет \u0026ldquo;английскими словами\u0026rdquo;, а не значениями HEX. Существует табличками с заданными названиями для пары сотен HEX значений. Её точно наизусть учить не надо, но эти значения удобно использовать например в протоколировании страницы.\nИ наконец для короткой цитаты (q) мы просто поменяли цвет.\nПринципиально всё. Вы только что изучили введение в CSS. Дальше мы будем тоже просто изменять и пробовать улучшить наши страницы и изучать, что можно сделать с помощью HTML и CSS, а что нет.\nПока можете стереть некоторые значения или даже добавить свои. Внести article в css со своими значениями и попробовать сделать конфликт, например указав разные цвет, размер для шрифтов артикля и абзаца, и посмотреть кто победит.\nПро CSS мы должны знать только, что это стили. Стили пишутся в отдельном файле. Все теги можно описать по отдельности, могут быть не описаны. Для него фронтендера это примерно минимальный базовый уровень.\nА мы продолжаем дальше.\nДомашнее задание #   Создайте страницу index.html. Открыть файл index.html текстовым редактором и написать в нем шаблон страницы. (DOCTYPE, head, body, p и так далее) Напишите маленькую статью в нескольких абзацах с заголовком  Дополнительные ссылки #   Глобальные атрибуты в HTML - mozilla Global Attributes - w3.org  "});index.add({'id':5,'href':'/school/java/basic-course/006-java-switch-case/','title':"006 Java Switch Case",'content':"Switch и Case: оператор выбора — введение в Java 006 #  В этом уроке мы рассмотрим на примерах оператор выбора Switch и опции выбора Case.\nПример:\n За пятёрку в четверти по математике папа обещал мне велосипед. За четвёрку в четверти по математике мама купит мне GoPro4. За тройку меня, наверное, не будут ругать. За двойку меня отругают. За единицу меня \u0026ldquo;убьют\u0026rdquo;.    Опять двойка   Типичный жизненный пример, который можно написать на Java:\npublic class SwitchOne { public static void main(String[] args) { int оценкаВЧетверти = 1; String награда; switch (оценкаВЧетверти) { case 5: награда = \u0026#34;Велосипед\u0026#34;; break; case 4: награда = \u0026#34;GoPro4\u0026#34;; break; case 3: награда = \u0026#34;Награды не будет\u0026#34;; break; case 2: награда = \u0026#34;Потерянный час времени и плохое настроение\u0026#34;; break; case 1: награда = \u0026#34;Лучше не спрашивайте\u0026#34;; break; default: награда = \u0026#34;Такой оценки не существует\u0026#34;; break; } System.out.println(награда); } } Мы видим, что каждая оценка заканчивается брейком: если брейк не ставить, то выбор селектирует следующую награду. Удобно, если у нас одинаковый результат на несколько переменных. Заканчивается ввод данных дефолтным(по умолчанию) выбором, который выдаётся при получении непредусмотренных данных или, лучше сказать, всех остальных неуказанных.\nПри наличии множественных выборов удобно использовать Switch и Case. Направо пойдёшь коня потеряешь, прямо\u0026hellip;. Это именно тот случай, где уже можно использовать такой алгоритм действий.\nПервый же пример из поиска приведёт нас к календарю. Это наиболее используемый пример в учебниках. 12 месяцев с уникальным названием и ID:\npublic class SwitchDemoCalendar { public static void main(String[] args) { int month = 8; String monthString; switch (month) { case 1: monthString = \u0026#34;January\u0026#34;; break; case 2: monthString = \u0026#34;February\u0026#34;; break; case 3: monthString = \u0026#34;March\u0026#34;; break; case 4: monthString = \u0026#34;April\u0026#34;; break; case 5: monthString = \u0026#34;May\u0026#34;; break; case 6: monthString = \u0026#34;June\u0026#34;; break; case 7: monthString = \u0026#34;July\u0026#34;; break; case 8: monthString = \u0026#34;August\u0026#34;; break; case 9: monthString = \u0026#34;September\u0026#34;; break; case 10: monthString = \u0026#34;October\u0026#34;; break; case 11: monthString = \u0026#34;November\u0026#34;; break; case 12: monthString = \u0026#34;December\u0026#34;; break; default: monthString = \u0026#34;Invalid month\u0026#34;; break; } System.out.println(monthString); } } В результате работы данной конструкции мы получаем переменную с нужным значением. В последнем случае \u0026ldquo;monthString\u0026rdquo;, или в случае с оценкой, \u0026ldquo;награда\u0026rdquo;. Абсолютно простая конструкция, где самое сложное — синтаксис, который просто надо выучить. И, после написания 30 различных примеров без шпаргалок, он в крови.\nДля закрепления рассмотрим ещё один пример:\npublic class SwitchCoffee { public static void main(String[] args) { int a = 1; //номер кнопки в кофе-автомате \tswitch (a) { case 1: System.out.println(\u0026#34;Кофе американо готовится\u0026#34;); break; case 2: System.out.println(\u0026#34;Кипяток сейчас будет\u0026#34;); break; case 3: System.out.println(\u0026#34;Кофе эспрессо готовится\u0026#34;); break; case 4: System.out.println(\u0026#34;Какао уже в пути\u0026#34;); break; case 5: System.out.println(\u0026#34;Вода кипятится\u0026#34;); System.out.println(\u0026#34;Кофе мелется\u0026#34;); System.out.println(\u0026#34;Сливки добавляются\u0026#34;); break; default: System.out.println(\u0026#34;повторите свой выбор, напиток под номером: \u0026#34; + a + \u0026#34; Временно недоступен\u0026#34;); break; } System.out.println(\u0026#34;Программа отработана без ошибок\u0026#34;); } } Можно заметить, что в пятом кейсе последнего примера с кофе-автоматом запускается множество сообщений. Мы можем использовать один кейс для запуска нескольких директив. Но это не рекомендуется из-за плохой читаемости кода. Обычно Switch используется для изменения одной переменной. Но это не значит, что вы такого не встретите в чужом коде.\npublic class CoffeeMashine { public static void main(String[] args) { int choose = 2; myChoose(choose); } public static void myChoose(int choose) { switch (choose) { case 3: latte(); break; case 2: americano(); break; case 1: cappucino(); break; default: americano(); } } public static void latte() { System.out.println(\u0026quot;---\u0026quot;); System.out.println(\u0026quot;We are created latte for you master\u0026quot;); milk(40); coffee(30); water(70); System.out.println(\u0026quot;---\u0026quot;); } public static void cappucino() { System.out.println(\u0026quot;---\u0026quot;); System.out.println(\u0026quot;We are created cappucino for you master\u0026quot;); milk(30); coffee(40); water(20); System.out.println(\u0026quot;---\u0026quot;); } public static void americano() { System.out.println(\u0026quot;---\u0026quot;); System.out.println(\u0026quot;We are created americano for you master\u0026quot;); milk(0); coffee(40); water(10); System.out.println(\u0026quot;---\u0026quot;); } public static void water(int ml) { System.out.printf(\u0026quot;Added %d ml of water \\n\u0026quot;, ml); } public static void milk(int ml) { System.out.printf(\u0026quot;Added %d ml of milk \\n\u0026quot;, ml); } public static void coffee(int ml) { System.out.printf(\u0026quot;Added %d ml of coffee \\n\u0026quot;, ml); } } Перед домашним заданием хочется привести ещё один пример применения Switch/Case в жизни: обычный лифт в многоэтажном здании. В зависимости от номера нажимаемой кнопки, лифт едет (ожидаемо) на нужный этаж. Оператор выбора Switch используется вокруг вас везде.\n  Лифт   Дополнительные материалы #  https://docs.oracle.com/javase/tutorial/java/nutsandbolts/switch.html\nДомашнее задание #   Напишите программу действий кассира магазина, если у него пытаются купить алкоголь следующие 5 покупателей: 10 лет, 17 лет, 18 лет, 20 лет и 30 лет. Напишите программу, которая определяет сезон года. Месяца указаны int переменными.  "});index.add({'id':6,'href':'/school/java/basic-course/007-java-if-else/','title':"007 Java if Else",'content':"Условный оператор if, if-else — введение в Java 007 #    если, то   В прошлом уроке я рассматривал оператор выбора Switch. Оператор IF имеет схожие функции и примерно те же цели. Основные отличия — в используемых условиях. Кстати, как обычно, верить мне необязательно: можно спросить у Google, например \u0026ldquo;java switch vs if сравнение\u0026rdquo;. Только на Хабре я нашёл несколько статей, рассматривающих эстетическую сторону вопроса, вопрос скорости, эффективности и вопрос используемых методов.\nПример: поездка в летний лагерь.\nЕсли от родителей будет разрешение (true), то я поеду в летний лагерь. Иначе я останусь на всё лето дома.\nif (true){ System.out.println(\u0026#34;я поеду в летний лагерь\u0026#34;); } else { System.out.println(\u0026#34;я останусь на всё лето дома\u0026#34;); } Switch нет смысла использовать с булевыми значениями: т.к. это всего два варианта. И это одно из отличий if-else и switch.\nСразу про плюсы: If-else позволяет запускать несколько (больше) одной команд.\npublic class IfElseKosmo { public static void main(String[] args) { int a = 5; final int SUPERCONSTANT_G = 10; // модификатор final обозначает константность переменной, которую невозможно изменить.  // например, ускорение свободного падения на поверхности Земли или  // PI, которое всегда константо. Кроме этой особенности final на результаты вычисления  // не влияет  if (a \u0026lt; SUPERCONSTANT_G){ System.out.println(\u0026#34;Первоночальное ускорение недостаточно\u0026#34;); System.out.println(\u0026#34;Ракета не может стартовать\u0026#34;); System.out.println(\u0026#34;Подготовить аварийные службы\u0026#34;); } else { System.out.println(\u0026#34;Ракета улетает в космос\u0026#34;); System.out.println(\u0026#34;Выпустить пресс-релиз об успешном запуске\u0026#34;); System.out.println(\u0026#34;Подготовить программистов к государственным наградам\u0026#34;); } } } В предыдущем уроке был очень жизненный пример про кассира, алкоголь и несовершеннолетних. В Switch нельзя указать \u0026ldquo;младше 18\u0026rdquo;. А в if else можно:\npublic class AlkogolIfElse { public static void main(String[] args) { int возрастПокупателя = 40; if (возрастПокупателя \u0026lt; 16){ System.out.println(\u0026#34;Алкоголь и сигареты продавать нельзя!!!\u0026#34;); } else if (возрастПокупателя \u0026gt;= 18){ System.out.println(\u0026#34;Можно продавать алкоголь и сигареты\u0026#34;); } else { System.out.println(\u0026#34;Водку продавать ещё нельзя, а пиво и сигареты уже можно\u0026#34;); } } } Переменные набраны кириллицей в учебных целях и, чтобы показать, что такое может пройти. Но считается плохим и очень плохим тоном использовать не ASCI символы в переменных.\nИногда программисты печально шутят, что вся жизнь кодера состоит из написания различных if else и Switch команд. Отчасти так и есть. В фундаменте Java не так много команд. И одну из самых часто употребляемых вы только что изучили.\n  Витязь   Дополнительные материалы #   The if-then and if-then-else Statements: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/if.html  Домашнее задание #   Напишите программу действий для сотрудника дорожной полиции, который остановил машину:  при езде до 50 км/час нарушений нет; за езду от 50 км/час до 65 км/час — устное порицание и лекция на 5 минут; за превышение скорости от 16 км/час — 40 евро штрафа; за езду от 100 км/час до 130 км/час — штраф 500 евро; и за езду свыше 130 км/час — штраф в 1000 евро, конфискация прав на 3 года и конфискация транспортного средства.   Напишите программу, которая объяснит наступление определённых событий, в зависимости от выбора \u0026ldquo;витязя\u0026rdquo;. Напишите программу для машины на светофоре. Что делать, если горит красный, жёлтый или зелёный свет. Напишите программу выдачи денег работнику с учётом надбавки за стаж, если базовая зарплата 500$. За 3 года работы надбавка 10%, за 5 лет работы надбавка 50%, за 10 лет работы надбавка 100%, за 15 лет работы надбавка 150%. Метод вывода даты на экран монитора принимает 3 целочисленных значения(день, месяц, год) и разделитель (например \u0026ldquo;-\u0026quot;). Проверить значения данных на адекватность, и если надо дописать нули.\n- 5.6.2020 должно быть выведено на экран как \u0026ldquo;05-06-2020\u0026rdquo; - 50.40.2020 не должно быть выведено вообще  "});index.add({'id':7,'href':'/school/java/basic-course/008-java-modulo/','title':"008 Java Modulo",'content':"Modulo — модуль деления, введение в Java 008 #  Modulo — в специализированной литературе \u0026ldquo;modulo\u0026rdquo; называется оператором деления по модулю или взятием модуля деления. В Java обозначается знаком \u0026ldquo;процентов\u0026rdquo; - %.\nИспользуется это в программировании, например для перевода десятичных чисел в двоичные. Не надо путать этот оператор с делением \u0026ldquo;/\u0026rdquo;. Замечу, что в Википедии на данный момент по запросу modulo выводится статья про \u0026ldquo;деление с остатком\u0026rdquo; . На мой взгляд это очень сильно дезориентирующие определение. Модуль деления — это вычисление остатка от деления целых чисел. Хотелось бы привести оба оператора и показать разницу.\n56 % 24 = 8; 56 / 24 = 2; 24 дважды помещается в 56 и ещё в остатке имеем 8. Читается это так : — Целочисленный остаток от деления 56 на 24 равно 8.\nЯ выговариваю это так: \u0026ldquo;56 модуло 24 равно 8\u0026rdquo;\nС делением дела обстоят немного по другому. Если мы говорим только о целых числах \u0026ldquo;int\u0026rdquo;, то при делении 56 на 24 получаем 2.\nПростейший пример в Java выглядит вот так:\npublic class Modulo { public static void main (String[] args ) { int x = 85; int y = 7; System.out.println(x + \u0026#34; mod \u0026#34;+ y + \u0026#34; = \u0026#34; + x % 7); System.out.println(x + \u0026#34; / \u0026#34;+ y + \u0026#34; = \u0026#34; + x / 7); } } На экране мы получаем:\n85 mod 7 = 1 85 / 7 = 12 Дополнительная литература #   Деление с остатком  Домашнее задание #   Напишите программу, которая находит чётные числа между a и b. Напишите программу, которая находит нечётные числа между a и b. Напишите программу, которая находит числа кратные 11 между a и b. Напишите программу, которая находит простые числа. Дано число меньше 3000. При делении числа на 32 получается остаток 30, при делении на 58 - остаток 44. Найдите число или числа. Напишите программу, которая проверяет год на високосность. Кратный четырём. Прочитайте в Википедии, какие года являются високосными и дополните предыдущую задачу.  "});index.add({'id':8,'href':'/school/java/basic-course/009-java-arithmetic-operators/','title':"009 Java Arithmetic Operators",'content':"Операторы в Java — введение в Java 009 #  Мы уже использовали многое в наших программах не задумываясь. Например знаками знакомыми нам из школьной математики: +, -, = и др.. Пришло время узнать весь список доступных в Java операторов и применение.\nЗаранее скажу, что для введения в Java достаточно понимать первые две таблицы - арифметические операторы и операторы сравнения.\nАрифметические операторы - arithmetic operators #     Оператор Пример использования Пояснение     + a + b Сложение   - a - b Вычитание (также унарный минус)   * a * b Умножение   / a / b Деление   % a % b Деление по модулю   ++ a++ Инкремент, а++ соответствует а = а + 1   \u0026ndash; a\u0026ndash; Декремент, а\u0026ndash; соответствует а = а - 1   += a += b Сложение с присваиванием Выражение a += b эквивалентно значению a = a + b.   -= a -= b Вычитание с присваиванием   *= a *= b Умножение с присваиванием   /= a /= b Деление с присваиванием   %= a %= b Деление по модулю с присваиванием    Знак +, ой, простите, оператор сложения может быть и оператором конкатенации. Конкатенация = объединение, сцепление. Мы с ним знакомы, когда цепляем один String с другим. Мы их не складывали, а конкатенировали.\nОператоры сравнения #  Мы с ними немного познакомились при рассмотрении: тип данных boolean и логические операторы.\n   Оператор Пример Пояснение     == a == b a соответствует(равно) b   != a != b a не соответствует(не равно) b   \u0026gt; a \u0026gt; b а больше b   \u0026gt;= a \u0026gt;= b а больше либо равно b   \u0026lt; a \u0026lt; b а меньше b   \u0026lt;= a \u0026lt;= b а меньше либо равно b   \u0026amp;\u0026amp; a \u0026amp;\u0026amp; b а и b истинны, b оценивается условно (если а ложно, b не вычисляется)   || a || b а или b истинно, b оценивается условно (если а истинно, b не вычисляется)   ! !a а ложно   \u0026amp; a \u0026amp; b AND, а и b истинны, b оценивается в любом случае   | a | b OR, а или b истинно, b оценивается в любом случае   ^ a ^ b XOR, а и b различны (исключительное или, побитовое логическое или)    Побитовые операторы #  Побитовые операторы работают с целыми числами, то есть с типами данных long, int, short, char(!), byte.\n   Оператор Пояснение     ~ Побитовый унарный оператор NOT   \u0026amp; Побитовый AND   \u0026amp;= Побитовый AND с присваиванием   | Побитовый OR   | = Побитовый OR с присваиванием   ^ Побитовый исключающий OR   ^= Побитовый исключающее OR с присваиванием   \u0026gt;\u0026gt; Сдвиг вправо   \u0026gt;= Сдвиг вправо с присваиванием   \u0026gt;\u0026gt;\u0026gt; Сдвиг вправо с заполнением нулями   \u0026laquo; Сдвиг влево   \u0026laquo;= Сдвиг влево с присваиванием   \u0026gt;\u0026gt;\u0026gt;= Сдвиг вправо с заполнением нулями с присваиванием    Это далеко не простая тема и требует повторения/изучения математической составляющей. Но теоретически можно изучать Java и дальше, оставив эту тему на когда-нибудь потом, самое главное никому не говорите, что я это сказал. А если серьёзно, то изучив эту тему вы станете на один шаг ближе к \u0026ldquo;стать программистом\u0026rdquo;.\nДоп. ссылки:\n Битовый сдвиг Побитовые операции в Java Побитовые операторы RAID  Логические операторы #     Логический операторы Значение     == Проверка на соотвествие (допустим, что a равен b)   != Неравно (eсли a неравно b, то)   ! Отрицание, логическое не   \u0026amp; Логическое И, and   | Логическое или, or   ^ Исключительное или, XOR   \u0026amp;\u0026amp; Укороченный \u0026amp;   || Укороченный или   \u0026amp;= AND с присваиванием   |= OR с присваиванием   ^= XOR с присваиванием   ?: Тернарный (троичный) условный оператор    Тернарный оператор достаточно интересен, мы его обязательно рассмотрим отдельно в следующих уроках.\nОператоры присваивания #  Операторы присваивания содержат в себе знак равенства =. Все их мы уже рассмотрели в рамках других операторов. И в этом нет никакого противоречия. Java многогранна и её не всегда можно однозначно описать простым языком кожаных мешков. Тот же += является одновременно оператором арифметическим и присваивания.\nЭто не значит, что вы не можете составить таблицу операторов сравнения самостоятельно.\nДля факультативного изучения #    Помимо всего прочего, операторы бывают унарными. Соответственно существуют бинарные и тернарные операторы. Логические операторы \u0026amp;\u0026amp; и || - это укороченные версии операторов \u0026amp; и |.   Отличие заключается в том, что например в укороченной версии (или), если первый операнд имеет значение (true), то выражение сразу становится (true) и второй операнд даже не рассматривается. То же самое и с (и), если первый операнд имеет ложное значение (false), то и все выражение сразу становится (false), второй операнд не рассматривается. И соответственно благодаря тому, что значение второго операнда вычислять не нужно, экономится время и повышается эффективность кода.\nПример:\npublic class AndAnd { public static void main(String[] args) { if(a() \u0026amp;\u0026amp; b()){ //здесь меняем оператор и сравниваем результаты  System.out.println(\u0026#34;Готово\u0026#34;); }else{ System.out.println(\u0026#34;Не получилось\u0026#34;); } } public static boolean a(){ System.out.print(\u0026#34;Hallo \u0026#34;); return false; } public static boolean b(){ System.out.println(\u0026#34;World\u0026#34;); return true; } }   //Если использовать оператор \u0026amp;\u0026amp;, то\n  Hallo Не получилось\n  //Вывод при использовании оператора \u0026amp;\n  Hallo World\n  Не получилось\n  Если должны быть проверены все условия, то надо использовать \u0026amp;. Если речь идёт о быстром и чётком решении, то \u0026amp;\u0026amp; помогает сэкономить ресурсы и время.\nДополнительные материалы #   https://docs.oracle.com/javase/tutorial/java/nutsandbolts/opsummary.html https://docs.oracle.com/javase/tutorial/java/nutsandbolts/operators.html https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html Прекраснейшая статья о побитовом сдвиге - https://javarush.ru/groups/posts/1925-pobitovihe-operacii https://www.baeldung.com/java-compound-operators  Очень рекомендую ресурс - www.baeldung.com. На проекте очень много грамотных постов о Java и из мира Java. Можно ввести в Google запрос \u0026ldquo;baeldung cast int\u0026rdquo; и получить прекрасную статью для самостоятельного изучения конвертации данных из типа данных String в int. Ресурс определённо в закладки.\nДомашнее задание #   Ознакомьтесь с термином - body mass index (BMI) Индекс массы тела . Напишите программу расчёта индекса массы тела. Если возникнут сложности, помните, что у вас есть все знания, что бы решить данную задачу. Просто решите её сначала на бумаге, а потом перенесите в Java.  "});index.add({'id':9,'href':'/school/java/basic-course/010-java-for/','title':"010 Java For",'content':"Цикл FOR — введение в Java 010 #    петля   Каждый день я встаю в шесть утра и иду на завод к восьми, в семь вечера я уже снова дома, смотрю кино по телевизору, курю с соседом на лестничной клетке и в одиннадцать уже иду спать. Утром вторника повторяется всё то же самое, и в среду, и в четверг, и в пятницу.\nВсё это можно описать, например, с помощью блока if else. Ничего сложного: если понедельник, то подъём; а если вдруг вторник, то тоже подъём; если среда, то подъём и т.д. и т.п. Но кусок кода повторяющийся, и для таких случаев придумали циклы, один из них — цикл FOR. Условно, с понедельника по пятницу выполняется следующий алгоритм действий: подъём, работа, телевизор, спать. Пример:\npublic class FourWeek { public static void main(String[] args) { int weekDays = 7; for (int i = 1; i \u0026lt; weekDays ; i++) { System.out.println(\u0026#34;------------\u0026#34;); System.out.println(\u0026#34;Новый день\u0026#34;); System.out.println(\u0026#34;я встаю в шесть утра\u0026#34;); System.out.println(\u0026#34;иду на завод к восьми\u0026#34;); System.out.println(\u0026#34;я уже дома\u0026#34;); System.out.println(\u0026#34;смотрю кино по телевизору\u0026#34;); System.out.println(\u0026#34;курю с соседом на лестничной клетке\u0026#34;); System.out.println(\u0026#34;иду спать\u0026#34;); System.out.println(\u0026#34;День подошёл к концу\u0026#34;); System.out.println(\u0026#34;-------------\u0026#34;); } } } Область видимости #  Мы можем использовать несколько циклов подряд:\npublic class Main { public static void main(String[] args) { int a = 0; for (int i = 0; i \u0026lt; 10; i++) { a++; } for (int i = 0; i \u0026lt; 20; i++) { a++; } System.out.println(a); System.out.println(i); } } При этом операции над переменной a будут проходить в каждом цикле, потому что a принадлежит к области видимости всего метода. А вот попытка вывести на консоль i приведёт к ошибке. Переменная i, в данном случае, объявлялась только в циклах, и за пределами самого цикла не видна. Именно поэтому мы и смогли декларировать эту переменную дважды. Потому что в самом методе её как бы и нет.\nМы можем экранировать переменные просто скобками:\npublic class Main { public static void main(String[] args) { int a = 0; { int b = 7; a = a + b; } System.out.println(a); System.out.println(b); } } В данном примере попытка \u0026ldquo;распечатать\u0026rdquo; b приведёт к ошибке. Декларация переменной произошла в экранированном участке кода. Но операции с a программа запомнит, потому что программа декларировала a, и закрытый участок кода для а — просто часть программы. Сверху вниз смотреть можно, а снизу вверх смотреть нельзя.\nИ снова к самому циклу for #  Это могут быть и арифметические операции:\npublic class FourTest { public static void main(String[] args) { int a = 20; int b = 11; int c; for (int i = 0; i \u0026lt; a; i++) { b = b + i; c = i + 1; System.out.println(\u0026#34;c \u0026#34; + c); } System.out.println(\u0026#34;b \u0026#34; + b); } } В определённом или в заданном интервале мы изменяем переменную по определённой формуле.\nfor (начало; условие; шаг) { // ... тело цикла ... в котором можно выполнять одну, две, три или даже очень много операций. } for (initialization condition; testing condition; increment/decrement){ statement(s) } For — это цикл, в котором \u0026ldquo;тело\u0026rdquo; выполняется заданное количество раз.\nНачало, условие, шаг #  Начало, условие, шаг надо запомнить не как \u0026ldquo;Отче наш\u0026rdquo;. А \u0026ldquo;Отче наш\u0026rdquo; заменяется теперь на \u0026ldquo;начало, условие, шаг\u0026rdquo;. Ещё один пример, где мы работаем только с одной переменной — отсчёт обратного времени. Именно этот код используется всеми космодромами при запуске ракет в космос:\npublic class TickTackStart { public static void main(String[] args) { for (int i = 10; i \u0026gt; 0; i--) System.out.println(\u0026#34;i= \u0026#34; + i); } } Начало может быть любым. Другой переменной int i = b или любым (обычно int) числом. Например, int i = 7.\nУсловие задаёт рабочий интервал между началом и концом программы.\nШаг может быть любым. Минус два, плюс два, минус 100 или плюс 5000. Шаг мы задаём сами. В шаге мы можем складывать, вычитать, умножать и даже делить: i = 2*i.\nfor (int i = 0; i \u0026lt; 20; i = 2*i){ System.out.println(i); } И это уже домашнее задание #   Определите на глаз, что будет выдано на консоли после запуска последнего куска кода? Даны целые числа A и B, где B \u0026gt; 0. Вывести B раз число A. Вывести в порядке возрастания все числа между А и B, где а = 5, а B = 17. Сколько раз будет выведено сообщение на экран? for (int i = 3; i \u0026lt; 10; i ++){ System.out.println(i); }  Распечатайте квадраты чисел от 1 до n, используя из арифметических операций лишь сложение. \u0026ldquo;Нарисуйте\u0026rdquo; (выведите на консоль) треугольник из звёздочек, используя только одну звёздочку и то, что только что изучили: * ** *** **** ***** ****** ******* ******** ********* **********   Дополнительные материалы #   https://docs.oracle.com/javase/tutorial/java/nutsandbolts/for.html  "});index.add({'id':10,'href':'/school/java/basic-course/037-java-assert/','title':"037 Java Assert",'content':"public class Test { public static void main(String[] args) { System.out.println(sum(1922222225, 1922222225)); } // Calculates the sum of a (int) + b (int) and returns the result (int). public static int sum(int a, int b) { assert (Integer.MAX_VALUE - a \u0026gt;= b) : \u0026quot;Value of \u0026quot; + a + \u0026quot; + \u0026quot; + b + \u0026quot; is too large to add.\u0026quot;; final int result = a + b; assert (result - a == b) : \u0026quot;Sum of \u0026quot; + a + \u0026quot; + \u0026quot; + b + \u0026quot; returned wrong sum \u0026quot; + result; return result; } } https://askdev.ru/q/chto-delaet-klyuchevoe-slovo-java-assert-i-kogda-ego-sleduet-ispolzovat-1901/\nhttps://stackoverflow.com/questions/18168257/where-to-add-compiler-options-like-ea-in-intellij-idea#:~:text=Add%20it%20as%20a%20VM%20option%20for%20your%20runtime%20configuration.\u0026amp;text=You%20can%20also%20make%20IntelliJ,Defaults%20%3E%20Application%20%3E%20VM%20options.\n"});index.add({'id':11,'href':'/school/frontend/fe-exercises/01-exercises-html/','title':"01 - html основы",'content':"Задача № 1 #  Exegi monumentum #  Условие: создайте html-файл (кодировка utf-8) с заголовком \u0026ldquo;Задача 1\u0026rdquo;, результат которого показан на рисунке.\n  Задача 1   Используйте подходящий тег заголовков (\u0026lt;h1\u0026gt; - \u0026lt;h6\u0026gt;), теги \u0026lt;br\u0026gt;, \u0026lt;p\u0026gt;, \u0026lt;i\u0026gt;, \u0026lt;em\u0026gt;, \u0026lt;strong\u0026gt;, \u0026lt;b\u0026gt; (необязательно все перечисленные). Выясните различие тегов \u0026lt;b\u0026gt; и \u0026lt;strong\u0026gt;, тегов \u0026lt;i\u0026gt; и \u0026lt;em\u0026gt;. В html-код добавьте комментарии: дату решения данной задачи и ФИО.\nAssets #  Я памятник себе воздвиг нерукотворный,\nК нему не зарастет народная тропа,\nВознесся выше он главою непокорной\nАлександрийского столпа.\nНет, весь я не умру — душа в заветной лире\nМой прах переживет и тленья убежит —\nИ славен буду я, доколь в подлунном мире\nЖив будет хоть один пиит.\nСлух обо мне пройдет по всей Руси великой,\nИ назовет меня всяк сущий в ней язык,\nИ гордый внук славян, и финн, и ныне дикой\nТунгус, и друг степей калмык.\nИ долго буду тем любезен я народу,\nЧто чувства добрые я лирой пробуждал,\nЧто в мой жестокий век восславил я Свободу\nИ милость к падшим призывал.\nВеленью божию, о муза, будь послушна,\nОбиды не страшась, не требуя венца,\nХвалу и клевету приемли равнодушно\nИ не оспаривай глупца.\n"});index.add({'id':12,'href':'/school/java/exercises/01-exercises-java/','title':"01 - логика",'content':"Задачи Java Boolean, введение — 01 #  Большие проекты развивают кругозор. Маленькие задачи тренируют мастерство. Множественное повторение одного действия позволяет выполнять его на автоматизме не задумываясь. Решение задач помогает закрепить пройденный материал и поддерживать себя в форме.\nЗадачи на усвоение булевых значений в Java. Достаточно знать тип данных boolean, желательно(рекомендуется) знать условный оператор if-else.\n Родители Васи Сидорова купили умный сейф и запрограммировали его на выдачу денег по отпечатку пальцев одного из родителей. smartDepositBox(true, false) -\u0026gt; true smartDepositBox(false, true) -\u0026gt; true smartDepositBox(false, false) -\u0026gt; false  После покупки сейфа в семье начался разлад по поводу выделению сыну денег и родители решили сейф перепрограммировать, таким образом, что бы он выдавал деньги только при обоюдном согласии родителей. smartDepositBoxVersionTwo(true, false) -\u0026gt; false smartDepositBoxVersionTwo(false, true) -\u0026gt; false smartDepositBoxVersionTwo(false, false) -\u0026gt; false smartDepositBoxVersionTwo(true, true) -\u0026gt; true  К родителям Васи Сидорова приехала Бабушка и сказала, что родители не умеют воспитывать сына и она сама знает, когда давать ребёнку деньги. Напишите программу выдачи денег Васе, если бабушка выдаёт деньги независимо от решения родителей. verySmartDepositBoxVersionThree(mamaPermission, papaPermission, omaPermission)  Родители Василия добились успехов в программировании и смогли передать свои знания сыну. Василий вырос и запрограммировал систему аварийного уничтожения первых космических кораблей земли, улетевших в Альфа-Центавру. Система уничтожения реагирует на ввод команд двух старших офицеров корабля. bigBadaBoom(true, true) -\u0026gt; true bigBadaBoom(false, false) -\u0026gt; false bigBadaBoom(true, false) -\u0026gt; false  На даче у родителей Васи Сидорова решили поставить звонок, который должен звонить при нажатии на кнопку звонка у калитки или у двери дома. Если соседские дети начинают играться и нажимать на кнопки звонка одновременно и на калитке и на доме, звонок не должен реагировать. Напишите программу управления звонком. doorbell(true, true) -\u0026gt; false doorbell(false, false) -\u0026gt; false doorbell(true, false) -\u0026gt; true  Программирование всё больше захватывало семью Василия и они решили сделать полностью умный дом. Для начала они решили сделать входную дверь учитывая новые стандарты. Дверь больше нельзя открыть обычным ключом, пока в доме есть интернет и она подключена к электросети. Напишите тесты для программы smartDoorCheckKey. Заказчик(бабушка Василия), хочет, что бы мы проконтролировали работу сторонней фирмы. Сторонняя фирма не справилась с написанием программы. Напишите самостоятельно метод, который возвращает false, если дверь открыть ключом нельзя. Родители сделали в итоге самостоятельно всё программирование вокруг двери не дожидаясь нас. Попробуйте угадать как же работает метод, которрый позволяет Василию открыть дверь телефоном, отпечатком пальца или введённым с клавиатуры паролем. verySmartDoor(false, true, false) -\u0026gt; true verySmartDoor(false, false, true) -\u0026gt; true verySmartDoor(true, false, false) -\u0026gt; true verySmartDoor(false, false, false) -\u0026gt; false  В девятом классе Вася ездил со своим и параллельным классом в Париж. Известно, что на двоих учителей нельзя брать в поездку больше 25 детей. Напишите проверочный метод paris(11, 15) -\u0026gt; false paris(11, 5) -\u0026gt; true   "});index.add({'id':13,'href':'/school/frontend/fe-exercises/02-exercises-html/','title':"02 - html основы",'content':"Задача № 2 #  Не позволяй душе лениться #  Условие: создайте html-файл (кодировка utf-8) с заголовком \u0026ldquo;Задача 2\u0026rdquo;, результат которого показан на рисунке. Используйте подходящий тег заголовков (h1-h6), теги \u0026lt;br\u0026gt;, \u0026lt;p\u0026gt;, \u0026lt;i\u0026gt;, \u0026lt;em\u0026gt;, \u0026lt;strong\u0026gt;, \u0026lt;b\u0026gt;, \u0026lt;hr\u0026gt;, \u0026lt;small\u0026gt; (необязательно все перечисленные). Обратите внимание, что шрифт фамилии автора меньшего размера. Заметим, что тег \u0026lt;hr\u0026gt; в разных браузерах может отображаться по-разному. В html-код добавьте условие данной задачи в виде комментариев.\n  Задача 2   Assets #  Не позволяй душе лениться!\nЧтоб в ступе воду не толочь,\nДуша обязана трудиться\nИ день и ночь, и день и ночь!\nГони ее от дома к дому,\nТащи с этапа на этап,\nПо пустырю, по бурелому,\nЧерез сугроб, через ухаб!\nНе разрешай ей спать в постели\nПри свете утренней звезды,\nДержи лентяйку в черном теле\nИ не спускай с нее узды!\nВ.Заболоцкий\n"});index.add({'id':14,'href':'/school/java/exercises/02-exercises-java/','title':"02 - Switch",'content':"Закрепление материала, введение — 02 #   методы и классы в Java простые типы данных Switch  Задачи #  1. Диапазон #  Даны два целых числа. Верните true, если одно из этих чисел находится в диапазоне от 10 до 20 включительно.\n2. Степень числа #  Возведите число n во вторую степень\ndigitPow(5) -\u0026gt; 25 digitPow(10) -\u0026gt; 100 digitPow(4) -\u0026gt; 16 3. getStringMonth #  Написать метод String getStringMonth(int month),который принимает номер месяца, а возвращает название. В main распечатать результат работы метода.\ngetStringMonth(12) -\u0026gt; Декабрь getStringMonth(1) -\u0026gt; Январь getStringMonth(2) -\u0026gt; Февраль 4. nearHundred #  Учитывая int n, возвращайте true, если он находится в пределах 10 от 100 или 200. Примечание: Math.abs(num) вычисляет абсолютное значение числа.\n- nearHundred(93) → true - nearHundred(90) → true - nearHundred(89) → false 5. Процент вклада #  Реализовать метод double getPercent(double amount, double interest) который считает указанный процент (interest) от указанного числа (amount). Например getPercent (1000.0, 10.0), должно вернуть 100. В main распечатать результат работы метода.\n6. Стоимость электроэнергии #  Стоимость электроэнергии рассчитывается исходя из стоимости одного киловатт-часа в 20 центов.\nБазовая плата - 30€. В базовую плату входят 100 киловатт-часов. Напишите метод расчёта стоимости пользования электроэнергией.\n7. Спортивные мячи почтой #  На складе крупной базы летом продают очень много спортивных мячей. Разного размера. Напиши метод, который в зависимости от диаметра мяча подбирает более подходящую упаковку с запасом в минимум 5% от размера мяча. Напишите программу, принимающую диаметр мяча и возвращающую тип коробки. Почтовые коробки на базе бывают размерами:\n Тип А - 200x200x200 мм Тип Б -150x150x150 мм Тип В -250x250x250 мм Тип Г -350x400x500 мм Тип Д -400x400x400 мм  8. Конвертер валют #   Реализовать метод, который принимает название валюты (например, “EUR”,”RUR”,”USD”,”GPB”) и выдает курс к доллару. Естественно, “USD” возвращает 1.0 . Используя метод из предыдущего пункта написать метод, который принимает пару валют (“GPB”,”EUR”) и возвращает курс обмена. Используя метод из предыдущего пункта реализовать метод который получает пару валют и сумму в первой валюте, возвращает сумму во второй валюте.  9. Окна и двери #  В старых советских хрущёвках города № решили поменять деревянные окна и двери на пластиковые. Выяснилось, что все двери в хрущёвках одинакового размера 2м*90см, а окна разные, но в каждой квартире могут быть только одинаковые окна.\nСтоимость переделки окон рассчитывается из стоимости стекла - 100€ за квадратный метр и стоимости косяка - погонный метр 100€.\nСтоимость дверей рассчитывается исходя из стоимости косяка (как и у окна) и стоимости самой двери 120€ за квадратный метр.\nНапишите программу, которая поможет стройтресту №12 правильно выставлять счета.\n10. Школа и геометрия #  Школа приняла на работу молодую учительницу геометрии. И первым делом она решила привести кабинет точных наук в порядок. В подвале школы были найдены:\n точная копия спутника земли ПС-1. Диаметр сферы 58см. жестяной куб со стороной 40см. правильная четырёхугольная пирамида \u0026ldquo;Хеопса\u0026rdquo; со стороной основания 20см и боковыми рёбрами 30см и чёрный ящик с размерами 80см * 30см * 20см.  Всё было в достаточно запущенном состоянии и новая учительница решила всё покрасить в красный цвет.\nСколько денег на покраску нужно потратить если на один квадратный метр надо 560мл краски, а балончик с аэрозольной краской 400мл стоит 17€?\n11. Стоимость дома из бруса #  Посчитайте стоимость дома из бруса, если:\n дом размерами 11*12 метров, и высотой 3 метра, размеры используемого бруса 20*20 см, цена елового бруса(200х200х6000 мм) за кубометр 250$ с доставкой. Дом делается примерно 2 недели тремя работниками и одним краном. Кран стоит 100€ в день. Бригадир у работников стоит 35$ в час. Плотники 25$ в час. Стоимость лака, которым надо потом покрасить внешние стены дома стоит 20 € за литр и одного литра хватает на 3 квадратных метра.  12. Расчёт плиток #  Мастеру плиточнику Сергею Ивановичу Золотыеруки задают часто один и тот же вопрос. Сколько будет стоить положить плитку на определённом участке.\n Нам известно, что в час он кладёт примерно один квадратный метр плитки. Его час стоит 27€ без НДС. Стандартная плитка 30 на 20 сантиметров.  Сергей Иванович обратился к нам за помощью и вам надо написать для него программу.\nКоторая будет принимать размеры стены/пола, стоимость плитки и выдавать:\n Количество требуемых плиток, как целых, так и тех которые надо будет резать. Учтите, что плитку можно класть как вдоль, так и поперёк и только на месте мастер узнает, как именно её надо класть. Стоимость материала Стоимость рабочего времени Итоговую ориентировочную стоимость  "});index.add({'id':15,'href':'/school/java/exercises/03-exercises-java/','title':"03 - If, else",'content':"Задачи. If, if else введение - 03 #  Требуется знание простых типов данных, String, if-else\n Даны два целых числа, верните большее из двух. Если числа равны, то верните ноль. moreOrLess(5, 6) -\u0026gt; 6 moreOrLess(5, 5) -\u0026gt; 0 moreOrLess(0, 100) -\u0026gt; 100  Даны три целых числа, верните их сумму. Если первое и третье числа равны друг другу, то верните второе, если сумма равна нулю, то верните -1. mySum(5, 6, 5) -\u0026gt; 6 mySum(5, 6, 7) -\u0026gt; 18 mySum(0, 0, 0) -\u0026gt; 0 mySum(0, -5, 5) -\u0026gt; -1  Дан строковый литерал. Верните его длину, если она больше 10. Если меньше десяти, то верните удвоенную длину строкового литерала, если длина равна нулю, то верните 100. findLength(\u0026quot;London is the capital\u0026quot;) -\u0026gt; 21 findLength(\u0026quot;\u0026quot;) -\u0026gt; 100 findLength(\u0026quot;Школа\u0026quot;) -\u0026gt; 10  Напишите программу действий для сотрудника дорожной полиции, который остановил машину:  при езде до 50 км/час нарушений нет; за езду от 50 км/час до 65 км/час — устное порицание и лекция на 5 минут; за превышение скорости от 16 км/час — 40 евро штрафа; за езду от 100 км/час до 130 км/час — штраф 500 евро; и за езду свыше 130 км/час — штраф в 1000 евро, конфискация прав на 3 года и конфискация транспортного средства.   Напишите программу, которая объяснит наступление определённых событий, в зависимости от выбора \u0026ldquo;витязя\u0026rdquo;. Напишите программу для машины на светофоре. Что делать, если горит красный, жёлтый или зелёный свет. Напишите программу выдачи денег работнику с учётом надбавки за стаж, если базовая зарплата 500$. За 3 года работы надбавка 10%, за 5 лет работы надбавка 50%, за 10 лет работы надбавка 100%, за 15 лет работы надбавка 150%. Метод вывода даты на экран монитора принимает 3 целочисленных значения(день, месяц, год) и разделитель (например \u0026ldquo;-\u0026quot;). Проверить значения данных на адекватность, и если надо дописать нули.\n- 5.6.2020 должно быть выведено на экран как \u0026ldquo;05-06-2020\u0026rdquo; - 50.40.2020 не должно быть выведено вообще Параметр weekday true, если это день недели, а параметр vacation true, если мы в отпуске. Мы спим, если это не рабочий день или мы в отпуске. Верните true, если мы спим.  sleepIn(false, false) → true sleepIn(true, false) → false sleepIn(false, true) → true   Получив два значения int, верните их сумму. Если два значения не одинаковы, верните двойную сумму.  sumDouble(1, 2) → 3 sumDouble(3, 2) → 5 sumDouble(2, 2) → 8   Необходимо написать метод, который бы возвращал из 2 чисел меньшее число. Например, из двух чисел 7 и 3 метод должен вывести в консоль 3.  "});index.add({'id':16,'href':'/school/java/exercises/04-exercises-java/','title':"04 - повторение",'content':"Задачи для повторения и закрепления — 04 #   Давайте попробуем написать методы для вычисления площади и периметра фигур: квадрата, прямоугольника, треугольника, круга. И один раз напишем их исполняющими, а один раз возвратными. В обоих случаях методы должны принимать необходимые данные для вычисления: как радиус, длину сторон или прочее. Даны натуральные числа от a = 35 до b = 87. Вывести на консоль те из них, которые при делении на 7 дают остаток 1, 2 или 5. а и b должны приниматься методом. Напишите метод(ы)- программу с описанием человеческих действий через комментирование кода или через систему вывода сообщений на экран, из которой понятно как получить утреннюю чашку кофе, а в пятницу вечером бутылку холодного пива. Дано два числа (a и b). Написать метод, который вернет сумму всех чисел между (a и b). Если a равно b, метод должен вернут a+b\nПример: sum(2,4) -\u0026gt; 9 Реализовать метод печатающий таблицу умножения для заданного числа Пример: multiplicationTable(3)-\u0026gt; 3x1=3 3x2=6 …. 3x10=30  Реализовать метод, печатающий все високосные годы в интервале от year1 до year2\nПример: printLeapYears(2000,2009) -\u0026gt; 2000 2004 2008  Реализовать метод, считающий все високосные годы в интервале от year1 до year2\nПример: countLeapYears(2000,2009) -\u0026gt; 3 Напишите метод, который выводит на экран квадрат с заданной стороной символами “*”\nПример: printSquare(4) -\u0026gt; **** **** **** ****  Реализовать метод, который принимает целое положительное число. Метод должен выводить на экран все положительные числа, на которые заданное число делится без остатка и отображает количество найденных делителей.\nПример: printDivisors(32) -\u0026gt; 32 16 8 4 2 1 Total divisors: 6  Дано два целых положительных числа от 1 до 99. Реализовать метод, который для каждого числа от a до b печатает строку вида “23 рубля”\nПример: printSumInRub(1,5) -\u0026gt; 1 рубль 2 рубля 3 рубля 4 рубля 5 рублей   "});index.add({'id':17,'href':'/school/java/basic-course/005-java-boolean/','title':"05 -",'content':"Тип данных boolean и логические операторы — введение в Java 005 #    Правда или ложь   Boolean #  Boolean в Java — это логический тип данных. Переменная типа boolean может принимать всего два значения — это правда или ложь — true \u0026amp; false. Эти два значения обозначаются в других языках и часто выдаются на экран как 1 и 0, но всё же не равны этим значениям: например, выражение boolean b = 0; приведёт к ошибке при компиляции программы. Но мы можем сравнить переменные или выполнить логическую операцию с типом данных boolean:\nint a = 1, b = 2; boolean bool = a \u0026lt;= b; Говоря о булевых или логических типах данных, нам придётся освежить свои воспоминания о булевой алгебре и возможных логических операциях.\nТаблица истинности #     a b a \u0026amp; b a I b a ^ b ! a     false false false false false true   false true false true true true   true false false true true false   true true true true false false    Давайте представим себе пример из жизни: мы ищем на сайте все статьи, которые мы опубликовали и комментировали. Должны быть два совпадения — это вариант a \u0026amp; b. Или мы ищем все статьи, в которых есть упоминание слов \u0026ldquo;алгебра\u0026rdquo; или \u0026ldquo;математика\u0026rdquo; — это a | b. А отыскать все статьи, которые написаны не нами, можно, применив логический оператор !a. Стать исключительно космонавтом или медиком — это a ^ b\nЭто так называемые булевы или логические операции. В интернете много материала по ключевым словам: таблица истинности, булева алгебра, теория множеств, конъюнкция, дизъюнкция.\nС помощью таблицы с результатами логических операций можно перепроверить работу Java:\npublic class NewBoolean { public static void main(String[] args) { boolean a, b, c; a = true; b = false; c = a \u0026amp; b; System.out.println(c); // returns false because only one of the two required values​is true  int d = 1, f = 2; boolean bool = d \u0026lt;= f; int i = 10; int j = 9; System.out.println(i \u0026gt; j); // returns true, because 10 is higher than 9  System.out.println(10 == 15); // returns false, because 10 is not equal to 15  int x = 10; System.out.println(x == 10); // returns true, because the value of x is equal to 10  } } Надо понимать, что значение вашего чекбокса (галочки) на сайте Facebook при регистрации — \u0026ldquo;с правилами ознакомлен и согласен\u0026rdquo; — и есть значение булевой переменной в программе.\nЛогические операторы, которые поддерживаются Java #     Логический операторы Значение     == Проверка на соответствие (допустим, что a равен b)   != Не равно (если a не равно b, то)   ! Отрицание, логическое не   \u0026amp; Логическое И, and   | Логическое или, or   ^ Исключительное или, XOR   \u0026amp;\u0026amp; Укороченный \u0026amp;   || Укороченный или    Амперсанд — это название знака \u0026amp;.\nКарет (англ. caret) — это название знака ^.\nПайп (pipeline), Вертикальная черта — это название знака |.\nМы ещё раз рассмотрим данные операторы позже. Пока мы должны понимать, что с арифметическими операторами всё немного сложнее, чем хотелось бы.\nБулева алгебра #  Булева алгебра, ударение на первый слог. БУлева.\nПринципиально основы булевой алгебры не должны были давать в школе. Программисты учат её в институте.\nДавайте я попробую на пальцах рассказать основы и то, что нам понадобится на минимальном уровне.\nДизъюнкция #   Когда мама ИЛИ папа дают мне деньги на карманные расходы, то я бегу и покупаю себе мороженное.\n Знакомая ситуация, деньги можно получить в трёх случах из четырёх. В одном случае же деньги может дать и мама, и папа, тогда и друга можно угостить мороженным.\nЭто дизъюнкция.\nДизъюнкция - логическое сложение, логическое ИЛИ, включающее или, просто \u0026ldquo;или\u0026rdquo;(англ. OR; нем. ODER) В Java операторы \u0026quot;|\u0026quot; и \u0026quot;||\u0026quot;\nboolean a = false, b = true, c; c = a | b; Пример в технике; дублирование выключателя или кнопки, дверной звонок и звонок у калитки вызывают одну и туже реакцию - включается мелодия звонка.\nВ учебниках можно встретить обозначение \u0026ldquo;больше либо равно единице\u0026rdquo; - =\u0026gt;1.\nКонъюнкция #  Конъюнкция - логическое \u0026ldquo;И\u0026rdquo;, логическое умножение, просто \u0026ldquo;И\u0026rdquo;, \u0026ldquo;AND\u0026rdquo;, \u0026quot;\u0026amp;\u0026quot;.\nВ Java оператор \u0026quot;\u0026amp;\u0026quot; и \u0026quot;\u0026amp;\u0026amp;\u0026quot;.\nboolean a = false, b = true, c; c = a \u0026amp; b;  Если светит солнце \u0026ldquo;И\u0026rdquo; у меня выходной, то я иду купаться на озеро.\n Пример из жизни. Ядерный чемоданчик могут активировать только два офицера одновременно. По отдельности чемодан остаётся неактивным.\nАнтиваленц #  \u0026ldquo;XOR\u0026rdquo;, эксклюзивное или, \u0026ldquo;EOR\u0026rdquo;, \u0026ldquo;EXOR\u0026rdquo;. В Java оператор \u0026quot;^\u0026quot;.\nboolean a = false, b = true, c; c = a ^ b;  Только на горных лыжах в Австрии или на лошадях у бабушки в деревне я забываю про свою работу.\n  Или ты садишься за математику или я расскажу всё отцу.\n ИЛИ - ИЛИ. Исключительное или.\nЛампочка в больнице может работать от городского электричества или от дизельного генератора в подвале. Но не от двух источников одновременно.\nВ учебниках можно встретить обозначение \u0026ldquo;равно единице\u0026rdquo; - =1.\nОтрицание #  Negation. NOT. В Java оператор \u0026quot;!\u0026quot;.\nboolean a = false, b; b = !a; Давайте представим огромный станок по продольной распилке леса. В цеху есть две кнопки. Зелёная и красная. При включении зелёной пила должна работать. При нажатии на красную пила должна остановится.\nДополнительные материалы #   Булева алгебра — самое важное Булева алгебра Теория множеств Очень неплохая статья simulator — симулятор логических выражений в электротехнике. Очень помог мне в своё время вспомнить булеву алгебру.  Домашнее задание #   Что выдаст программа, если запросить значения a, b, c, d, e, f? Посчитайте сначала в уме и проговорите вслух, что делает каждая строчка. boolean a = (7+8)*5 \u0026gt; 7+8*5; boolean b = (7+8)*4 != 7+4*5; boolean c = 3+4 \u0026gt; 9+1 \u0026amp; 16-5 \u0026gt; 3*4; boolean d = 16/2 \u0026lt; 6+2 | 4+5 \u0026lt;= 4*5; boolean e = !(3*4 \u0026lt; 7+8);  Напишите программу и проверьте свои результаты. Сравните строчку вывода со своей: System.out.println(a + \u0026quot;\\n\u0026quot; + b + \u0026quot;\\n\u0026quot; + c + \u0026quot;\\n\u0026quot; + d + \u0026quot;\\n\u0026quot; + e);  Повторение String: Найдите метод из официальной библиотеки и покажите его работу. По возможности используйте printf. Задача. Не для решения в Java, а для попытки понимания логических операций в уме.\nПетя, Вася и Маша остались дома одни. Кто-то из них ел варенье. На вопрос мамы, кто это сделал, они сказали:  Петя: \u0026ldquo;Я не ел. Маша тоже не ела.\u0026rdquo; Вася: \u0026ldquo;Маша действительно не ела. Это сделал Петя\u0026rdquo; Маша: \u0026ldquo;Вася врет. Это он съел.\u0026rdquo;    Выясните, кто ел варенье, если известно, что двое из них оба раза сказали правду, а третий один раз соврал, а один раз сказал правду.\nОтвет к задаче для собственной сверки\n"});index.add({'id':18,'href':'/school/java/exercises/05-exercises-java/','title':"05 - цикл for",'content':"Задачи. Цикл for, введение — 05 #  Задачи на закрепление основ программирования. Требуется знание простых типов данных, String, switch, if-else, for\nЗакрепление изученного #  1. Счастливый пельмень #  Существует такая традиция: при приготовлении пельменей в один из них кладут монетку на счастье. Считается, что тому, кому попадется пельмень с монеткой, улыбнется удача.\n Представим, что у нас есть кастрюля, в которой лежит 10 пельменей. Один из них счастливый — а именно пятый пельмень. Давайте напишем программу, которая ищет счастливый пельмень. Программа перебирает пельмени в кастрюле по одному, и когда доходит до пятого пельменя — напишет \u0026ldquo;Вот счастливый пельмень!\u0026rdquo; и выходит из цикла.  2. На 3 без остатка #  Вывести на экран все числа от 1 до 100, которые делятся на 3 без остатка.\n3. Последовательность (100) #  Необходимо, чтоб программа выводила на экран вот такую последовательность:\nmyLine(100) -\u0026gt; 7 14 21 28 35 42 49 56 63 70 77 84 91 98 4. Последовательность (1000) #  Необходимо вывести на консоль такую последовательность чисел:\nmySecondLine(1000) -\u0026gt; 1 2 4 8 16 32 64 128 256 512 5. 4 Буквы в строке #  Вывести каждую букву американского алфавита от A-Z по 4 буквы в строке.\n6. Ряд Фибоначчи #  Выведите на экран первые 11 членов последовательности Фибоначчи.\n первый и второй члены последовательности равны единицам а каждый следующий — сумме двух предыдущих То есть числа Фибоначчи - это 1 1 2 3 5 8 13 21 34 55 89 и т.д.  7. Числовой палиндром #  Дано целое трехзначное число. Написать метод, который возвращает число, записанное в обратном порядке, например:\n123 -\u0026gt; 321 768 -\u0026gt; 867 8. Сумма разрядов #  Дано целое трехзначное число. Написать метод, который возвращает сумму разрядов этого числа, например:\n123 -\u0026gt; 6 (1+2+3) 768 -\u0026gt; 21 (7+6+8) 9. Делится на 11 #  Найдите в заданном диапазоне хотя бы одно натуральное число, которое делится на 11, а при делении на 2, 3, 4, \u0026hellip;, 10 дает в остатке 1.\nfindDigits(99999, 11) -\u0026gt; 25201, 52921, 80641 10. Степень числа #  Возведите число n во вторую степень. Не используя арифмитический оператор умножения.\ndigitPowTwo(5) -\u0026gt; 25 digitPowTwo(10) -\u0026gt; 100 digitPowTwo(4) -\u0026gt; 16 11. Чёт/нечет разрядов #  Дано целое трехзначное число. Написать метод, который определит чётность/ нечётность разрядов этого числа, например: 123 -\u0026gt; 1 – нечет. 2- чёт. 3-нечет. 768 -\u0026gt; 1 – нечет. 2- чёт. 3-чет.\n12. Повторяка номер n #  реализовать метод, который выводит на экран заданную строку N раз. printLineNtimes(“hello”,3) -\u0026gt; hello hello hello \n13. Обратный отсчёт #  Реализовать метод “ Обратный отсчёт ” который выводит на экран цифры от n до 1, затем выводит строку „start“. countdown(5) -\u0026gt; 5 4 3 2 1 start\n14. Обратный отсчёт - start #  реализовать метод \u0026ldquo;Обратный отсчёт\u0026rdquo; который выводит на экран цифры от 5 до 1 текстом, затем выводит строку \u0026ldquo;start\u0026rdquo;. countdownStart() -\u0026gt; five four tree two one start\n15. Буква \u0026lsquo;я\u0026rsquo; #  Буква \u0026ldquo;Я\u0026rdquo; воистину великая буква. И все слова в которых есть это буква являются великими. Напишите метод, который находит великие слова.\n16. Палиндром #  Написать свой метод проверки строки на палиндром.\nУчесть, что палиндром может быть предложением с пробелами.\nПри решении задачи используйте цикл.\nНельзя использовать методы replace(), reverse() и конструкции, которые вы не учили.\ncheckPalindrom( \u0026quot;А роза упала на лапу Азора\u0026quot;) -\u0026gt; true checkPalindrom( \u0026quot;поп\u0026quot;) -\u0026gt; true checkPalindrom( \u0026quot;школа\u0026quot;) -\u0026gt; false 17. Шифрование Цезаря #  Разработайте шифровальную машину для нового клиента фирмы - Гая Юлия Цезаря.\nКлиент придумал шифровальный алгоритм и хочет, что бы мы реализовали его в методе. Пример выполнения метода:\nenigmaCaesar(\u0026quot;Съешь же ещё этих мягких французских булок, да выпей чаю.\u0026quot;) -\u0026gt; \u0026quot;Фэзыя йз зьи ахлш пвёнлш чугрщцкфнлш дцосн, жг еютзм ъгб.\u0026quot; О самом методе шифрования(шифр подстановки) написана подробная документация, которая доступна по ссылке.\n18. Дешифратор Цезаря #  Написать программу, которая производит дешифровку сообщений, зашифрованных предыдущим методом enigmaCaesar\n19. Генератор паролей #  Давайте напишем генератор паролей. Методу передаётся длина пароля. И метод генерирует пароль используя латиницу, цифры и некоторые спецсимволы(на ваш выбор). Подсказка - использовать только те знания, которые были уже изучены. Существует как минимум два(на самом деле 222) разных подхода к решению этой проблемы. Не бойтесь пробовать.\n"});index.add({'id':19,'href':'/school/java/exercises/06-exercises-java/','title':"06 - Nested Loops",'content':"Вложенные циклы (Nested Loops) — 06 #  1. Прямоугольник #  При вызове метода rectangle(5, 7); на экране появился прямоугольник. Что написано в методе rectangle?\n******* ******* ******* ******* ******* 2. Трое неизвестных #  нужно написать алгоритм вывода на экран всех возможных комбинаций 3-х натуральных чисел до 36 с определенными условиями:\n необходимо использовать вложенные циклы x \u0026lt;= y \u0026lt;= z xyz = 36  например:\n x=1, y=1, z=36 x=1; y=3; z=12  3. Шахматная доска #  Выведите на экран в шахматном порядке символы.\n*-*-*-*- -*-*-*-* *-*-*-*- -*-*-*-* *-*-*-*- -*-*-*-* *-*-*-*- -*-*-*-* 4. Таблица умножения #  Выведите на экран таблицу умножения, как показано ниже.\n1 2 3 4 5 6 7 8 9 10 2 4 6 8 10 12 14 16 18 20 3 6 9 12 15 18 21 24 27 30 4 8 12 16 20 24 28 32 36 40 5 10 15 20 25 30 35 40 45 50 6 12 18 24 30 36 42 48 54 60 7 14 21 28 35 42 49 56 63 70 8 16 24 32 40 48 56 64 72 80 9 18 27 36 45 54 63 72 81 90 10 20 30 40 50 60 70 80 90100 5. Геометрические фигуры #   \u0026ldquo;Нарисуйте/выведите в консоль\u0026rdquo; треугольник из звёздочек используя только одну звёздочку и то что только что изучили:  * ** *** **** ***** ****** ******* ******** ********* **********  Предыдущая задача очень важна. И важно, что бы вы её могли решить самостоятельно. Если решили, то попробуйте усложнить требуемое и нарисуйте равнобедренный треугольник. А после все фигуры из рисунка снизу.    Треугольники   6. Треугольники из чисел #  6.1 Первый #  1 222 33333 4444444 555555555 66666666666 6.2 Второй #  1 212 32123 4321234 543212345 65432123456 6.3 Floyd`s triangle #  Треугольник Флойда является прямоугольным треугольником из натуральных чисел. Он назван в честь Роберта Флойда . Строки треугольника заполняются последовательными номерами, начиная с 1 в верхнем левом углу:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 7. Снежинка #  Нарисуйте снежинку makeSnowflake(10)\nX X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X "});index.add({'id':20,'href':'/school/java/exercises/07-exercises-java/','title':"07 - Modulo",'content':"Двоичные системы счисления, Modulo — 07 #   В одном KByte(килобайт) - 1000 Byte(10^3). В одном KiB(кикибайт) - 1024 Byte(2^10).  Напишите программу, которая например из 100.000 байтов вычисляет сколько это целых KByte(килобайт) и оставшихся Byte. Напишите программу подсчёта (обмана) разницы маркетинговых гигабайт с гигабайтами. Сколько \u0026ldquo;программистских\u0026rdquo; или двоичных мебибайт в десятичных гигабайтах.   Написать программу, которая нам переводит любое десятичное число в двоичное. Напишите программу для перевода из двоичных в десятичные. Написать программу перевода десятичных чисел в восьмеричную систему. Напишите программу перевода чисел из любой(X) системы в любую(Y) систему. Сделайте ограничение для систем выше 16. Программу перевода десятичных чисел в двоичные, где пользователь вводит значения через клавиатуру.  "});index.add({'id':21,'href':'/school/java/exercises/09-exercises-java/','title':"09 - многомерные",'content':"Многомерные массивы, введение — 09 #   Перепишите метод monthCalendar используя метод цикл фор ич. Создать таблицу умножения(Пифагора) для младших классов.   Таблица Пифагора    Создать поле для игры в сапёров с типом данных на выбор. Например boolean со значениями false. Размером 100 на 100. И раставить 20 случайных бомб (true). Распечатайте координаты бомб. Создайте String массив случайного размера в диапазоне (10-100). Заполните его случайными строками(паролями?, логинами?, значениями?) длиной от 10 до 20. Найдите среднюю длину элемента. Отсортируйте элементы в массиве по длине.  "});index.add({'id':22,'href':'/school/java/exercises/10-exercises-java/','title':"10 - WarmUp",'content':"Задачи на закрепления всех основных конструкций — 10 #   The parameter weekday is true if it is a weekday, and the parameter vacation is true if we are on vacation. We sleep in if it is not a weekday or we\u0026rsquo;re on vacation. Return true if we sleep in. sleepIn(false, false) → true sleepIn(true, false) → false sleepIn(false, true) → true  Given an int n, return the absolute difference between n and 21, except return double the absolute difference if n is over 21. diff21(19) → 2 diff21(10) → 11 diff21(21) → 0  Given an int n, return true if it is within 10 of 100 or 200. Note: Math.abs(num) computes the absolute value of a number. nearHundred(93) → true nearHundred(90) → true nearHundred(89) → false  Given a non-empty string and an int n, return a new string where the char at index n has been removed. The value of n will be a valid index of a char in the original string (i.e. n will be in the range 0..str.length()-1 inclusive). missingChar(\u0026quot;kitten\u0026quot;, 1) → \u0026quot;ktten\u0026quot; missingChar(\u0026quot;kitten\u0026quot;, 0) → \u0026quot;itten\u0026quot; missingChar(\u0026quot;kitten\u0026quot;, 4) → \u0026quot;kittn\u0026quot;  Given a string, take the last char and return a new string with the last char added at the front and back, so \u0026ldquo;cat\u0026rdquo; yields \u0026ldquo;tcatt\u0026rdquo;. The original string will be length 1 or more. backAround(\u0026quot;cat\u0026quot;) → \u0026quot;tcatt\u0026quot; backAround(\u0026quot;Hello\u0026quot;) → \u0026quot;oHelloo\u0026quot; backAround(\u0026quot;a\u0026quot;) → \u0026quot;aaa\u0026quot;  Given a string, return true if the string starts with \u0026ldquo;hi\u0026rdquo; and false otherwise. startHi(\u0026quot;hi there\u0026quot;) → true startHi(\u0026quot;hi\u0026quot;) → true startHi(\u0026quot;hello hi\u0026quot;) → false  We\u0026rsquo;ll say that a number is \u0026ldquo;teen\u0026rdquo; if it is in the range 13..19 inclusive. Given 3 int values, return true if 1 or more of them are teen. hasTeen(13, 20, 10) → true hasTeen(20, 19, 10) → true hasTeen(20, 10, 13) → true  Return true if the given string begins with \u0026ldquo;mix\u0026rdquo;, except the \u0026rsquo;m' can be anything, so \u0026ldquo;pix\u0026rdquo;, \u0026ldquo;9ix\u0026rdquo; .. all count. mixStart(\u0026quot;mix snacks\u0026quot;) → true mixStart(\u0026quot;pix snacks\u0026quot;) → true mixStart(\u0026quot;piz snacks\u0026quot;) → false  Given 2 int values, return whichever value is nearest to the value 10, or return 0 in the event of a tie. Note that Math.abs(n) returns the absolute value of a number. close10(8, 13) → 8 close10(13, 8) → 8 close10(13, 7) → 0  Return true if the given string contains between 1 and 3 \u0026lsquo;e\u0026rsquo; chars. stringE(\u0026quot;Hello\u0026quot;) → true stringE(\u0026quot;Heelle\u0026quot;) → true stringE(\u0026quot;Heelele\u0026quot;) → false  Given a non-empty string and an int N, return the string made starting with char 0, and then every Nth char of the string. So if N is 3, use char 0, 3, 6, \u0026hellip; and so on. N is 1 or more. everyNth(\u0026quot;Miracle\u0026quot;, 2) → \u0026quot;Mrce\u0026quot; everyNth(\u0026quot;abcdefg\u0026quot;, 2) → \u0026quot;aceg\u0026quot; everyNth(\u0026quot;abcdefg\u0026quot;, 3) → \u0026quot;adg\u0026quot;  We have two monkeys, a and b, and the parameters aSmile and bSmile indicate if each is smiling. We are in trouble if they are both smiling or if neither of them is smiling. Return true if we are in trouble. monkeyTrouble(true, true) → true monkeyTrouble(false, false) → true monkeyTrouble(true, false) → false  We have a loud talking parrot. The \u0026ldquo;hour\u0026rdquo; parameter is the current hour time in the range 0..23. We are in trouble if the parrot is talking and the hour is before 7 or after 20. Return true if we are in trouble. parrotTrouble(true, 6) → true parrotTrouble(true, 7) → false parrotTrouble(false, 6) → false  Given 2 int values, return true if one is negative and one is positive. Except if the parameter \u0026ldquo;negative\u0026rdquo; is true, then return true only if both are negative. posNeg(1, -1, false) → true posNeg(-1, 1, false) → true posNeg(-4, -5, true) → true  Given a string, return a new string where the first and last chars have been exchanged. frontBack(\u0026quot;code\u0026quot;) → \u0026quot;eodc\u0026quot; frontBack(\u0026quot;a\u0026quot;) → \u0026quot;a\u0026quot; frontBack(\u0026quot;ab\u0026quot;) → \u0026quot;ba\u0026quot;  Return true if the given non-negative number is a multiple of 3 or a multiple of 5. Use the % \u0026ldquo;mod\u0026rdquo; operator \u0026ndash; see Introduction to Mod or35(3) → true or35(10) → true or35(8) → false  Given two temperatures, return true if one is less than 0 and the other is greater than 100. icyHot(120, -1) → true icyHot(-1, 120) → true icyHot(2, 120) → false  We\u0026rsquo;ll say that a number is \u0026ldquo;teen\u0026rdquo; if it is in the range 13..19 inclusive. Given 2 int values, return true if one or the other is teen, but not both. loneTeen(13, 99) → true loneTeen(21, 19) → true loneTeen(13, 13) → false  Given a string, return a string made of the first 2 chars (if present), however include first char only if it is \u0026lsquo;o\u0026rsquo; and include the second only if it is \u0026lsquo;z\u0026rsquo;, so \u0026ldquo;ozymandias\u0026rdquo; yields \u0026ldquo;oz\u0026rdquo;. startOz(\u0026quot;ozymandias\u0026quot;) → \u0026quot;oz\u0026quot; startOz(\u0026quot;bzoo\u0026quot;) → \u0026quot;z\u0026quot; startOz(\u0026quot;oxx\u0026quot;) → \u0026quot;o\u0026quot;  Given 2 int values, return true if they are both in the range 30..40 inclusive, or they are both in the range 40..50 inclusive. in3050(30, 31) → true in3050(30, 41) → false in3050(40, 50) → true  Given two non-negative int values, return true if they have the same last digit, such as with 27 and 57. Note that the % \u0026ldquo;mod\u0026rdquo; operator computes remainders, so 17 % 10 is 7. lastDigit(7, 17) → true lastDigit(6, 17) → false lastDigit(3, 113) → true   Разминка номер два #   Given a string and a non-negative int n, return a larger string that is n copies of the original string. stringTimes(\u0026quot;Hi\u0026quot;, 2) → \u0026quot;HiHi\u0026quot; stringTimes(\u0026quot;Hi\u0026quot;, 3) → \u0026quot;HiHiHi\u0026quot; stringTimes(\u0026quot;Hi\u0026quot;, 1) → \u0026quot;Hi\u0026quot;  Given a string, return true if the first instance of \u0026ldquo;x\u0026rdquo; in the string is immediately followed by another \u0026ldquo;x\u0026rdquo;. doubleX(\u0026quot;axxbb\u0026quot;) → true doubleX(\u0026quot;axaxax\u0026quot;) → false doubleX(\u0026quot;xxxxx\u0026quot;) → true  Given a string, return the count of the number of times that a substring length 2 appears in the string and also as the last 2 chars of the string, so \u0026ldquo;hixxxhi\u0026rdquo; yields 1 (we won\u0026rsquo;t count the end substring). last2(\u0026quot;hixxhi\u0026quot;) → 1 last2(\u0026quot;xaxxaxaxx\u0026quot;) → 1 last2(\u0026quot;axxxaaxx\u0026quot;) → 2  Given a string, return a string made of the chars at indexes 0,1, 4,5, 8,9 \u0026hellip; so \u0026ldquo;kittens\u0026rdquo; yields \u0026ldquo;kien\u0026rdquo;. altPairs(\u0026quot;kitten\u0026quot;) → \u0026quot;kien\u0026quot; altPairs(\u0026quot;Chocolate\u0026quot;) → \u0026quot;Chole\u0026quot; altPairs(\u0026quot;CodingHorror\u0026quot;) → \u0026quot;Congrr\u0026quot;  Given a string and a non-negative int n, we\u0026rsquo;ll say that the front of the string is the first 3 chars, or whatever is there if the string is less than length 3. Return n copies of the front; frontTimes(\u0026quot;Chocolate\u0026quot;, 2) → \u0026quot;ChoCho\u0026quot; frontTimes(\u0026quot;Chocolate\u0026quot;, 3) → \u0026quot;ChoChoCho\u0026quot; frontTimes(\u0026quot;Abc\u0026quot;, 3) → \u0026quot;AbcAbcAbc\u0026quot;  Given a string, return a new string made of every other char starting with the first, so \u0026ldquo;Hello\u0026rdquo; yields \u0026ldquo;Hlo\u0026rdquo;. stringBits(\u0026quot;Hello\u0026quot;) → \u0026quot;Hlo\u0026quot; stringBits(\u0026quot;Hi\u0026quot;) → \u0026quot;H\u0026quot; stringBits(\u0026quot;Heeololeo\u0026quot;) → \u0026quot;Hello\u0026quot;  Given 2 strings, a and b, return the number of the positions where they contain the same length 2 substring. So \u0026ldquo;xxcaazz\u0026rdquo; and \u0026ldquo;xxbaaz\u0026rdquo; yields 3, since the \u0026ldquo;xx\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, and \u0026ldquo;az\u0026rdquo; substrings appear in the same place in both strings. stringMatch(\u0026quot;xxcaazz\u0026quot;, \u0026quot;xxbaaz\u0026quot;) → 3 stringMatch(\u0026quot;abc\u0026quot;, \u0026quot;abc\u0026quot;) → 2 stringMatch(\u0026quot;abc\u0026quot;, \u0026quot;axc\u0026quot;) → 0  Suppose the string \u0026ldquo;yak\u0026rdquo; is unlucky. Given a string, return a version where all the \u0026ldquo;yak\u0026rdquo; are removed, but the \u0026ldquo;a\u0026rdquo; can be any char. The \u0026ldquo;yak\u0026rdquo; strings will not overlap. stringYak(\u0026quot;yakpak\u0026quot;) → \u0026quot;pak\u0026quot; stringYak(\u0026quot;pakyak\u0026quot;) → \u0026quot;pak\u0026quot; stringYak(\u0026quot;yak123ya\u0026quot;) → \u0026quot;123ya\u0026quot;  Count the number of \u0026ldquo;xx\u0026rdquo; in the given string. We\u0026rsquo;ll say that overlapping is allowed, so \u0026ldquo;xxx\u0026rdquo; contains 2 \u0026ldquo;xx\u0026rdquo;. countXX(\u0026quot;abcxx\u0026quot;) → 1 countXX(\u0026quot;xxx\u0026quot;) → 2 countXX(\u0026quot;xxxx\u0026quot;) → 3  Given a non-empty string like \u0026ldquo;Code\u0026rdquo; return a string like \u0026ldquo;CCoCodCode\u0026rdquo;. stringSplosion(\u0026quot;Code) → \u0026quot;CCoCodCode\u0026quot; stringSplosion(\u0026quot;abc\u0026quot;) → \u0026quot;aababc\u0026quot; stringSplosion(\u0026quot;ab\u0026quot;) → \u0026quot;aab\u0026quot;  Given a string, return a version where all the \u0026ldquo;x\u0026rdquo; have been removed. Except an \u0026ldquo;x\u0026rdquo; at the very start or end should not be removed. stringX(\u0026quot;xxHxix\u0026quot;) → \u0026quot;xHix\u0026quot; stringX(\u0026quot;abxxxcd\u0026quot;) → \u0026quot;abcd\u0026quot; stringX(\u0026quot;xabxxxcdx\u0026quot;) → \u0026quot;xabcdx\u0026quot;   © - codingbat.com\nFizzBuzz - Задача, которая очень часто встречается на собеседовании #   Program that prints the numbers from 1 to 100. But for multiples of three print \u0026ldquo;Fizz\u0026rdquo; instead of the number and for the multiples of five print \u0026ldquo;Buzz\u0026rdquo;. For numbers which are multiples of both three and five print \u0026ldquo;FizzBuzz\u0026rdquo;. fizzBuzz() → \u0026quot;Fizz\u0026quot; fizzBuzz() → \u0026quot;Buzz\u0026quot; fizzBuzz() → \u0026quot;FizzBuzz\u0026quot;   "});index.add({'id':23,'href':'/school/java/exercises/11-exercises-java-logic-01/','title':"11 - Logic-1",'content':"Задачи на логику, на английском - уно #   When squirrels get together for a party, they like to have cigars. A squirrel party is successful when the number of cigars is between 40 and 60, inclusive. Unless it is the weekend, in which case there is no upper bound on the number of cigars. Return true if the party with the given values is successful, or false otherwise. cigarParty(30, false) → false cigarParty(50, false) → true cigarParty(70, true) → true  You are driving a little too fast, and a police officer stops you. Write code to compute the result, encoded as an int value: 0=no ticket, 1=small ticket, 2=big ticket. If speed is 60 or less, the result is 0. If speed is between 61 and 80 inclusive, the result is 1. If speed is 81 or more, the result is 2. Unless it is your birthday \u0026ndash; on that day, your speed can be 5 higher in all cases. caughtSpeeding(60, false) → 0 caughtSpeeding(65, false) → 1 caughtSpeeding(65, true) → 0  The number 6 is a truly great number. Given two int values, a and b, return true if either one is 6. Or if their sum or difference is 6. Note: the function Math.abs(num) computes the absolute value of a number. love6(6, 4) → true love6(4, 5) → false love6(1, 5) → true  Return true if the given non-negative number is 1 or 2 more than a multiple of 20. See also: Introduction to Mod more20(20) → false more20(21) → true more20(22) → true  Given a non-negative number \u0026ldquo;num\u0026rdquo;, return true if num is within 2 of a multiple of 10. Note: (a % b) is the remainder of dividing a by b, so (7 % 5) is 2. See also: Introduction to Mod nearTen(12) → true nearTen(17) → false nearTen(19) → true  We are having a party with amounts of tea and candy. Return the int outcome of the party encoded as 0=bad, 1=good, or 2=great. A party is good (1) if both tea and candy are at least 5. However, if either tea or candy is at least double the amount of the other one, the party is great (2). However, in all cases, if either tea or candy is less than 5, the party is always bad (0). teaParty(6, 8) → 1 teaParty(3, 8) → 0 teaParty(20, 6) → 2  Given three ints, a b c, return true if it is possible to add two of the ints to get the third. twoAsOne(1, 2, 3) → true twoAsOne(3, 1, 2) → true twoAsOne(3, 2, 2) → false  Given three ints, a b c, return true if two or more of them have the same rightmost digit. The ints are non-negative. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder, e.g. 17 % 10 is 7. lastDigit(23, 19, 13) → true lastDigit(23, 19, 12) → false lastDigit(23, 19, 3) → true  Given two int values, return whichever value is larger. However if the two values have the same remainder when divided by 5, then the return the smaller value. However, in all cases, if the two values are the same, return 0. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder, e.g. 7 % 5 is 2. maxMod5(2, 3) → 3 maxMod5(6, 2) → 6 maxMod5(3, 2) → 3  You have a blue lottery ticket, with ints a, b, and c on it. This makes three pairs, which we\u0026rsquo;ll call ab, bc, and ac. Consider the sum of the numbers in each pair. If any pair sums to exactly 10, the result is 10. Otherwise if the ab sum is exactly 10 more than either bc or ac sums, the result is 5. Otherwise the result is 0. blueTicket(9, 1, 0) → 10 blueTicket(9, 2, 0) → 0 blueTicket(6, 1, 4) → 10  You and your date are trying to get a table at a restaurant. The parameter \u0026ldquo;you\u0026rdquo; is the stylishness of your clothes, in the range 0..10, and \u0026ldquo;date\u0026rdquo; is the stylishness of your date\u0026rsquo;s clothes. The result getting the table is encoded as an int value with 0=no, 1=maybe, 2=yes. If either of you is very stylish, 8 or more, then the result is 2 (yes). With the exception that if either of you has style of 2 or less, then the result is 0 (no). Otherwise the result is 1 (maybe). dateFashion(5, 10) → 2 dateFashion(5, 2) → 0 dateFashion(5, 5) → 1  Given 2 ints, a and b, return their sum. However, sums in the range 10..19 inclusive, are forbidden, so in that case just return 20. sortaSum(3, 4) → 7 sortaSum(9, 4) → 20 sortaSum(10, 11) → 21  Given a number n, return true if n is in the range 1..10, inclusive. Unless outsideMode is true, in which case return true if the number is less or equal to 1, or greater or equal to 10. in1To10(5, false) → true in1To10(11, false) → false in1To10(11, true) → true  Return true if the given non-negative number is a multiple of 3 or 5, but not both. Use the % \u0026ldquo;mod\u0026rdquo; operator \u0026ndash; see Introduction to Mod old35(3) → true old35(10) → true old35(15) → false  Given 2 ints, a and b, return their sum. However, \u0026ldquo;teen\u0026rdquo; values in the range 13..19 inclusive, are extra lucky. So if either value is a teen, just return 19. teenSum(3, 4) → 7 teenSum(10, 13) → 19 teenSum(13, 2) → 19  Given a string str, if the string starts with \u0026ldquo;f\u0026rdquo; return \u0026ldquo;Fizz\u0026rdquo;. If the string ends with \u0026ldquo;b\u0026rdquo; return \u0026ldquo;Buzz\u0026rdquo;. If both the \u0026ldquo;f\u0026rdquo; and \u0026ldquo;b\u0026rdquo; conditions are true, return \u0026ldquo;FizzBuzz\u0026rdquo;. In all other cases, return the string unchanged. (See also: FizzBuzz Code) fizzString(\u0026quot;fig\u0026quot;) → \u0026quot;Fizz\u0026quot; fizzString(\u0026quot;dib\u0026quot;) → \u0026quot;Buzz\u0026quot; fizzString(\u0026quot;fib\u0026quot;) → \u0026quot;FizzBuzz\u0026quot;  Given three ints, a b c, return true if b is greater than a, and c is greater than b. However, with the exception that if \u0026ldquo;bOk\u0026rdquo; is true, b does not need to be greater than a. inOrder(1, 2, 4, false) → true inOrder(1, 2, 1, false) → false inOrder(1, 1, 2, true) → true  Given three ints, a b c, return true if one of them is 10 or more less than one of the others. lessBy10(1, 7, 11) → true lessBy10(1, 7, 10) → false lessBy10(11, 1, 7) → true  You have a red lottery ticket showing ints a, b, and c, each of which is 0, 1, or 2. If they are all the value 2, the result is 10. Otherwise if they are all the same, the result is 5. Otherwise so long as both b and c are different from a, the result is 1. Otherwise the result is 0. redTicket(2, 2, 2) → 10 redTicket(2, 2, 1) → 0 redTicket(0, 0, 0) → 5  Given two ints, each in the range 10..99, return true if there is a digit that appears in both numbers, such as the 2 in 12 and 23. (Note: division, e.g. n/10, gives the left digit while the % \u0026ldquo;mod\u0026rdquo; n%10 gives the right digit.) shareDigit(12, 23) → true shareDigit(12, 43) → false shareDigit(12, 44) → false  The squirrels in Palo Alto spend most of the day playing. In particular, they play if the temperature is between 60 and 90 (inclusive). Unless it is summer, then the upper limit is 100 instead of 90. Given an int temperature and a boolean isSummer, return true if the squirrels play and false otherwise. squirrelPlay(70, false) → true squirrelPlay(95, false) → false squirrelPlay(95, true) → true  Given a day of the week encoded as 0=Sun, 1=Mon, 2=Tue, \u0026hellip;6=Sat, and a boolean indicating if we are on vacation, return a string of the form \u0026ldquo;7:00\u0026rdquo; indicating when the alarm clock should ring. Weekdays, the alarm should be \u0026ldquo;7:00\u0026rdquo; and on the weekend it should be \u0026ldquo;10:00\u0026rdquo;. Unless we are on vacation \u0026ndash; then on weekdays it should be \u0026ldquo;10:00\u0026rdquo; and weekends it should be \u0026ldquo;off\u0026rdquo;. alarmClock(1, false) → \u0026quot;7:00\u0026quot; alarmClock(5, false) → \u0026quot;7:00\u0026quot; alarmClock(0, false) → \u0026quot;10:00\u0026quot;  We\u0026rsquo;ll say a number is special if it is a multiple of 11 or if it is one more than a multiple of 11. Return true if the given non-negative number is special. Use the % \u0026ldquo;mod\u0026rdquo; operator \u0026ndash; see Introduction to Mod specialEleven(22) → true specialEleven(23) → true specialEleven(24) → false  Return true if the given non-negative number is 1 or 2 less than a multiple of 20. So for example 38 and 39 return true, but 40 returns false. See also: Introduction to Mod less20(18) → true less20(19) → true less20(20) → false  Your cell phone rings. Return true if you should answer it. Normally you answer, except in the morning you only answer if it is your mom calling. In all cases, if you are asleep, you do not answer. answerCell(false, false, false) → true answerCell(false, false, true) → false answerCell(true, false, false) → false  Given an int n, return the string form of the number followed by \u0026ldquo;!\u0026rdquo;. So the int 6 yields \u0026ldquo;6!\u0026rdquo;. Except if the number is divisible by 3 use \u0026ldquo;Fizz\u0026rdquo; instead of the number, and if the number is divisible by 5 use \u0026ldquo;Buzz\u0026rdquo;, and if divisible by both 3 and 5, use \u0026ldquo;FizzBuzz\u0026rdquo;. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder after division, so 23 % 10 yields 3. What will the remainder be when one number divides evenly into another? (See also: FizzBuzz Code and Introduction to Mod) fizzString2(1) → \u0026quot;1!\u0026quot; fizzString2(2) → \u0026quot;2!\u0026quot; fizzString2(3) → \u0026quot;Fizz!\u0026quot;  Given three ints, a b c, return true if they are in strict increasing order, such as 2 5 11, or 5 6 7, but not 6 5 7 or 5 5 7. However, with the exception that if \u0026ldquo;equalOk\u0026rdquo; is true, equality is allowed, such as 5 5 7 or 5 5 5. inOrderEqual(2, 5, 11, false) → true inOrderEqual(5, 7, 6, false) → false inOrderEqual(5, 5, 7, true) → true  Return the sum of two 6-sided dice rolls, each in the range 1..6. However, if noDoubles is true, if the two dice show the same value, increment one die to the next value, wrapping around to 1 if its value was 6. withoutDoubles(2, 3, true) → 5 withoutDoubles(3, 3, true) → 7 withoutDoubles(3, 3, false) → 6  You have a green lottery ticket, with ints a, b, and c on it. If the numbers are all different from each other, the result is 0. If all of the numbers are the same, the result is 20. If two of the numbers are the same, the result is 10. greenTicket(1, 2, 3) → 0 greenTicket(2, 2, 2) → 20 greenTicket(1, 1, 2) → 10  Given 2 non-negative ints, a and b, return their sum, so long as the sum has the same number of digits as a. If the sum has more digits than a, just return a without b. (Note: one way to compute the number of digits of a non-negative int n is to convert it to a string with String.valueOf(n) and then check the length of the string.) sumLimit(2, 3) → 5 sumLimit(8, 3) → 8 sumLimit(8, 1) → 9   © - codingbat.com\n"});index.add({'id':24,'href':'/school/java/exercises/12-exercises-java-logic-02/','title':"12 - Logic-2",'content':"Задачи на логику - дос #   We want to make a row of bricks that is goal inches long. We have a number of small bricks (1 inch each) and big bricks (5 inches each). Return true if it is possible to make the goal by choosing from the given bricks. This is a little harder than it looks and can be done without any loops. See also: Introduction to MakeBricks makeBricks(3, 1, 8) → true makeBricks(3, 1, 9) → false makeBricks(3, 2, 10) → true  Given 3 int values, a b c, return their sum. However, if any of the values is a teen \u0026ndash; in the range 13..19 inclusive \u0026ndash; then that value counts as 0, except 15 and 16 do not count as a teens. Write a separate helper \u0026ldquo;public int fixTeen(int n) {\u0026ldquo;that takes in an int value and returns that value fixed for the teen rule. In this way, you avoid repeating the teen code 3 times (i.e. \u0026ldquo;decomposition\u0026rdquo;). Define the helper below and at the same indent level as the main noTeenSum(). noTeenSum(1, 2, 3) → 6 noTeenSum(2, 13, 1) → 3 noTeenSum(2, 1, 14) → 3  Given 2 int values greater than 0, return whichever value is nearest to 21 without going over. Return 0 if they both go over. blackjack(19, 21) → 21 blackjack(21, 19) → 21 blackjack(19, 22) → 19  Given 3 int values, a b c, return their sum. However, if one of the values is the same as another of the values, it does not count towards the sum. loneSum(1, 2, 3) → 6 loneSum(3, 2, 3) → 2 loneSum(3, 3, 3) → 0  For this problem, we\u0026rsquo;ll round an int value up to the next multiple of 10 if its rightmost digit is 5 or more, so 15 rounds up to 20. Alternately, round down to the previous multiple of 10 if its rightmost digit is less than 5, so 12 rounds down to 10. Given 3 ints, a b c, return the sum of their rounded values. To avoid code repetition, write a separate helper \u0026ldquo;public int round10(int num) {\u0026rdquo; and call it 3 times. Write the helper entirely below and at the same indent level as roundSum(). roundSum(16, 17, 18) → 60 roundSum(12, 13, 14) → 30 roundSum(6, 4, 4) → 10  Given 3 int values, a b c, return their sum. However, if one of the values is 13 then it does not count towards the sum and values to its right do not count. So for example, if b is 13, then both b and c do not count. luckySum(1, 2, 3) → 6 luckySum(1, 2, 13) → 3 luckySum(1, 13, 3) → 1  Given three ints, a b c, return true if one of b or c is \u0026ldquo;close\u0026rdquo; (differing from a by at most 1), while the other is \u0026ldquo;far\u0026rdquo;, differing from both other values by 2 or more. Note: Math.abs(num) computes the absolute value of a number. closeFar(1, 2, 10) → true closeFar(1, 2, 3) → false closeFar(4, 1, 3) → true  We want make a package of goal kilos of chocolate. We have small bars (1 kilo each) and big bars (5 kilos each). Return the number of small bars to use, assuming we always use big bars before small bars. Return -1 if it can\u0026rsquo;t be done. makeChocolate(4, 1, 9) → 4 makeChocolate(4, 1, 10) → -1 makeChocolate(4, 1, 7) → 2  Given three ints, a b c, one of them is small, one is medium and one is large. Return true if the three values are evenly spaced, so the difference between small and medium is the same as the difference between medium and large. evenlySpaced(2, 4, 6) → true evenlySpaced(4, 6, 2) → true evenlySpaced(4, 6, 3) → false   © - codingbat.com\n"});index.add({'id':25,'href':'/school/java/exercises/14-exercises-java-string-02/','title':"14 - String-2",'content':"Доброе день, String - дос #   Given a string, return a string where for every char in the original, there are two chars. doubleChar(\u0026quot;The\u0026quot;) → \u0026quot;TThhee\u0026quot; doubleChar(\u0026quot;AAbb\u0026quot;) → \u0026quot;AAAAbbbb\u0026quot; doubleChar(\u0026quot;Hi-There\u0026quot;) → \u0026quot;HHii--TThheerree\u0026quot;  Return the number of times that the string \u0026ldquo;code\u0026rdquo; appears anywhere in the given string, except we\u0026rsquo;ll accept any letter for the \u0026rsquo;d', so \u0026ldquo;cope\u0026rdquo; and \u0026ldquo;cooe\u0026rdquo; count. countCode(\u0026quot;aaacodebbb\u0026quot;) → 1 countCode(\u0026quot;codexxcode\u0026quot;) → 2 countCode(\u0026quot;cozexxcope\u0026quot;) → 2  Return true if the given string contains a \u0026ldquo;bob\u0026rdquo; string, but where the middle \u0026lsquo;o\u0026rsquo; char can be any char. bobThere(\u0026quot;abcbob\u0026quot;) → true bobThere(\u0026quot;b9b\u0026quot;) → true bobThere(\u0026quot;bac\u0026quot;) → false  Given a string and an int n, return a string made of n repetitions of the last n characters of the string. You may assume that n is between 0 and the length of the string, inclusive. repeatEnd(\u0026quot;Hello\u0026quot;, 3) → \u0026quot;llollollo\u0026quot; repeatEnd(\u0026quot;Hello\u0026quot;, 2) → \u0026quot;lolo\u0026quot; repeatEnd(\u0026quot;Hello\u0026quot;, 1) → \u0026quot;o\u0026quot;  Given a string, consider the prefix string made of the first N chars of the string. Does that prefix string appear somewhere else in the string? Assume that the string is not empty and that N is in the range 1..str.length(). prefixAgain(\u0026quot;abXYabc\u0026quot;, 1) → true prefixAgain(\u0026quot;abXYabc\u0026quot;, 2) → true prefixAgain(\u0026quot;abXYabc\u0026quot;, 3) → false  Returns true if for every \u0026lsquo;*\u0026rsquo; (star) in the string, if there are chars both immediately before and after the star, they are the same. sameStarChar(\u0026quot;xy*yzz\u0026quot;) → true sameStarChar(\u0026quot;xy*zzz\u0026quot;) → false sameStarChar(\u0026quot;*xa*az\u0026quot;) → true  Return a version of the given string, where for every star () in the string the star and the chars immediately to its left and right are gone. So \u0026ldquo;abcd\u0026rdquo; yields \u0026ldquo;ad\u0026rdquo; and \u0026ldquo;ab**cd\u0026rdquo; also yields \u0026ldquo;ad\u0026rdquo;. starOut(\u0026quot;ab*cd\u0026quot;) → \u0026quot;ad\u0026quot; starOut(\u0026quot;ab**cd\u0026quot;) → \u0026quot;ad\u0026quot; starOut(\u0026quot;sm*eilly\u0026quot;) → \u0026quot;silly\u0026quot;  Return the number of times that the string \u0026ldquo;hi\u0026rdquo; appears anywhere in the given string. countHi(\u0026quot;abc hi ho\u0026quot;) → 1 countHi(\u0026quot;ABChi hi\u0026quot;) → 2 countHi(\u0026quot;hihi\u0026quot;) → 2  Given two strings, return true if either of the strings appears at the very end of the other string, ignoring upper/lower case differences (in other words, the computation should not be \u0026ldquo;case sensitive\u0026rdquo;). Note: str.toLowerCase() returns the lowercase version of a string. endOther(\u0026quot;Hiabc\u0026quot;, \u0026quot;abc\u0026quot;) → true endOther(\u0026quot;AbC\u0026quot;, \u0026quot;HiaBc\u0026quot;) → true endOther(\u0026quot;abc\u0026quot;, \u0026quot;abXabc\u0026quot;) → true  We\u0026rsquo;ll say that a String is xy-balanced if for all the \u0026lsquo;x\u0026rsquo; chars in the string, there exists a \u0026lsquo;y\u0026rsquo; char somewhere later in the string. So \u0026ldquo;xxy\u0026rdquo; is balanced, but \u0026ldquo;xyx\u0026rdquo; is not. One \u0026lsquo;y\u0026rsquo; can balance multiple \u0026lsquo;x\u0026rsquo;s. Return true if the given string is xy-balanced. xyBalance(\u0026quot;aaxbby\u0026quot;) → true xyBalance(\u0026quot;aaxbb\u0026quot;) → false xyBalance(\u0026quot;yaaxbb\u0026quot;) → false  Given a string and an int n, return a string made of the first n characters of the string, followed by the first n-1 characters of the string, and so on. You may assume that n is between 0 and the length of the string, inclusive (i.e. n \u0026gt;= 0 and n \u0026lt;= str.length()). repeatFront(\u0026quot;Chocolate\u0026quot;, 4) → \u0026quot;ChocChoChC\u0026quot; repeatFront(\u0026quot;Chocolate\u0026quot;, 3) → \u0026quot;ChoChC\u0026quot; repeatFront(\u0026quot;Ice Cream\u0026quot;, 2) → \u0026quot;IcI\u0026quot;  Given a string, does \u0026ldquo;xyz\u0026rdquo; appear in the middle of the string? To define middle, we\u0026rsquo;ll say that the number of chars to the left and right of the \u0026ldquo;xyz\u0026rdquo; must differ by at most one. This problem is harder than it looks. xyzMiddle(\u0026quot;AAxyzBB\u0026quot;) → true xyzMiddle(\u0026quot;AxyzBB\u0026quot;) → true xyzMiddle(\u0026quot;AxyzBBB\u0026quot;) → false  Given a string, compute a new string by moving the first char to come after the next two chars, so \u0026ldquo;abc\u0026rdquo; yields \u0026ldquo;bca\u0026rdquo;. Repeat this process for each subsequent group of 3 chars, so \u0026ldquo;abcdef\u0026rdquo; yields \u0026ldquo;bcaefd\u0026rdquo;. Ignore any group of fewer than 3 chars at the end. oneTwo(\u0026quot;abc\u0026quot;) → \u0026quot;bca\u0026quot; oneTwo(\u0026quot;tca\u0026quot;) → \u0026quot;cat\u0026quot; oneTwo(\u0026quot;tcagdo\u0026quot;) → \u0026quot;catdog\u0026quot;  Given a string and a non-empty word string, return a version of the original String where all chars have been replaced by pluses (\u0026quot;+\u0026quot;), except for appearances of the word string which are preserved unchanged. plusOut(\u0026quot;12xy34\u0026quot;, \u0026quot;xy\u0026quot;) → \u0026quot;++xy++\u0026quot; plusOut(\u0026quot;12xy34\u0026quot;, \u0026quot;1\u0026quot;) → \u0026quot;1+++++\u0026quot; plusOut(\u0026quot;12xy34xyabcxy\u0026quot;, \u0026quot;xy\u0026quot;) → \u0026quot;++xy++xy+++xy\u0026quot;  Return true if the string \u0026ldquo;cat\u0026rdquo; and \u0026ldquo;dog\u0026rdquo; appear the same number of times in the given string. catDog(\u0026quot;catdog\u0026quot;) → true catDog(\u0026quot;catcat\u0026quot;) → false catDog(\u0026quot;1cat1cadodog\u0026quot;) → true  Return true if the given string contains an appearance of \u0026ldquo;xyz\u0026rdquo; where the xyz is not directly preceeded by a period (.). So \u0026ldquo;xxyz\u0026rdquo; counts but \u0026ldquo;x.xyz\u0026rdquo; does not. xyzThere(\u0026quot;abcxyz\u0026quot;) → true xyzThere(\u0026quot;abc.xyz\u0026quot;) → false xyzThere(\u0026quot;xyz.abc\u0026quot;) → true  Given two strings, a and b, create a bigger string made of the first char of a, the first char of b, the second char of a, the second char of b, and so on. Any leftover chars go at the end of the result. mixString(\u0026quot;abc\u0026quot;, \u0026quot;xyz\u0026quot;) → \u0026quot;axbycz\u0026quot; mixString(\u0026quot;Hi\u0026quot;, \u0026quot;There\u0026quot;) → \u0026quot;HTihere\u0026quot; mixString(\u0026quot;xxxx\u0026quot;, \u0026quot;There\u0026quot;) → \u0026quot;xTxhxexre\u0026quot;  Given two strings, word and a separator sep, return a big string made of count occurrences of the word, separated by the separator string. repeatSeparator(\u0026quot;Word\u0026quot;, \u0026quot;X\u0026quot;, 3) → \u0026quot;WordXWordXWord\u0026quot; repeatSeparator(\u0026quot;This\u0026quot;, \u0026quot;And\u0026quot;, 2) → \u0026quot;ThisAndThis\u0026quot; repeatSeparator(\u0026quot;This\u0026quot;, \u0026quot;And\u0026quot;, 1) → \u0026quot;This\u0026quot;  A sandwich is two pieces of bread with something in between. Return the string that is between the first and last appearance of \u0026ldquo;bread\u0026rdquo; in the given string, or return the empty string \u0026quot;\u0026quot; if there are not two pieces of bread. getSandwich(\u0026quot;breadjambread\u0026quot;) → \u0026quot;jam\u0026quot; getSandwich(\u0026quot;xxbreadjambreadyy\u0026quot;) → \u0026quot;jam\u0026quot; getSandwich(\u0026quot;xxbreadyy\u0026quot;) → \u0026quot;\u0026quot;  Look for patterns like \u0026ldquo;zip\u0026rdquo; and \u0026ldquo;zap\u0026rdquo; in the string \u0026ndash; length-3, starting with \u0026lsquo;z\u0026rsquo; and ending with \u0026lsquo;p\u0026rsquo;. Return a string where for all such words, the middle letter is gone, so \u0026ldquo;zipXzap\u0026rdquo; yields \u0026ldquo;zpXzp\u0026rdquo;. zipZap(\u0026quot;zipXzap\u0026quot;) → \u0026quot;zpXzp\u0026quot; zipZap(\u0026quot;zopzop\u0026quot;) → \u0026quot;zpzp\u0026quot; zipZap(\u0026quot;zzzopzop\u0026quot;) → \u0026quot;zzzpzp\u0026quot;  Given a string and a non-empty word string, return a string made of each char just before and just after every appearance of the word in the string. Ignore cases where there is no char before or after the word, and a char may be included twice if it is between two words. wordEnds(\u0026quot;abcXY123XYijk\u0026quot;, \u0026quot;XY\u0026quot;) → \u0026quot;c13i\u0026quot; wordEnds(\u0026quot;XY123XY\u0026quot;, \u0026quot;XY\u0026quot;) → \u0026quot;13\u0026quot; wordEnds(\u0026quot;XY1XY\u0026quot;, \u0026quot;XY\u0026quot;) → \u0026quot;11\u0026quot;   © - codingbat.com\n"});index.add({'id':26,'href':'/school/java/exercises/15-exercises-java-string-03/','title':"15 - String-3",'content':"Добрый вечер, String - трес #   Given a string, count the number of words ending in \u0026lsquo;y\u0026rsquo; or \u0026lsquo;z\u0026rsquo; \u0026ndash; so the \u0026lsquo;y\u0026rsquo; in \u0026ldquo;heavy\u0026rdquo; and the \u0026lsquo;z\u0026rsquo; in \u0026ldquo;fez\u0026rdquo; count, but not the \u0026lsquo;y\u0026rsquo; in \u0026ldquo;yellow\u0026rdquo; (not case sensitive). We\u0026rsquo;ll say that a y or z is at the end of a word if there is not an alphabetic letter immediately following it. (Note: Character.isLetter(char) tests if a char is an alphabetic letter.) countYZ(\u0026quot;fez day\u0026quot;) → 2 countYZ(\u0026quot;day fez\u0026quot;) → 2 countYZ(\u0026quot;day fyyyz\u0026quot;) → 2  We\u0026rsquo;ll say that a lowercase \u0026lsquo;g\u0026rsquo; in a string is \u0026ldquo;happy\u0026rdquo; if there is another \u0026lsquo;g\u0026rsquo; immediately to its left or right. Return true if all the g\u0026rsquo;s in the given string are happy. gHappy(\u0026quot;xxggxx\u0026quot;) → true gHappy(\u0026quot;xxgxx\u0026quot;) → false gHappy(\u0026quot;xxggyygxx\u0026quot;) → false  Given a string, return the longest substring that appears at both the beginning and end of the string without overlapping. For example, sameEnds(\u0026ldquo;abXab\u0026rdquo;) is \u0026ldquo;ab\u0026rdquo;. sameEnds(\u0026quot;abXYab\u0026quot;) → \u0026quot;ab\u0026quot; sameEnds(\u0026quot;xx\u0026quot;) → \u0026quot;x\u0026quot; sameEnds(\u0026quot;xxx\u0026quot;) → \u0026quot;x\u0026quot;  Given a string, return the sum of the numbers appearing in the string, ignoring all other characters. A number is a series of 1 or more digit chars in a row. (Note: Character.isDigit(char) tests if a char is one of the chars \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, .. \u0026lsquo;9\u0026rsquo;. Integer.parseInt(string) converts a string to an int.) sumNumbers(\u0026quot;abc123xyz\u0026quot;) → 123 sumNumbers(\u0026quot;aa11b33\u0026quot;) → 44 sumNumbers(\u0026quot;7 11\u0026quot;) → 18  Given two strings, base and remove, return a version of the base string where all instances of the remove string have been removed (not case sensitive). You may assume that the remove string is length 1 or more. Remove only non-overlapping instances, so with \u0026ldquo;xxx\u0026rdquo; removing \u0026ldquo;xx\u0026rdquo; leaves \u0026ldquo;x\u0026rdquo;. withoutString(\u0026quot;Hello there\u0026quot;, \u0026quot;llo\u0026quot;) → \u0026quot;He there\u0026quot; withoutString(\u0026quot;Hello there\u0026quot;, \u0026quot;e\u0026quot;) → \u0026quot;Hllo thr\u0026quot; withoutString(\u0026quot;Hello there\u0026quot;, \u0026quot;x\u0026quot;) → \u0026quot;Hello there\u0026quot;  We\u0026rsquo;ll say that a \u0026ldquo;triple\u0026rdquo; in a string is a char appearing three times in a row. Return the number of triples in the given string. The triples may overlap. countTriple(\u0026quot;abcXXXabc\u0026quot;) → 1 countTriple(\u0026quot;xxxabyyyycd\u0026quot;) → 3 countTriple(\u0026quot;a\u0026quot;) → 0  Given a string, look for a mirror image (backwards) string at both the beginning and end of the given string. In other words, zero or more characters at the very begining of the given string, and at the very end of the string in reverse order (possibly overlapping). For example, the string \u0026ldquo;abXYZba\u0026rdquo; has the mirror end \u0026ldquo;ab\u0026rdquo;. mirrorEnds(\u0026quot;abXYZba\u0026quot;) → \u0026quot;ab\u0026quot; mirrorEnds(\u0026quot;abca\u0026quot;) → \u0026quot;a\u0026quot; mirrorEnds(\u0026quot;aba\u0026quot;) → \u0026quot;aba\u0026quot;  Given a string, return a string where every appearance of the lowercase word \u0026ldquo;is\u0026rdquo; has been replaced with \u0026ldquo;is not\u0026rdquo;. The word \u0026ldquo;is\u0026rdquo; should not be immediately preceeded or followed by a letter \u0026ndash; so for example the \u0026ldquo;is\u0026rdquo; in \u0026ldquo;this\u0026rdquo; does not count. (Note: Character.isLetter(char) tests if a char is a letter.) notReplace(\u0026quot;is test\u0026quot;) → \u0026quot;is not test\u0026quot; notReplace(\u0026quot;is-is\u0026quot;) → \u0026quot;is not-is not\u0026quot; notReplace(\u0026quot;This is right\u0026quot;) → \u0026quot;This is not right\u0026quot;  Given a string, return true if the number of appearances of \u0026ldquo;is\u0026rdquo; anywhere in the string is equal to the number of appearances of \u0026ldquo;not\u0026rdquo; anywhere in the string (case sensitive). equalIsNot(\u0026quot;This is not\u0026quot;) → false equalIsNot(\u0026quot;This is notnot\u0026quot;) → true equalIsNot(\u0026quot;noisxxnotyynotxisi\u0026quot;) → true  Given a string, return the sum of the digits 0-9 that appear in the string, ignoring all other characters. Return 0 if there are no digits in the string. (Note: Character.isDigit(char) tests if a char is one of the chars \u0026lsquo;0\u0026rsquo;, \u0026lsquo;1\u0026rsquo;, .. \u0026lsquo;9\u0026rsquo;. Integer.parseInt(string) converts a string to an int.) sumDigits(\u0026quot;aa1bc2d3\u0026quot;) → 6 sumDigits(\u0026quot;aa11b33\u0026quot;) → 8 sumDigits(\u0026quot;Chocolate\u0026quot;) → 0  Given a string, return the length of the largest \u0026ldquo;block\u0026rdquo; in the string. A block is a run of adjacent chars that are the same. maxBlock(\u0026quot;hoopla\u0026quot;) → 2 maxBlock(\u0026quot;abbCCCddBBBxx\u0026quot;) → 3 maxBlock(\u0026quot;\u0026quot;) → 0   © - codingbat.com\n"});index.add({'id':27,'href':'/school/java/exercises/18-exercises-java-arrays-01/','title':"18 - Array-1",'content':"Закрепление массивов, Java-Basic #    Given an array of ints, return true if 6 appears as either the first or last element in the array. The array will be length 1 or more.\nДан массив int. Верните true, если цифра 6 является значением в первом или последнем элементе массива. Массив будет длиной больше, либо равной единице.\nfirstLast6([1, 2, 6]) → true firstLast6([6, 1, 2, 3]) → true firstLast6([13, 6, 1, 2, 3]) → false   Given 2 arrays of ints, a and b, return true if they have the same first element or they have the same last element. Both arrays will be length 1 or more.\nПолучив 2 массива int[], a и b, возвращаем true, если они имеют один и тот же первый или последний элемент. Оба массива будут длиной больше, либо равной единице.\ncommonEnd([1, 2, 3], [7, 3]) → true commonEnd([1, 2, 3], [7, 3, 2]) → false commonEnd([1, 2, 3], [1, 3]) → true   Given an array of ints length 3, return a new array with the elements in reverse order, so {1, 2, 3} becomes {3, 2, 1}.\nДан массив длиной 3, верните новый массив с элементами в обратном порядке, например {1, 2, 3} становится {3, 2, 1}.\nreverse3([1, 2, 3]) → [3, 2, 1] reverse3([5, 11, 9]) → [9, 11, 5] reverse3([7, 0, 0]) → [0, 0, 7]   Given 2 int arrays, a and b, each length 3, return a new array length 2 containing their middle elements.\nДаны 2 массива int, a и b, каждый длиной 3, верните новый массив с длиной 2, содержащего среднее арифметическое элементов первоначальных массивов.\nmiddleWay([1, 2, 3], [4, 5, 6]) → [2, 5] middleWay([7, 7, 7], [3, 8, 0]) → [7, 8] middleWay([5, 2, 9], [1, 4, 5]) → [2, 4]   Given an int array length 2, return true if it does not contain a 2 or 3.\nno23([4, 5]) → true no23([4, 2]) → false no23([3, 5]) → false   Given an int array length 3, if there is a 2 in the array immediately followed by a 3, set the 3 element to 0. Return the changed array.\nfix23([1, 2, 3]) → [1, 2, 0] fix23([2, 3, 5]) → [2, 0, 5] fix23([1, 2, 1]) → [1, 2, 1]   Given an array of ints of even length, return a new array length 2 containing the middle two elements from the original array. The original array will be length 2 or more.\nmakeMiddle([1, 2, 3, 4]) → [2, 3] makeMiddle([7, 1, 2, 3, 4, 9]) → [2, 3] makeMiddle([1, 2]) → [1, 2]   Given an array of ints of odd length, return a new array length 3 containing the elements from the middle of the array. The array length will be at least 3.\nmidThree([1, 2, 3, 4, 5]) → [2, 3, 4] midThree([8, 6, 7, 5, 3, 0, 9]) → [7, 5, 3] midThree([1, 2, 3]) → [1, 2, 3]   We\u0026rsquo;ll say that a 1 immediately followed by a 3 in an array is an \u0026ldquo;unlucky\u0026rdquo; 1. Return true if the given array contains an unlucky 1 in the first 2 or last 2 positions in the array.\nunlucky1([1, 3, 4, 5]) → true unlucky1([2, 1, 3, 4, 5]) → true unlucky1([1, 1, 1]) → false   Given an array of ints, return true if the array is length 1 or more, and the first element and the last element are equal.\nsameFirstLast([1, 2, 3]) → false sameFirstLast([1, 2, 3, 1]) → true sameFirstLast([1, 2, 1]) → true   Given an array of ints length 3, return the sum of all the elements.\nsum3([1, 2, 3]) → 6 sum3([5, 11, 2]) → 18 sum3([7, 0, 0]) → 7   Given an array of ints length 3, figure out which is larger, the first or last element in the array, and set all the other elements to be that value. Return the changed array.\nmaxEnd3([1, 2, 3]) → [3, 3, 3] maxEnd3([11, 5, 9]) → [11, 11, 11] maxEnd3([2, 11, 3]) → [3, 3, 3]   Given an array of ints, return a new array length 2 containing the first and last elements from the original array. The original array will be length 1 or more.\nmakeEnds([1, 2, 3]) → [1, 3] makeEnds([1, 2, 3, 4]) → [1, 4] makeEnds([7, 4, 6, 2]) → [7, 2]   Given an int array, return a new array with double the length where its last element is the same as the original array, and all the other elements are 0. The original array will be length 1 or more. Note: by default, a new int array contains all 0\u0026rsquo;s.\nmakeLast([4, 5, 6]) → [0, 0, 0, 0, 0, 6] makeLast([1, 2]) → [0, 0, 0, 2] makeLast([3]) → [0, 3]   Start with 2 int arrays, a and b, of any length. Return how many of the arrays have 1 as their first element.\nstart1([1, 2, 3], [1, 3]) → 2 start1([7, 2, 3], [1]) → 1 start1([1, 2], []) → 1   Given 2 int arrays, each length 2, return a new array length 4 containing all their elements.\nplusTwo([1, 2], [3, 4]) → [1, 2, 3, 4] plusTwo([4, 4], [2, 2]) → [4, 4, 2, 2] plusTwo([9, 2], [3, 4]) → [9, 2, 3, 4]   Given an array of ints of odd length, look at the first, last, and middle values in the array and return the largest. The array length will be a least 1.\nmaxTriple([1, 2, 3]) → 3 maxTriple([1, 5, 3]) → 5 maxTriple([5, 2, 3]) → 5   Given 2 int arrays, a and b, return a new array length 2 containing, as much as will fit, the elements from a followed by the elements from b. The arrays may be any length, including 0, but there will be 2 or more elements available between the 2 arrays.\nmake2([4, 5], [1, 2, 3]) → [4, 5] make2([4], [1, 2, 3]) → [4, 1] make2([], [1, 2]) → [1, 2]   Return an int array length 3 containing the first 3 digits of pi, {3, 1, 4}.\nmakePi() → [3, 1, 4]   Given an array of ints length 3, return an array with the elements \u0026ldquo;rotated left\u0026rdquo; so {1, 2, 3} yields {2, 3, 1}.\nrotateLeft3([1, 2, 3]) → [2, 3, 1] rotateLeft3([5, 11, 9]) → [11, 9, 5] rotateLeft3([7, 0, 0]) → [0, 0, 7]   Given an array of ints, return the sum of the first 2 elements in the array. If the array length is less than 2, just sum up the elements that exist, returning 0 if the array is length 0.\nsum2([1, 2, 3]) → 3 sum2([1, 1]) → 2 sum2([1, 1, 1, 1]) → 2   Given an int array length 2, return true if it contains a 2 or a 3.\nhas23([2, 5]) → true has23([4, 3]) → true has23([4, 5]) → false   Given an int array, return true if the array contains 2 twice, or 3 twice. The array will be length 0, 1, or 2.\ndouble23([2, 2]) → true double23([3, 3]) → true double23([2, 3]) → false   Start with 2 int arrays, a and b, each length 2. Consider the sum of the values in each array. Return the array which has the largest sum. In event of a tie, return a.\nbiggerTwo([1, 2], [3, 4]) → [3, 4] biggerTwo([3, 4], [1, 2]) → [3, 4] biggerTwo([1, 1], [1, 2]) → [1, 2]   Given an array of ints, swap the first and last elements in the array. Return the modified array. The array length will be at least 1.\nswapEnds([1, 2, 3, 4]) → [4, 2, 3, 1] swapEnds([1, 2, 3]) → [3, 2, 1] swapEnds([8, 6, 7, 9, 5]) → [5, 6, 7, 9, 8]   Given an int array of any length, return a new array of its first 2 elements. If the array is smaller than length 2, use whatever elements are present.\nfrontPiece([1, 2, 3]) → [1, 2] frontPiece([1, 2]) → [1, 2] frontPiece([1]) → [1]   Given 2 int arrays, a and b, of any length, return a new array with the first element of each array. If either array is length 0, ignore that array.\nfront11([1, 2, 3], [7, 9, 8]) → [1, 7] front11([1], [2]) → [1, 2] front11([1, 7], []) → [1]   © - codingbat.com\n"});index.add({'id':28,'href':'/school/java/exercises/19-exercises-java-arrays-02/','title':"19 - Array-2",'content':"Закрепление массивов, Java-Basic, Array-3 #  Закрепление массивов, Java-Basic #   Return the number of even ints in the given array. Note: the % \u0026ldquo;mod\u0026rdquo; operator computes the remainder, e.g. 5 % 2 is 1. countEvens([2, 1, 2, 3, 4]) → 3 countEvens([2, 2, 0]) → 3 countEvens([1, 3, 5]) → 0  Return the sum of the numbers in the array, returning 0 for an empty array. Except the number 13 is very unlucky, so it does not count and numbers that come immediately after a 13 also do not count. sum13([1, 2, 2, 1]) → 6 sum13([1, 1]) → 2 sum13([1, 2, 2, 1, 13]) → 6  Given an array of ints, return true if the array contains no 1\u0026rsquo;s and no 3\u0026rsquo;s. lucky13([0, 2, 4]) → true lucky13([1, 2, 3]) → false lucky13([1, 2, 4]) → false  Given a number n, create and return a new int array of length n, containing the numbers 0, 1, 2, \u0026hellip; n-1. The given n may be 0, in which case just return a length 0 array. You do not need a separate if-statement for the length-0 case; the for-loop should naturally execute 0 times in that case, so it just works. The syntax to make a new int array is: new int[desired_length] (See also: FizzBuzz Code) fizzArray(4) → [0, 1, 2, 3] fizzArray(1) → [0] fizzArray(10) → [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]  Given an array of ints, return true if it contains no 1\u0026rsquo;s or it contains no 4\u0026rsquo;s. no14([1, 2, 3]) → true no14([1, 2, 3, 4]) → false no14([2, 3, 4]) → true  Given arrays nums1 and nums2 of the same length, for every element in nums1, consider the corresponding element in nums2 (at the same index). Return the count of the number of times that the two elements differ by 2 or less, but are not equal. matchUp([1, 2, 3], [2, 3, 10]) → 2 matchUp([1, 2, 3], [2, 3, 5]) → 3 matchUp([1, 2, 3], [2, 3, 3]) → 2  Given an array of ints, return true if the array contains either 3 even or 3 odd values all next to each other. modThree([2, 1, 3, 5]) → true modThree([2, 1, 2, 5]) → false modThree([2, 4, 2, 5]) → true  Return true if the group of N numbers at the start and end of the array are the same. For example, with {5, 6, 45, 99, 13, 5, 6}, the ends are the same for n=0 and n=2, and false for n=1 and n=3. You may assume that n is in the range 0..nums.length inclusive. sameEnds([5, 6, 45, 99, 13, 5, 6], 1) → false sameEnds([5, 6, 45, 99, 13, 5, 6], 2) → true sameEnds([5, 6, 45, 99, 13, 5, 6], 3) → false  Return an array that is \u0026ldquo;left shifted\u0026rdquo; by one \u0026ndash; so {6, 2, 5, 3} returns {2, 5, 3, 6}. You may modify and return the given array, or return a new array. shiftLeft([6, 2, 5, 3]) → [2, 5, 3, 6] shiftLeft([1, 2]) → [2, 1] shiftLeft([1]) → [1]  Given a non-empty array of ints, return a new array containing the elements from the original array that come after the last 4 in the original array. The original array will contain at least one 4. Note that it is valid in java to create an array of length 0. post4([2, 4, 1, 2]) → [1, 2] post4([4, 1, 4, 2]) → [2] post4([4, 4, 1, 2, 3]) → [1, 2, 3]  Return a version of the given array where all the 10\u0026rsquo;s have been removed. The remaining elements should shift left towards the start of the array as needed, and the empty spaces a the end of the array should be 0. So {1, 10, 10, 2} yields {1, 2, 0, 0}. You may modify and return the given array or make a new array. withoutTen([1, 10, 10, 2]) → [1, 2, 0, 0] withoutTen([10, 2, 10]) → [2, 0, 0] withoutTen([1, 99, 10]) → [1, 99, 0]  This is slightly more difficult version of the famous FizzBuzz problem which is sometimes given as a first problem for job interviews. (See also: FizzBuzz Code.) Consider the series of numbers beginning at start and running up to but not including end, so for example start=1 and end=5 gives the series 1, 2, 3, 4. Return a new String[] array containing the string form of these numbers, except for multiples of 3, use \u0026ldquo;Fizz\u0026rdquo; instead of the number, for multiples of 5 use \u0026ldquo;Buzz\u0026rdquo;, and for multiples of both 3 and 5 use \u0026ldquo;FizzBuzz\u0026rdquo;. In Java, String.valueOf(xxx) will make the String form of an int or other type. This version is a little more complicated than the usual version since you have to allocate and index into an array instead of just printing, and we vary the start/end instead of just always doing 1..100. //02-12\u0026mdash;Это немного более сложная версия известной проблемы FizzBuzz, // которую иногда называют первой проблемой для собеседований. (См. Также: Код FizzBuzz.) // Рассмотрим последовательность чисел, начинающуюся с начала и продолжающуюся до, // но не включающую конец, поэтому, например, start = 1 и end = 5 дают серии 1, 2, 3, 4. // Возвращаем новую строку [] массив, содержащий строковую форму этих чисел, // за исключением кратных 3, используйте «Fizz» вместо числа, для кратных 5 используйте «Buzz», // а для кратных 3 и 5 используйте «FizzBuzz». В Java String.valueOf (xxx) // сделает строковую форму типа int или другого типа. Эта версия немного сложнее, чем обычная версия, // так как вам нужно выделять и индексировать массив, // а не просто печатать, и мы меняем начало / конец вместо того, чтобы всегда делать 1..100. fizzBuzz(1, 6) → [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;] fizzBuzz(1, 8) → [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;7\u0026quot;] fizzBuzz(1, 11) → [\u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;Buzz\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;Fizz\u0026quot;, \u0026quot;Buzz\u0026quot;]  Given an array length 1 or more of ints, return the difference between the largest and smallest values in the array. Note: the built-in Math.min(v1, v2) and Math.max(v1, v2) methods return the smaller or larger of two values. bigDiff([10, 3, 5, 6]) → 7 bigDiff([7, 2, 10, 9]) → 8 bigDiff([2, 10, 7, 2]) → 8  Return the sum of the numbers in the array, except ignore sections of numbers starting with a 6 and extending to the next 7 (every 6 will be followed by at least one 7). Return 0 for no numbers. sum67([1, 2, 2]) → 5 sum67([1, 2, 2, 6, 99, 99, 7]) → 5 sum67([1, 1, 6, 7, 2]) → 4  Given an array of ints, return true if the sum of all the 2\u0026rsquo;s in the array is exactly 8. sum28([2, 3, 2, 2, 4, 2]) → true sum28([2, 3, 2, 2, 4, 2, 2]) → false sum28([1, 2, 3, 4]) → false  Given an array of ints, return true if every element is a 1 or a 4. only14([1, 4, 1, 4]) → true only14([1, 4, 2, 4]) → false only14([1, 1]) → true  We\u0026rsquo;ll say that a value is \u0026ldquo;everywhere\u0026rdquo; in an array if for every pair of adjacent elements in the array, at least one of the pair is that value. Return true if the given value is everywhere in the array. isEverywhere([1, 2, 1, 3], 1) → true isEverywhere([1, 2, 1, 3], 2) → false isEverywhere([1, 2, 1, 3, 4], 1) → false  Given an array of ints, return true if the array contains two 7\u0026rsquo;s next to each other, or there are two 7\u0026rsquo;s separated by one element, such as with {7, 1, 7}. has77([1, 7, 7]) → true has77([1, 7, 1, 7]) → true has77([1, 7, 1, 1, 7]) → false  Given an array of ints, return true if the value 3 appears in the array exactly 3 times, and no 3\u0026rsquo;s are next to each other. haveThree([3, 1, 3, 1, 3]) → true haveThree([3, 1, 3, 3]) → false haveThree([3, 4, 3, 3, 4]) → false  Return true if the array contains, somewhere, three increasing adjacent numbers like \u0026hellip;. 4, 5, 6, \u0026hellip; or 23, 24, 25. tripleUp([1, 4, 5, 6, 2]) → true tripleUp([1, 2, 3]) → true tripleUp([1, 2, 4]) → false  For each multiple of 10 in the given array, change all the values following it to be that multiple of 10, until encountering another multiple of 10. So {2, 10, 3, 4, 20, 5} yields {2, 10, 10, 10, 20, 20}. tenRun([2, 10, 3, 4, 20, 5]) → [2, 10, 10, 10, 20, 20] tenRun([10, 1, 20, 2]) → [10, 10, 20, 20] tenRun([10, 1, 9, 20]) → [10, 10, 10, 20]  We\u0026rsquo;ll say that an element in an array is \u0026ldquo;alone\u0026rdquo; if there are values before and after it, and those values are different from it. Return a version of the given array where every instance of the given value which is alone is replaced by whichever value to its left or right is larger. notAlone([1, 2, 3], 2) → [1, 3, 3] notAlone([1, 2, 3, 2, 5, 2], 2) → [1, 3, 3, 5, 5, 2] notAlone([3, 4], 3) → [3, 4]  Return a version of the given array where each zero value in the array is replaced by the largest odd value to the right of the zero in the array. If there is no odd value to the right of the zero, leave the zero as a zero. zeroMax([0, 5, 0, 3]) → [5, 5, 3, 3] zeroMax([0, 4, 0, 3]) → [3, 4, 3, 3] zeroMax([0, 1, 0]) → [1, 1, 0]  Return the \u0026ldquo;centered\u0026rdquo; average of an array of ints, which we\u0026rsquo;ll say is the mean average of the values, except ignoring the largest and smallest values in the array. If there are multiple copies of the smallest value, ignore just one copy, and likewise for the largest value. Use int division to produce the final average. You may assume that the array is length 3 or more. centeredAverage([1, 2, 3, 4, 100]) → 3 centeredAverage([1, 1, 5, 5, 10, 8, 7]) → 5 centeredAverage([-10, -4, -2, -4, -2, 0]) → -3  Given an array of ints, return true if the array contains a 2 next to a 2 somewhere. has22([1, 2, 2]) → true has22([1, 2, 1, 2]) → false has22([2, 1, 2]) → false  Given an array of ints, return true if the number of 1\u0026rsquo;s is greater than the number of 4\u0026rsquo;s more14([1, 4, 1]) → true more14([1, 4, 1, 4]) → false more14([1, 1]) → true  Given a number n, create and return a new string array of length n, containing the strings \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo; \u0026ldquo;2\u0026rdquo; .. through n-1. N may be 0, in which case just return a length 0 array. Note: String.valueOf(xxx) will make the String form of most types. The syntax to make a new string array is: new String[desired_length] (See also: FizzBuzz Code) fizzArray2(4) → [\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;] fizzArray2(10) → [\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;3\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;, \u0026quot;6\u0026quot;, \u0026quot;7\u0026quot;, \u0026quot;8\u0026quot;, \u0026quot;9\u0026quot;] fizzArray2(2) → [\u0026quot;0\u0026quot;, \u0026quot;1\u0026quot;]  Given an array of ints, return true if the array contains a 2 next to a 2 or a 4 next to a 4, but not both. either24([1, 2, 2]) → true either24([4, 4, 1]) → true either24([4, 4, 1, 2, 2]) → false  Given an array of ints, return true if there is a 1 in the array with a 2 somewhere later in the array. has12([1, 3, 2]) → true has12([3, 1, 2]) → true has12([3, 1, 4, 5, 2]) → true  Given an array of ints, return true if every 2 that appears in the array is next to another 2. twoTwo([4, 2, 2, 3]) → true twoTwo([2, 2, 4]) → true twoTwo([2, 2, 4, 2]) → false  Given start and end numbers, return a new array containing the sequence of integers from start up to but not including end, so start=5 and end=10 yields {5, 6, 7, 8, 9}. The end number will be greater or equal to the start number. Note that a length-0 array is valid. (See also: FizzBuzz Code) fizzArray3(5, 10) → [5, 6, 7, 8, 9] fizzArray3(11, 18) → [11, 12, 13, 14, 15, 16, 17] fizzArray3(1, 3) → [1, 2]  Given a non-empty array of ints, return a new array containing the elements from the original array that come before the first 4 in the original array. The original array will contain at least one 4. Note that it is valid in java to create an array of length 0. pre4([1, 2, 4, 1]) → [1, 2] pre4([3, 1, 4]) → [3, 1] pre4([1, 4, 4]) → [1]  Return an array that contains the exact same numbers as the given array, but rearranged so that all the zeros are grouped at the start of the array. The order of the non-zero numbers does not matter. So {1, 0, 0, 1} becomes {0 ,0, 1, 1}. You may modify and return the given array or make a new array. zeroFront([1, 0, 0, 1]) → [0, 0, 1, 1] zeroFront([0, 1, 1, 0, 1]) → [0, 0, 1, 1, 1] zeroFront([1, 0]) → [0, 1]  Return an array that contains the exact same numbers as the given array, but rearranged so that all the even numbers come before all the odd numbers. Other than that, the numbers can be in any order. You may modify and return the given array, or make a new array. evenOdd([1, 0, 1, 0, 0, 1, 1]) → [0, 0, 0, 1, 1, 1, 1] evenOdd([3, 3, 2]) → [2, 3, 3] evenOdd([2, 2, 2]) → [2, 2, 2]   © - codingbat.com\n"});index.add({'id':29,'href':'/school/java/basic-course/002-java-integers/','title':"2",'content':"Простые типы данных — byte, short, int, long, в примерах — введение в Java 002 #  Чтобы вызвать на экран что-то большее, чем \u0026ldquo;Привет, Мир!\u0026rdquo;, надо работать с числами, символами и буквами. Чтобы работать с ними в Java — надо научиться их хранить и передавать. Для этого нам надо познакомиться с понятием \u0026ldquo;типы данных\u0026rdquo;, а точнее \u0026ldquo;простые типы данных\u0026rdquo;.\nПростые типы данных — Java Primitives #  Существуют следующие базовые типы данных: byte, short, int, long, float, double, char, boolean и String (не совсем примитив, но базовый тип данных).\nЦелочисленные типы данных #  Мы начнём знакомство с базовыми типами данных с int.\nС помощью целочисленного типа данных, а именно так и переводится \u0026ldquo;integer\u0026rdquo;, мы храним в int целые числа. Для визуализации можно попробовать представить себе следующие примеры:\n Общепринятая нумерация домов во всем мире использует целые числа: ул. Грибоедова 15, ул. Каштановая 10, пятое Авеню 457 и т.д. Перекличка в классе тоже возможна с помощью типа данных int — первый, второй, третий, четвёртый\u0026hellip; Числа Фибоначчи: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\u0026hellip; Возведение одного простого числа в степень другого простого числа — например 2 в степени 7 = 128.    Целые числа   Давайте совершим пару арифметических действий на практике.\npublic class HalloInteger { public static void main(String[] args) { // Создаём переменные и присваиваем им значения  int a = 2; int b = 3; int c = a + b; System.out.println(\u0026#34;Сумма a и b = \u0026#34; + c); // Найдём периметр квадрата.  int d = 4; System.out.println(\u0026#34;Периметр квадрата со стороной d =\u0026gt; P = \u0026#34; + 4 * d); } } В Java есть несколько типов данных для хранения целых чисел, это — byte, short, int, long. Принципиально они различаются только размером. Для хранения числа в \u0026ldquo;int\u0026rdquo; надо 4 байта, если речь идёт о таблице Менделеева или о простых задачах, то мы можем обойтись и примитивным типом данных \u0026ldquo;byte\u0026rdquo;. Именно столько занимает места этот тип данных, 1 байт (byte) или 8 бит. Давайте посмотрим таблицу:\n   Тип Размер (бит) Диапазон     byte 8 бит от -128 до 127   short 16 бит от -32768 до 32767   int 32 бит от -2147483648 до 2147483647   long 64 бит от -9223372036854775808 до 9223372036854775807    2 в восьмой степени = 256. Именно столько можно запомнить в примитивном типе данных переменных byte. От -128 до 127 мы можем работать с любым числом в десятичной системе, включая ноль.\npublic class HalloLong { public static void main(String[] args) { long a = 7_456_678_678L; long b = 87_456_678_678L; long c = a + b; System.out.println(c); } } Нам надо помнить только, что byte — это 8 бит, short — 16 бит, int — 32 бита, long — 64 бита. Обычно возникают 2 вопроса. Какой тип данных использовать и зачем эти 4 типа \u0026ldquo;одинаковых\u0026rdquo; данных?\nРазные типы данных сложились исторически. Из-за особенностей x86-процессоров. Всё, что нам надо помнить — это экономия: размер ячейки для хранения, мы экономим место, процессорное время, RAM компьютера или прибора пользователя, и на планете не умирают котики.\nЕсли постоянно всё писать просто в long, то наша программа будет занимать неоправданно много места, она будет \u0026ldquo;есть\u0026rdquo; память и доставлять неудобства. И действительно, зачем использовать программу в 8 гигабайт, если можно сделать её, как минимум, в восемь раз меньше?\nЕщё раз для закрепления:\npublic class IntegerTypes { public static void main(String[] args) { byte a = 111; short b = 1111; int c = 7777777; long d = 2_358_765_649l; // Постфикс l или L обозначает литералы типа long.  // L нужна только за границами int.  // В Java можно использовать подчёркивания для визуального разделения чисел.  // 2_358_765_649 = 2358765649, для программы разницы нет.  System.out.println(a); System.out.println(b); System.out.println(c); System.out.println(d); } } Пример использования byte:\npublic class AdditionByte { public static void main(String[] args) { byte a = 10; byte b = 30; byte c = (byte) (a + b); System.out.println(\u0026#34;The c variable Value after Addition is : \u0026#34; + c); } } Если сложить два byte числа, которые в сумме дают больше 127, например 70 и 80, то мы получим не 150, а отрицательное число. Byte пойдёт в минусовые значения и будет считать дальше от -128. По кругу, в своём диапазоне из 256 возможных значений. Мир типа данных Byte — всего лишь один байт. Это его ограничение.\nОпределение, объявление, инициализация переменных #  Definition, declaration, initialization #  В Java переменная определяется и объявляется одновременно:\nshort b; Отделить эти понятия нельзя. Обычно в Java говорят только о декларации переменной, когда она просто объявляется:\n \u0026ldquo;Слушайте все!!! И не говорите, что не слышали! Мы объявляем, что от сего дня создана переменная B типа шорт\u0026rdquo;.\n В момент, когда мы присваиваем переменной значение, мы говорим об инициализации переменной.\n \u0026ldquo;Отныне переменная B получает графство и значение\u0026rdquo; 3.\n b = 3; Двоичные числа и не только #  Java позволяет хранить не только десятичные числа\nint hexValue1 = 0x100; // Шестнадцатеричная система счисления int binar = 0B1001_1001; // Двоичная система счисления int octal = 0757; // восьмеричная система счисления Домашнее задание #  Найдите применение каждому типу данных из заголовка и напишите программу с использованием byte, short, int, long:\n Найти площадь и периметр квадрата Найти площадь и периметр прямоугольника Найти площадь и периметр куба Найти количество зёрен на шахматной доске, если на первую клетку положить одно зёрнышко, на вторую клетку два зёрнышка, на третью в два раза больше, чем на предыдущей, то есть четыре и так далее.    шахматы   Дополнительные материалы #   Bit - https://en.wikipedia.org/wiki/Bit https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html Легенда о шахматах и зёрнах  Скачать статью в pdf-формате - тут\n"});index.add({'id':30,'href':'/school/java/exercises/20-exercises-java-arrays-03/','title':"20 - Array-3",'content':"Закрепление массивов, Java-Basic, Array-3 #   Consider the leftmost and righmost appearances of some value in an array. We\u0026rsquo;ll say that the \u0026ldquo;span\u0026rdquo; is the number of elements between the two inclusive. A single value has a span of 1. Returns the largest span found in the given array. (Efficiency is not a priority.) maxSpan([1, 2, 1, 1, 3]) → 4 maxSpan([1, 4, 2, 1, 4, 1, 4]) → 6 maxSpan([1, 4, 2, 1, 4, 4, 4]) → 6  Given a non-empty array, return true if there is a place to split the array so that the sum of the numbers on one side is equal to the sum of the numbers on the other side. canBalance([1, 1, 1, 2, 1]) → true canBalance([2, 1, 1, 2, 1]) → false canBalance([10, 10]) → true  Given n\u0026gt;=0, create an array with the pattern {1, 1, 2, 1, 2, 3, \u0026hellip; 1, 2, 3 .. n} (spaces added to show the grouping). Note that the length of the array will be 1 + 2 + 3 \u0026hellip; + n, which is known to sum to exactly n*(n + 1)/2. seriesUp(3) → [1, 1, 2, 1, 2, 3] seriesUp(4) → [1, 1, 2, 1, 2, 3, 1, 2, 3, 4] seriesUp(2) → [1, 1, 2]  Return an array that contains exactly the same numbers as the given array, but rearranged so that every 3 is immediately followed by a 4. Do not move the 3\u0026rsquo;s, but every other number may move. The array contains the same number of 3\u0026rsquo;s and 4\u0026rsquo;s, every 3 has a number after it that is not a 3, and a 3 appears in the array before any 4. fix34([1, 3, 1, 4]) → [1, 3, 4, 1] fix34([1, 3, 1, 4, 4, 3, 1]) → [1, 3, 4, 1, 1, 3, 4] fix34([3, 2, 2, 4]) → [3, 4, 2, 2]  Given two arrays of ints sorted in increasing order, outer and inner, return true if all of the numbers in inner appear in outer. The best solution makes only a single \u0026ldquo;linear\u0026rdquo; pass of both arrays, taking advantage of the fact that both arrays are already in sorted order. linearIn([1, 2, 4, 6], [2, 4]) → true linearIn([1, 2, 4, 6], [2, 3, 4]) → false linearIn([1, 2, 4, 4, 6], [2, 4]) → true  We\u0026rsquo;ll say that a \u0026ldquo;mirror\u0026rdquo; section in an array is a group of contiguous elements such that somewhere in the array, the same group appears in reverse order. For example, the largest mirror section in {1, 2, 3, 8, 9, 3, 2, 1} is length 3 (the {1, 2, 3} part). Return the size of the largest mirror section found in the given array. maxMirror([1, 2, 3, 8, 9, 3, 2, 1]) → 3 maxMirror([1, 2, 1, 4]) → 3 maxMirror([7, 1, 2, 9, 7, 2, 1]) → 2  (This is a slightly harder version of the fix34 problem.) Return an array that contains exactly the same numbers as the given array, but rearranged so that every 4 is immediately followed by a 5. Do not move the 4\u0026rsquo;s, but every other number may move. The array contains the same number of 4\u0026rsquo;s and 5\u0026rsquo;s, and every 4 has a number after it that is not a 4. In this version, 5\u0026rsquo;s may appear anywhere in the original array. fix45([5, 4, 9, 4, 9, 5]) → [9, 4, 5, 4, 5, 9] fix45([1, 4, 1, 5]) → [1, 4, 5, 1] fix45([1, 4, 1, 5, 5, 4, 1]) → [1, 4, 5, 1, 1, 4, 5]  Given n\u0026gt;=0, create an array length n*n with the following pattern, shown here for n=3 : {0, 0, 1, 0, 2, 1, 3, 2, 1} (spaces added to show the 3 groups). squareUp(3) → [0, 0, 1, 0, 2, 1, 3, 2, 1] squareUp(2) → [0, 1, 2, 1] squareUp(4) → [0, 0, 0, 1, 0, 0, 2, 1, 0, 3, 2, 1, 4, 3, 2, 1]  Say that a \u0026ldquo;clump\u0026rdquo; in an array is a series of 2 or more adjacent elements of the same value. Return the number of clumps in the given array. countClumps([1, 2, 2, 3, 4, 4]) → 2 countClumps([1, 1, 2, 1, 1]) → 2 countClumps([1, 1, 1, 1, 1]) → 1   © - codingbat.com\nПеревод 01 #  Условие задачи - ищем самый большой диапазон для любого элемента из массива, а не только для первого или последнего элементов.\nМассив может быть гораздо длиннее и бОльшее расстояние может находиться и в середине массива. Мы и ищем бОльшее расстояние между одинаковыми элементами на любых позициях.\n  Consider the leftmost and righmost appearances of some value in an array. Перевод: \u0026ldquo;Сравните самое левое и самое правое появление какого-либо значения в массиве. \u0026quot;\n  We\u0026rsquo;ll say that the \u0026ldquo;span\u0026rdquo; is the number of elements between the two inclusive. Перевод: \u0026ldquo;Назовём \u0026ldquo;интервалом\u0026rdquo; (span) количество элементов между двумя одинаковыми элементами, включая эти элементы.\u0026rdquo;\n  A single value has a span of 1. Returns the largest span found in the given array. Перевод: \u0026ldquo;У единичного значения интервал 1. Верните больший интервал в заданном массиве.\u0026rdquo; (Efficiency is not a priority.)\n  "});index.add({'id':31,'href':'/school/java/basic-course/003-java-float-double/','title':"3",'content':"Типы данных с плавающей точкой: float и double — введение в Java 003 #  Числа с плавающей точкой #  Для хранения дробных чисел в Java используют float и double. Правильное название — простые (примитивные) типы данных с плавающей точкой. Примитивные типы данных — byte, short, int, long, которые являются целыми числами, — мы рассматривали - здесь.\n  число Пи   Float #  Давайте сразу рассмотрим практический пример:\npublic class TestFloat { public static void main(String[] args) { float a = 3.5f; float b = 4.5F; float c = (float) 5.5; float d = a + b + c; System.out.println(\u0026#34;a+b+c: \u0026#34; + d); } } Здесь использованы три способа объявления переменных типа float. Самое важное при работе с ними — избавится от \u0026ldquo;запятых\u0026rdquo;. Java — американский язык программирования, и в американсой математике дробь отделяется точкой.\nDouble #  Давайте отдельно рассмотрим пример деления с целыми и дробными числами. Сначала целые числа:\npublic class IntDiv { public static void main(String[] args) { int a, b, c; a = 1; b = 10; c = a / b; System.out.println(c); } } При делении единицы на десять мы получаем ноль целых и, при использовании типа данных int, после и\u0026hellip; больше ничего не будет. Деление единицы на десять даёт ноль.\n- Сколько айфонов ценой в 1000€ я могу купить за 10€? - Ноль. За 10€ я куплю ноль айфонов. И за 999€ я куплю ровно ноль айфонов.  Результат деления целых чисел (тип данных int) округляется до меньшего целого числа. #  public class IntDiv { public static void main(String[] args) { double a, b, c; a = 1; b = 10; c = a / b; System.out.println(c); } } Но, если мы при инициализации переменных изменим их тип на double, то получим привычное нам 0.1.\nПредставьте, что вы купили десять метров ткани, и на костюм вам надо 7 метров. Сколько костюмов вы сошьёте из 10 метров? Один или полтора? В некоторых случаях нам абсолютно не нужны дробные (с плавающей точкой) числа, а в некоторых — целые.\nНа простейшем примере можно увидеть работу double ещё раз:\npublic class HalloDouble { public static void main(String[] args) { final double PI = 3.14; // final - используется для \u0026#34;финализации\u0026#34; переменной,  // теперь переменной PI нельзя присвоить другое значение.  double r = 5.5; double k = r * r; double s = PI * r * r; System.out.println(k); // промежуточный результат  System.out.println(s); } }    Тип Максимальное позитивное значение Минимальное позитивное значение Размер (бит)     float 3.4028234663852886E+038 1.4012984643248171E-045 32   double 1.7976931348623157E+308 4.9406564584124654E-324 64    Экспоненциальная запись #  Экспоненциальная запись — представление действительных чисел в виде мантиссы (дробной части логарифма числа) и порядка. Удобна при представлении очень больших и очень малых чисел, а также для унификации их написания.\n1_000_000 - один миллион: 1,0Е+6 соответствует один умножить на десять в шестой степени.  Что использовать нам в программе? Float или double #  У меня два ответа на этот вопрос.\nВариант один. Пока вы учитесь, используйте double. Он проще не требует буковок после цифры или дополнительного кастинга.\nВариант два. Производительность программы с float ровно в два раза выше, чем с double. Если вам важно делать свой код изящнее, то вы всегда должны понимать, какие типы данных уместнее использовать.\nДавайте попробуем сделать программу, которая считает степень двойки.\npublic class HalloDouble2 { public static void main(String[] args) { double a = 2; double b = 30; double c = Math.pow(a, b); System.out.println(c); // Выводит на экран 1.073741824E9  } } Достаточно интересный вопрос: что происходит при пересечении разных типов данных? Что произойдёт, если тип переменных int встретится с double? Я подготовил программу без единой строчки комментария. Попробуйте предугадать то, что Java выведет на экран.\npublic class IntToDouble { public static void main(String[] args) { int var1 = 5; int var2 = 2; int var3 = var1 / var2; double var4 = 5.0; double var5 = 2.0; double var6 = var4 / var5; double var7 = var1 / var2; double var25 = var1 / var4; System.out.println(\u0026#34;Int Var3 = \u0026#34; + var3); System.out.println(\u0026#34;double Var6 = \u0026#34; + var6); System.out.println(\u0026#34;double Var7 = \u0026#34; + var7); System.out.println(\u0026#34;double Var25 = \u0026#34; + var25); int var11 = (int) (var1 / var4); System.out.println(\u0026#34;Int Var11 = \u0026#34;+ var11); System.out.println(\u0026#34;Магия \u0026#34; + 5.0/var2); } } Результат работы IntToDouble:\n Int Var3 = 2 double Var6 = 2.5 double Var7 = 2.0 double Var25 = 1.0 Int Var11 = 1 Магия = 2.5  Результат работы подтверждает, что int находится в пределах double и легко может использоваться в расчётах, где результатом будет число типа double. К сожалению, обратное невозможно. Мы должны преобразовать тип данных — произвести Casting. Пример кастования из нашего IntToDouble: int var11 = (int) (var1 / var4), где int в скобках — и есть преобразование.\nПомимо вычисления степени числа, математическая библиотека Java (Math) предлагает нам метод, который генерирует случайное число. Дотошный разработчик скажет, что это не случайное число, а псевдослучайное, но на нашем уровне обучения псевдослучайности достаточно для работы в Java.\nДавайте, в качестве примера, сгенерируем число от 30 до 100:\npublic static void main(String[] args) { int min = 30; int max = 100; int result = (int) (Math.random() * (max - min) + 1) + min; System.out.println(result); } Метод Math.random() представляет результат в виде дробных чисел типа double. Нам нужны целые числа, поэтому мы \u0026ldquo;кастуем\u0026rdquo; результат в нужный тип данных.\nМетод Math.random() генерирует дробные числа между 0 и 1. Поэтому мы с помощью арифметики приводим случайное число между нулём и единицой в случайное число между 30 и 100. Попробуйте получить число между 1 и 50. Поэкспериментируйте с этим методом. Он нам понадобится не один раз.\nМетод Math.random() является одним из многих подготовленных для вас методов, которые часто требуются при программировании. Возведение в степень, число PI, логарифмы и многое другое. Вы можете ознакомиться с официальной документацией к библиотеке Math — здесь\nОстался, может быть, вопрос, что использовать? Если нет особой надобности в учебных целях или для скорости разработки — используйте double и int. Остальные типы данных требуют более бережного отношения и внимания.\nДомашнее задание #   Написать программу для вычисления площади круга. Найти длину окружности. Написать формулу вычисления стоимости Евро, если курс Евро к Доллару 1,1. Найти соотношение площади Беларуси к площади Украины. Найти, во сколько раз площадь Москвы больше площади Берлина. Если клиент положил в банк 1000€ под 3,5%, какая сумма будет его ждать через семь лет?  Дополнительные материалы #   Полезная библиотека - Math Конвенция java договор о правописании и синтаксисе Округление чисел - https://geekbrains.ru/posts/java_round  "});index.add({'id':32,'href':'/school/frontend/fe-exercises/03-exercises-html/','title':"3 - html основы",'content':"Задача № 3 #    Задача 3   Молчание золото #  Дана фотография, короткий заголовок. Создайте файл, как на примере.\nAssets #  Silence is golden #  Ссылка на изображение\n"});index.add({'id':33,'href':'/school/java/basic-course/004-java-char-string/','title':"4",'content':"Типы данных char и String: примеры применения — введение в Java 004 #  Char #    Таблица символов   Если в программе нужны символы, то для этого мы пользуемся типом данных char. Например:\npublic class HelloChar { public static void main(String[] args) { char zahl = 100; // Сотый по счёту символ в таблице  char octal = \u0026#39;\\u039A\u0026#39;; // Вызов определённого символа кодом  char zeichen = \u0026#39;A\u0026#39;; // Буква A  char tabulator = \u0026#39;\\t\u0026#39;; // В русском языке клавиша называется \u0026#34;Таб\u0026#34;  // Табулятор  char phi = \u0026#39;\\u03A6\u0026#39;; // Греческая буквая Фита - PHI  System.out.println(zahl); System.out.println(octal); System.out.println(zeichen); System.out.print(tabulator); System.out.println(phi); } } Объект базового (примитивного) типа char является 16-битным символом Unicode.\nМы можем вывести любое сообщение или любой символ. однако достаточно сложно вывести на экран кавычки, ведь в них мы и держим значения наших переменных. Для таких случаев мы используем экранирование. С помощью обратной косой черты(обратный слеш) мы экранируем символ или используем её для дополнительных параметров.\n\\b Backspace (Курсор двигается на одно место влево) \\n Newline (Новая строчка) \\f Newpage (Новая страница) \\r Carriage return (Курсор становится на первое место в строчке, возврат каретки) \\t Горизонтальный табулятор \\\u0026quot; Двойная кавычка \\' Одинарная кавычка \\\\ Backslash(вызов обратного слэша) \\___ Символы с октальным значением от 000 до 377, например \\304 соответствует символу Ä \\u___ Вызов символа уникода (Unicode-16). Где например \\u00C4 соответствует Ä Таблица символов Windows (charmap) вызывает и показывает именно те символы, которые можно вызвать в Java.\nString #  Мы можем хранить в программе и набор символов: пароль, фамилию, звание, название улицы или просто набор символов. Для хранения таких данных можно использовать String. Пример использования:\npublic class HelloString { public static void main(String[] args) { String firstname = \u0026#34;Andrej\u0026#34;; String secondname = \u0026#34;Podlubnyj\u0026#34;; char copyright = \u0026#39;\\u00A9\u0026#39;; int old = 18; System.out.println(firstname + \u0026#34; \u0026#34; + secondname + \u0026#34; \u0026#34; + old); String student = firstname + \u0026#34; \u0026#34; + secondname + \u0026#34; \u0026#34; + copyright; System.out.println(student); } } Один символ можно записать как \u0026ldquo;маленьким\u0026rdquo; стрингом, так и через символ при помощи типа данных char. Цепочку символов, больше одного, мы храним в типе данных String. Каждый элемент этой цепочки символов можно отобразить при помощи char. Это очень важно понять и запомнить.\nСтроковый набор символов класса String может немного больше, чем просто хранить строчку в переменной. Например, мы можем вычислить количество символов или длину String, используя один из методов, которые есть в Java. Это примерно такие же методы, как те, что мы использовали в предыдущих уроках, чтобы возводить числа в степень или выводить результаты на экран:\nint dlina; dlina = student.length(); System.out.println(dlina); Для переменных типа String ява заготовила много дополнительных методов, которые делают нашу жизнь проще. Например метод substring, который вырезает из одной цепочки символов другую.\nНапример:\npublic class WhatCanYouDoString { public static void main(String[] args) { String name = \u0026#34;AndrejPodlubnyj\u0026#34;; int dlina = name.length(); System.out.println(name); System.out.println(dlina); // вырезать символы с 6-го по 15-ый \tString firstName = name.substring(6,15); dlina = firstName.length(); System.out.println(firstName); System.out.println(dlina); } } Если мы пишем приложение для веб-сайта с \u0026ldquo;user generated content\u0026rdquo;, то мы можем столкнуться с тем, что часть контента пишется заглавными буквами. В Java есть методы, которые приводят цепочку символов алфавита к прописным (заглавным) или к строчным (маленьким) буквам. Давайте рассмотрим пример:\npublic class UppercaseAndLowercase { public static void main(String[] args) { String articleTitle = \u0026#34;london is the capital\u0026#34;; articleTitle = articleTitle.substring(0,1).toUpperCase() + articleTitle.substring(1); System.out.println(articleTitle); articleTitle = articleTitle.toUpperCase(); System.out.println(articleTitle); System.out.println(articleTitle.toLowerCase()); } } С помощью метода toUpperCase() мы делаем буквы прописными, с помощью метода toLowerCase() мы приводим значение строки к строчным буквам.\nМы обязательно вернёмся к этому и другим возможностям класса. Пока надо только запомнить, что, если мы хотим создать записную книжку, то фамилию и имя абонента мы скорее всего будем хранить с помощью типа данных String.\nЯвные и неявные преобразования #  Значения, передаваемые переменным, можно привести в тот тип данных, которые переменная может принять. Вручную или автоматически, или явно и неявно.\n  преобразование типов данных   Расширение типа (widening Casting), которое можно проследить на схеме с помощью стрелок, происходит автоматически. Это преобразование меньшего типа данных в типа большего размера: byte -\u0026gt; short -\u0026gt; char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double.\nСужение типа (narrowing Casting) — преобразование типа данных большего размера в тип данных меньшего размера — делается вручную: double -\u0026gt; float -\u0026gt; long -\u0026gt; int -\u0026gt; char -\u0026gt; short -\u0026gt; byte\npublic class MyClass { public static void main(String[] args) { int myInt = 9; double myDouble = myInt; // Automatic casting: int to double  System.out.println(myInt); // Outputs 9  System.out.println(myDouble); // Outputs 9.0  } } public class MyClass { public static void main(String[] args) { double myDouble = 9.78; int myInt = (int) myDouble; // Manual casting: double to int  System.out.println(myDouble); // Outputs 9.78  System.out.println(myInt); // Outputs 9  } } Повышение типа на примере\npublic class Main { public static void main(String[] args) { byte b = 42; char c = \u0026#39;a\u0026#39;; short s = 1024; int i = 50_000; float f = 5.67f; double d = .1234; double result = (f * b) + (i / c) - (d * s); System.out.println((f * b) + \u0026#34; + \u0026#34; + (i / c) + \u0026#34; - \u0026#34; + (d * s)); System.out.println(\u0026#34;result = \u0026#34; + result); } } Допустим, у нас имеется старая база данных, где все данные записаны в строковом виде. Например просто текстовый файл столбиком. Java даёт нам возможность \u0026ldquo;спарсить\u0026rdquo; целочисленные данные из строк.\nString number = \u0026quot;10\u0026quot;; int result = Integer.parseInt(number); System.out.println(result); Дополнительные материалы #   По ссылке можно посмотреть все методы, которые поддерживает тип данных String.  Домашнее задание #   Найти в интернете таблицы для типа данных char. Проверить, что они действительно соответствуют тому, что выводит Java на экран. Найти \u0026ldquo;смешные\u0026rdquo; символы, символ стандартного смайлика, найти символ телефона, параграфа, копирайта(C), торговой марки(тм), рубля, евро, доллара, знаков зодиака, шахмат, червы. Вбить в поисковую строку Windows \u0026ldquo;charmap\u0026rdquo;. Найдите самостоятельно статьи на тему:  Что такое юникод? Что такое ASCII? Что такое UTF?   Что будет, если \u0026ldquo;сложить\u0026rdquo; переменную String с самой собой? Можно ли умножить её на саму себя? Почему? Вывести на экран сообщение в кавычках. Например собственное имя + \u0026ldquo;профессия\u0026rdquo;. Вывести на экран построчно анкетные данные: Имя, Фамилия, Адрес, Улица и тд и тп. Пример вывода одной строчки:   Имя пользователя: Андрей\n   Вырезать из выражения \u0026ldquo;Вход разрешён\u0026rdquo; последние 8 символов и добавить \u0026ldquo;воспрещён\u0026rdquo;. Вывести на экран \u0026ldquo;Осторожно, вход воспрещён\u0026rdquo; заглавными буквами.  "});index.add({'id':34,'href':'/school/frontend/fe-exercises/04-exercises-html/','title':"4 - html основы",'content':"Задача № 4 #  Название задачи #  Assets #  "});index.add({'id':35,'href':'/school/frontend/fe-exercises/05-exercises-html/','title':"5 - html основы",'content':"Задача № 5 #  Название задачи #  Assets #  "});index.add({'id':36,'href':'/school/database/05-sql-select-requests/','title':"SQL запросы",'content':"SQL запросы #  Gegeben ist die folgende Artikel-Tabelle. Nachfolgend wird diese Tabelle mittels Select-Anweisung abgefragt.\n   id bezeichnung farbe einkaufsPreis lieferant bestand     114629 Kaschmir Rosé 6,95 Lana Grossa 386   114670 Cotonara Weiß 4,95 Lana Grossa 124   114324 Eco Vitas Hellgelb 3,50 ONline 956   114339 Cotton Baby Apricot 2,95 ONline 45   112999 Kaschmir Anthrazit 11,95 Junghans 39   111072 Cotonara Beige 2,95 Junghans 428    https://web.archive.org/web/20180830073915/http://angelika-lorenz.de/pages/03select.php\thttps://habr.com/ru/post/480838/\n"});index.add({'id':37,'href':'/school/java/oop-course/012-java-string-stringbuffer-stringbuilder/','title':"StringBuffer, StringBuilder и String в чём отличие",'content':"#String, StringBuffer и StringBuilder — Java OPP 12\n(В разработке)\nНас уже не должны пугать ключевые слова с большой буквы. Нам известны как минимум два из них String и Scanner. StringBuffer и StringBuilder родные братья уже давно изученного типа данных String.\nЧем был плох String? #  String всем прекрасен, только он неизменяем (immutable). И операции со строковыми величинами иногда дороги в потреблении ресурсов. Например, если мы в цикле изменяем строку добавляя к ней символы. Java каждый раз создаёт новый String. Пример:\npublic class MyString { public static void main(String[] args) { triangle(10); } private static void triangle(int n) { String star = \u0026#34;*\u0026#34;; String row = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; n; i++) { row = row + star; System.out.println(row); } } } Короткая рекомендация - использовать String для редко изменяемых переменных. Например для имени, фамилии, адреса пользователя.\nStringBuffer и StringBuilder, почему сразу два новых типа? #  StringBuffer и StringBuilder абсолютно идентичные классы и их следует использовать для часто изменяемых строк. Различие в том, что\nStringBuffer синхронизированный(synchronized) и потокобезопасный. StringBuilder однопоточный и не потокобезопасный.\nЧто такое синхронизация, коротко #  Представьте, что вы пишите приложение для продажи ЖД-билетов. И вы не можете дважды продать одно место. Синхронизация блокирует метод, если один из потоков его запустил. То есть в многопоточном приложении доступ к продаже ведётся поочерёдно. В однопоточном приложении доступ разрешается всем сразу. Совсем коротко, синхронизация более дорогая в ресурсах, но по другому проблему доступа решить не всегда возможно.\nДополнительные материалы #   https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java https://metanit.com/java/tutorial/7.3.php  "});index.add({'id':38,'href':'/school/frontend/html/04-html-tags/','title':"test",'content':"HTML теги #  Мы уже говорили про структурные элементы. Это те теги, которые размечают структуру текста.\nСтруктурные теги #     Название Короткое пояснение     body Содержит весь контент страницы.   main Главное уникальное содержимое страницы. Используется в документе только один раз.   header \u0026ldquo;Шапка секции/документа\u0026rdquo;. Важная вводная информация. В html5 разрешено многократное использование на одной странице.   footer Заключительная часть секции. Может включать в себя, к примеру, автора статьи, дату статьи.   nav Важная навигация сайта.   article Статья. Самостоятельная часть документа.   section Несамостоятельная часть документа. Например анонсы статей с заголовками на главной.   aside Обычно боковая колонка, в которой содержится часть документа.   address Контактные данные. Дочерний тег article или body.    Блочные теги #  Блочные элементы — занимают всю ширину страницы, а по высоте определены его содержимым. К блочным HTML-тегам относятся: address, blockquote, div, fieldset, form, h1 - h6, hr, , p, pre, table, ul.\nИз всего этого списка два тега являются наиболее часто употребляемы. Это p - параграф или абзац, и div - блок с содержимым, который описывается отдельно.\nСтрочные теги #  Строчные элементы — это те теги, которые используются внутри блока, внутри строки. Это к примеру: img, span, a, q, code, b, strong, em, i.\nЯ привёл наиболее часто употребляемые теги. Без ссылок, фотографий и выделений текста интернет тяжело себе представить.\nВсе остальные теги #  Существует более сотни HTML-элементов: article, aside, details, figcaption, figure, footer, header, main, mark, nav, section, summary, time и прочие.\nНе уверен, что их все надо знать наизусть. Но один раз ознакомиться с каждым из них стоит.\nЯ собрал пару ссылок, где подробнее обсуждаются большинство из тегов. Постепенно, шаг за шагом, мы рассмотрим некоторые из них.\nДополнительные ссылки #   Категории контента HTML Element Reference Все элементы HTML - developer.mozilla.org Все HTML элементы - w3.org HTML5 best practices; section/header/aside/article elements - вопросы по размещению одних тегов в других.  "});index.add({'id':39,'href':'/school/tools/04-how-to-create-passwords/','title':"Как правильно создавать пароли",'content':"Немного о паролях, или как их правильно создавать\n  -Вы слабое звено! И вы выбываете из игры!\n  Можно добавить ещё пару анекдотов, чтобы правда жизни не так резала по сердцу.\nОднако. Здравствуйте. При самом крутом алгоритме шифрования пароль \u0026ldquo;мама\u0026rdquo; вскрывается за одну секунду. Также не стоит ставить паролем свой день рождения. Если бы вы знали сколько мужей погорело на различных Love-порталах, выбравших свой день рождения паролем. А недовольных дворецких и секретарш на пенсии, тоже ещё никто не удосужился отменить.\nА ведь в нашем окружении немало людей, знающих наши привычки и пристрастия. Поэтому просто перейдём к тому как правильно создавать пароли.\nУровень сложности пароля #  У любого из нас уже могла возникнуть ситуация, когда нам проходилось сообщать пароль от какой-либо системы (емайл, банк, компьютер, программа и тд и тп) своим близким или коллегам. В наш информационный век с десятком емайлов и форумов, аккаунтом к Ebay, интернет доступом к своему банку и паролем на \u0026ldquo;вторую\u0026rdquo; бухгалтерию тяжело, даже очень тяжело придумывать в каждом отдельном случае новый пароль. И очень часто неплохой пароль используется везде. Один и тот же. Не всегда есть возможность сказать решительное: \u0026ldquo;Нет. Я не дам тебе свой пароль\u0026rdquo;. А к чему может это привести, каждый из должен понимать сам.\nИтак. Имеет смысл ввести пяти или десяти бальный приоритет паролей. Чем выше приоритет, тем он для вас важнее.\nДесятибалльная система приоритетов для паролей #   Пароль на пароли. Записная книжка с кодом или маленький контейнер с личными данными и записной книжкой с паролями от всего , где у нас есть пароль. Пароль на модуль шифрования в личной или деловой переписке. Пароль на контейнер с защищённой информацией (разница с пунктом 10 в размере). Доступ к компьютеру Пароль к электронной почте (емайл) Банковский пароль Пароли к сервисам с оплатой (ebay, online-shops итд и тп) Пароли к Facebook, Instagram, Telegram, Icq, Msn, Skype и тд и тп. Пароли к развлекательным порталам и форумам Пароль на фотографии с последней вечеринки.  Приоритеты каждый расставляет сам, и просматривая эту таблицу, выясняется, что кроме последней вечеринки, вся остальная информация не предназначена для других глаз.\nОднако. Здравствуйте. Как тогда получается, что пароль с самым высоким приоритетом является фамилией той девочки, что сидела с вами в первом классе за одной партой, а у компьютера вообще нет пароля и вся информация лежит абсолютно открыто?\nПри аккуратном разделении типа информации/паролей, намного легче менять скомпрометировавшие себя пароли. И мы избежим цепной реакции при возможном нападении.\nА вот как узнать скомпрометировал себя пароль или нет? И как часто нужно менять пароли?\nСмена пароля. Как часто? #  Скомпрометированные пароли сразу. Скомпрометированным паролем считается пароль, который записан на бумажку и приклеен к монитору, либо носится в портмоне. Также скомпрометированы те пароли, которые кроме вас знает ещё один человек.\nЗависит от ценности информации. К примеру, в Skype или ICQ я не менял пароль уже лет 10. Потеря логина или УИНа не отразится на моих контактах и финансах. Скорее испортится настроение на 6,5 минут. Естественно, если у кого то супер-элитный 5-значный уин с френдлистой на всю женскую сборную по синхронному плаванию России, то пароль стоит менять хотя бы раз в год.\nИ приоритет пароля повышается до пункта 2, а то и 1. Пароль на пароли я тоже на самом деле не менял ни разу. Пользуюсь им я редко, а бэкапов от контейнера с паролями много. И вот тут один из радикальных вопросов криптологии.\nПодавляющее большинство специалистов и сисадминов регулярно советуют, либо заставляют менять пароли. Правильно замечая, что пароли со временем компрометируются самыми различными способами и ухищрениями. От банального воровства пароля, до глупости юзера, когда он использует рабочий пароль для входа во все форумы и чаты.\nОднако. Здравствуйте. Регулярная смена паролей приводит к тому, что юзеры записывают их на бумажках и телефонах, визитных карточках и просто на мониторе. Если раньше в до-интернетовскую эру, мы не удивлялись ходячим записным книжкам, в головах которых были записаны все телефоны знакомых, то сейчас мозг почти не тренируется, любая информация либо записана в кпк, либо есть в сети. И просто запомнить девятизначный номер телефона уже становится экзаменом для многих. Поэтому я рекомендую:\nПароль для доступа к рабочей станции(компьютер) не должен быть более чем двухсложным и оптимально 8-12 знаков.\nПримеры: #   trzg457fg - цифры и маленькие буквы. GDUI?!:ZH- большие буквы и спецзнаки.  По договорённости, юзер сам должен иметь право придумывать себе пароль. К примеру, если пароль больше 30 знаков. В качестве хорошего примера (до того как он здесь был опубликован.\n  kak_by_ya_hotel_zarabatywat_w_mesac_milion_dolarow\n  Рекомендации для сис-админов и фирм с ценными данными #   Обязательно ознакомить всех сотрудников с принципами защиты, хранения и обработки информации.\nПонимая хотя бы основы криптологии, можно избежать многих ошибок. Классификация прав на доступ к информации по степени секретности(от „секретно в стадии разработки“, до „совершенно секретно“- при разглашении уголовное преступление Роспись каждого сотрудника об ознакомлении и исполнении требований по защите информации, подкреплённое организационными и дисциплинарными мерами, при нарушении этих требований.\nТакая роспись о неразглашении творит поистине чудеса. Желательно провести ликбез на тему „защита информации, трояны, вирусы, программы шифрования и взлома“ и сдача тематического зачёта. Иметь в штате специалиста, профессионально разбирающегося в криптологии. Стараться использовать то программное обеспечение, в котором есть 100% уверенность. Анализ действий вероятного противника (конкурента). Грамотно использовать программы защиты и по возможности избегать „сертифицированных“ в США или России программ. Использовать программы с открытым алгоритмом работы. Использовать такие настройки операционной системы, которые предотвращали бы „заражение“ компьютера или тем паче всей фирмы через интернет или электронную почту. Дополнительно разработать комплексную стратегию защиты информации на вашем предприятии. Лучше поручить такую задачу сторонним специалистам. Например - мне. Провести \u0026ldquo;испытание\u0026rdquo; имеющихся у вас средств защиты информации, поручив стороннему специалисту испробовать на прочность вашу защиту.  "});index.add({'id':40,'href':'/school/java/basic-course/025-java-idea-basics/','title':"Настройка, горячие клавиши, debugging в IntelliJ IDEA",'content':"IntelliJ IDEA — настройка, горячие клавиши, debugging — введение в Java 025 #  (В разработке)\nСегодняшний программист очень сильно отличается от программиста 90-х.\nБлокноты сменились мощными инструментами, которые подсказывают нам даже эффективные методы решения. Порой, кажется, что ещё чуть-чуть и людям точно не надо будет учить программирование, потому что Idea сделает всё сама.\nНо пока этого не случилось нам стоит потратить немного времени на настройку самого главного инструмента, в котором мы пишем код. Idea может очень многое. Очень. В этой главе мы рассмотрим несколько горячих клавиш, некоторые типы подсказок и базисные вещи, которые нам предлагает рефакторинг и дебаггинг.\nДавайте на секунду отвлечёмся от самого кодинга и попробуем настроить наш инструмент для работы с Java и подтянуть наши скилы для работы с ним.\n  Отладка программы в intellij idea   Рефакторинг #  Alt + F6 — одна из самых полезных функций рефакторинг. Переименование переменной во всём коде программы, сколько бы раз она не упоминалась.\nДля этого надо выделить название метода, класса или переменной и вызвать из контекстного меню или горячими клавишами безопасное переименование. Очень удобно и для тех случаев, когда класс создан с грамматической ошибкой. IDEA переименовывает и файл и класс одновременно.\n  Безопасное переименование переменных   Не только hotkeys #  Горячие клавиши очень полезны в работе, но всё же не все функции доступны через клавиши.\nСтоит выделить время и посмотреть что может программа: подобрать цветовую гамму, шрифты и их размер, научиться делить окна на рабочие зоны.\nКак открыть одновременно 2 класса в IDEA? #  Например мы можем работать одновременно в нескольких классах (файлах). Эта функция доступна нам, если мы правой кнопкой нажмём на вкладку файла в окне, а затем на \u0026ldquo;Split Vertically\u0026rdquo; или \u0026ldquo;Split Horizontally\u0026rdquo;. Это очень удобно, когда программа состоит из больше, чем одного класса.\n  Разделить окно IDEA   Как добавить плагин в intellij idea? #  File -\u0026gt; Settings -\u0026gt; Plugins здесь можно посмотреть, что уже установлено или добавить новый полезный плагин.\nНапример мне оказался очень полезен плагин Grazie - проверка орфографии.\n  Grazie - проверка орфографии   Проверка правописания в Intellij Idea для русского текста #  File -\u0026gt; Settings -\u0026gt; Editor -\u0026gt; Proofreading\nЗдесь можно добавить те языки, которые нужны в работе над кодом и документацией.\n  Настройка проверки орфографии в IDEA   Горячие клавиши #  \u0026ldquo;Alt + h + k\u0026rdquo;. В Idea есть возможность вызвать помощника по горячим клавишам \u0026ldquo;Alt + h + k\u0026rdquo; открывает pdf файл, где описаны поддерживаемые вызовы.\nНастройка консоли #  Порой выдача в консоли не всегда очевидна или понятна. Или требуется пересчитать элементы. \u0026ldquo;CTRL + F\u0026rdquo; поможет нам в поиске определённых символов или слов и подсветит их.\n  Поиск результата в консоли   Отладка программы #  Отладка Java кода в IDEA. Основные возможности отладчика.   "});index.add({'id':41,'href':'/school/java/basic-course/024-java-swap-two-variables/','title':"Обмен значений переменных в Java",'content':"Обмен значений переменных — введение в Java 024 #  Допустим у нас есть переменная A со значением 5 и переменная B со значением 3. И нам нужно поменять значения у переменных местами. Это достаточно часто используемая операция и есть далеко не один способ её реализации.\nint a = 5; int b = 7; int temp = a; a = b; b = temp; Мы создаём дополнительную переменную. Передаём ей временно для хранения значение A, в само A передаём значение B. В B присваиваем значение, которое у нас хранится во временной переменной.\nСуществуют способы поменять их местами не создавая новую переменную.\npublic class Main { public static void main(String[] args) { int a = 5; int b = 3; // меняем местами пошагово  a = a + b; b = a - b; a = a - b; // меняем местами в одну строчку.  a = a + b - (b = a); // меняем местами пошагово с помощью XOR  a = a ^ b; b = b ^ a; a = a ^ b; } } Вариант с созданием дополнительной переменной легко читаемый и понятный всеми вариант.\nДомашнее задание #   Попробуйте дополнительно поменять местами переменные используя другие арифметические операторы.  "});index.add({'id':42,'href':'/school/frontend/html/03-html-path/','title':"Относительные и абсолютные пути - введение в HTML",'content':"Относительные и абсолютные пути #  С HTML у нас будет очень много различных файлов и папок, и изображений, и стилей. Поэтому нам надо понять как именно можно указывать месторасположение наших ресурсов.\nЧетыре варианта, которые указывают на то, где лежит файл.\n1. \u0026#34;styles.css\u0026#34; 2. \u0026#34;./styles.css\u0026#34; 3. \u0026#34;./../styles.css\u0026#34; 4. \u0026#34;/my_styles/styles.css\u0026#34; 5. \u0026#34;http://www.povar.eu/style.css\u0026#34; 6. \u0026lt;a href=\u0026#34;#\u0026#34;\u0026gt;Empty link\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; 7. \u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;home\u0026lt;/a\u0026gt;  Первый и второй вариант пытаются указать на один и тот же файл, который лежит в этой же папке. Третий вариант ищет файл на один уровень выше. Четвёртый в подпапке my_styles Пятый вариант указывает абсолютный путь в интернете. Шестой вариант - пример пустой ссылки на сайте. Заглушка во время создания. Пример ссылки на корень сайта.  Пример в HTML #  Интернет построен на ссылках из одних документов на другие документы. Давайте рассмотрим пример.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Пример ссылки в HTML\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Здесь я хочу поставить ссылку на \u0026lt;a href=\u0026#34;https://andron13.de/\u0026#34;\u0026gt;свой собственный сайт\u0026lt;/a\u0026gt;. Что бы на примере показать как в HTML делают ссылки\u0026lt;/p\u0026gt;. \u0026lt;p\u0026gt;А вот вторая ссылка на другой сайт в интернете - \u0026lt;a href=\u0026#34;https://povar.eu/\u0026#34;\u0026gt;сайт повара\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;. \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Нюансы #  Данный синтаксис ссылок и написание путей(path) используется не только в ссылках на внутренние или внешние ресурсы, но и на другие файлы используемые в проекте: css, js, java, php и прочие.\nДополнительные ссылки #   Спецификации ссылки по стандартам HTML  "});index.add({'id':43,'href':'/school/java/basic-course/027-java-sorting-algorithms-01-bubblesort/','title':"Пузырьковая сортировка — Bubble Sort. Алгоритмы сортировок.",'content':"Алгоритмы сортировок, Bubble Sort — введение в Java 027 #    массив требующий сортировки   Представьте себе ситуацию, что вы просите свой компьютер отсортировать фотографии по размеру или занимаемому месту, товары на странице магазина по цене и новости на сайте по дате написания.\nВсе эти данные, массивы информации сортируются. Сейчас мы попробуем написать простейший алгоритм сортировки массива состоящего из чисел.\nПузырьковая сортировка #  В пузырьковой сортировке мы по очереди просматриваем попарно весь массив. Для визуализации можно ещэ раз посмотреть прекрасный танец\n  Названа сортировка так потому, что цифры \u0026ldquo;всплывают\u0026rdquo; меняясь местами.\n  Пузырьковая сортировка или Bubble sort   Bubble Sort и рекурсия #  import java.util.Arrays; public class BubbleSort { static void bubbleSort(int[] arrUnsort) { int count = 0; for (int i = 0; i \u0026lt; arrUnsort.length - 1; i++) if (arrUnsort[i] \u0026gt; arrUnsort[i + 1]) { int temp = arrUnsort[i]; arrUnsort[i] = arrUnsort[i + 1]; arrUnsort[i + 1] = temp; count++; } if (count \u0026gt; 0) { bubbleSort(arrUnsort); } } public static void main(String[] args) { int[] myArr = {104, 64, 34, 25, 12, 22, 11, 90}; bubbleSort(myArr); System.out.println(Arrays.toString(myArr)); } } Bubble Sort без рекурсии #  public static void bubbleSort(int[] array) { boolean unsorted = true; int temp; while (unsorted) { unsorted = false; for (int i = 0; i \u0026lt; array.length - 1; i++) { if (array[i] \u0026gt; array[i + 1]) { temp = array[i]; array[i] = array[i + 1]; array[i + 1] = temp; unsorted = true; } } } } Пузырьковая сортировка строковых значений по алфавиту #  import java.util.Arrays; public class Main { public static void main(String[] args) { String name = \u0026#34;Andrej\u0026#34;; String[] array = name.split(\u0026#34;\u0026#34;); System.out.println(Arrays.toString(bubbleSort(array))); } public static String[] bubbleSort(String[] array) { int count = 0; for (int i = 0; i \u0026lt; array.length - 1; i++) { if (array[i + 1].toLowerCase().compareTo(array[i].toLowerCase()) \u0026lt; 0) { String tempStr = array[i]; array[i] = array[i + 1]; array[i + 1] = tempStr; count++; } } if (count \u0026gt; 0) { bubbleSort(array); } return array; } } Рекурсия #  Некоторые алгоритмы можно описать очень просто - выполняй, пока соблюдается условие. Порой вместо цикла уместнее использовать рекурсию.\nРекурсия - определение метода через саму себя.\nРекурсия в алгоритмах сортировки будет использоваться достаточно часто и охотно. Стоит потратить время на укрепление материала.\n Рекурсия, 17-yj урок Домашнее задание и закрепление материала - рекурсия. Занимательные задачки Как работает рекурсия – объяснение в блок-схемах и видео Просто для ознакомления - рекурсивное программирование  Дополнительные материалы к пузырьковой сортировке #   Пузырьковая сортировка и все-все-все Очень важный материал для самостоятельного изучения - двоичное дерево поиска Сортировка пузырьком https://www.baeldung.com/java-bubble-sort  Дополнительные материалы для ознакомления и расширения кругозора #   Алгоритм сортировки Блочная сортировка  "});index.add({'id':44,'href':'/school/frontend/html/01-html-intro/','title':"Уроки HTML и CSS Online",'content':"Веб-девелопмент — пособие для начинающих #  Предисловие #  Свой первый сайт я сделал ещё в 96-м году. Просто скопировав исходники с сайта модного компьютерного журнала и поставив их на свой. Принципиально это не самый плохой способ. Подсмотреть и сделать лучше. Что бы понять как это работает — просмотр чужих примеров просто обязателен.\nПоследние пару лет слово пример практически не используется в моём IT-круге. Принято говорить кейсы, кейс клиентa, пользовательский кейс. И это важная черта компьютерных разговоров. Очень много англицизмов. Невозможно перевести всю документацию на языки пользователей. Английский как язык технического документооборота принят на многих фирмах, где англичан к примеру никогда и не было, да и команда разработки к примеру - русская. В одной из таких фирм меня шеф бил по рукам за комментарии в коде на русском языке.\nАнглийский #  Это я к тому, что если вы не выучите английский, то шансов стать хорошим разработчиком у вас нет. И мы подошли к главному - для кого это пособие. Сейчас, когда написана только первая глава, я вижу, что книга должна помочь взрослому человеку разобраться в мире веб-технологий. То есть это пособие для меня в прошлом, когда я не знал с чего начинать учить Frontend.\nВполне возможно, что оно поможет и редакторам сайтов, которые не собираются углубляться в веб-строительство, а просто хотят хорошо делать свою работу. Как минимум для вас, моих коллег-редакторов я и сделал обзор тегов HTML и их возможностей. Один раз ознакомиться с этим списком важно для любого человека, который пишет в этом вашем интернете.\nНадеюсь это пособие поможет и тебе.\nHTML и 2019 год #  Официально интернет пришёл в разные страны по разному.\nНациональные доменные зоны #     Домен Назначение Дата появления     COM Коммерческие для всех 1 января 1985   US США 15 февраля 1985   DE ФРГ 5 ноября 1986   SU Советский Союз 19 сентября 1990   UA Украина 1 декабря 1992   RU Россия 7 апреля 1994   BY Республика Беларусь 10 мая 1994    В 95-м году интернет на территории бывшего СССР стоил больших денег и был скорее доступен сотрудникам научно-технических организаций и студентам высших учебных заведений. В это же время в странах западной Европы и США были уже частные интернет провайдеры, которые предлагали доступ для частных лиц из дома. В Германии на тот момент час \u0026ldquo;звонка\u0026rdquo; с модема на модем внутри города стоил около 5 немецких марок(2,5€).\nКак мы видим интернет тогда был и на Западе уделом богатых или умных, или умных и богатых. Так он и развивался, медленно, лишь постепенно становясь доступным массовому пользователю и бизнесу. Развиваясь, в нём появлялись деньги, исполнители, знания, новые требования, новые возможности. И он менялся; прокладывались новые линии, придумывались новые языки, библиотеки, методы решения проблем и \u0026hellip; снижался порог входа.\nТо, что мы сегодня называем интернетом очень и очень отличается от того, что называли интернетом в 1994 году.\n HTML5 - сегодняшний стандарт интернета - принят в 2014 году. CSS3 - существует с 2000 года. React, который используется сейчас чуть ли не на 80% новых сайтов вообще придуман в 2014 году.  Технологии действительно новы и вместе с вами их учат и \u0026ldquo;бывалые\u0026rdquo; программисты. Так что это примерно как с правилами дорожного движения. У старых водителей есть опыт, у новых водителей знания. И где-то за два года работы каждый новенький становится стареньким.\nЭто всё просто #  Нет, серьёзно! Это всё несложно. До определённой степени. Ну так же несложно как писать красивые письма, делать презентации или отсылать письма.\nHypertext Markup Language #  HTML (Hypertext Markup Language) - не язык программирования, а язык разметки. С помощью него нельзя вычислить траекторию полёта, предсказать погоду на завтра или смоделировать поведение человека. Это просто правила отображения текста на экране.\nЧто мы должны понять и запомнить? C помощью HTML мы указываем параметры текста, что является заголовком, что чужой цитатой, что считать аббревиатурой, а что статьёй. Указателей для текста или правил много, больше сотни. Но все их можно выучить за неделю. С учителем. Без учителя до месяца. Даже мне понадобился всего месяц, что бы с нуля пройти весь HTML5. А мне уже за 40, плохое зрение, одышка и желание учиться новому так себе, на самом деле. Я к чему? — это действительно несложно. Это HTML.\nСуществует множество способов разметки текста. Ваш простой ворд-файл тоже сохраняется в одной из таких разметок. В этом пособии я коснусь HTML, XML, Markdown. Первых два - общепринятые способы хранения \u0026ldquo;компьютерных данных\u0026rdquo;. Markdown — один из самых популярных, на данный момент, способов написания документации. Помимо HTML мы коснёмся достаточно подробно CSS и совсем немного JavaScript, чисто что бы понять, что это такое.\nДавайте начнём!\nРедактор HTML #  При обучении любой компьютерной технологии первым уроком учат писать Hello World!\nЯ не могу бросить вызов сложившийся культуре, но первым делом нам придётся выбрать инструменты где мы будем это писать.\n   Название эдитора Короткое примечание     Atom Очень приятный и достаточно популярный эдитор от платформы Github (это слово надо знать - Github)   Sublime Text Очень популярный редактор у маководов.   Visual Studio Code Очень, очень годный продукт от Microsoft. В нём я пишу это пособие   WebStorm Раньше был бесплатен. На данный момент для студентов есть возможность бесплатного использования. Практически обязателен к установке. Jetbrains продукты внешне очень похожи между собой. У меня он установлен, как и все выше перечисленные редакторы.   Notepad++ Любимый редактор моей жены. Сам, я лично не использую этот реактор, потому что он мне напоминает встроенный windows-редактор. Но должен сказать, что Notepad++ популярен и среди разработчиков. И очень неплох.    Вы можете установить все эти редакторы и перепробовать их по очереди. Работать с ними одновременно или разделить их по языкам. Например, я использую \u0026ldquo;Visual Studio Code\u0026rdquo; для написания документации к софту и в нём у меня очень много плагинов. В Webstorm пишу уже непосредственно сайты, а Sublime у меня без плагинов, очень лёгкая и его я запускаю часто вторым редактором. Выберете свой редактор из списка или спросите друзей. Кстати очень неплохой совет. Редакторы в 2019 году достаточно сложны. И настроить для повседневной работы получится далеко не сразу. Лишний совет никогда не помешает. Спросите, чем пользуются ваши друзья.\nРабочая папка и домашняя директория #  Во-первых, давайте создадим папку в которой вы будете работать. Например в домашней директории папку \u0026ldquo;HtmlLessons\u0026rdquo;. И уже здесь у вас могло возникнуть два вопроса: что такое домашняя директория и почему не \u0026ldquo;html-lessons\u0026rdquo;.\nДомашняя директория под Виндовсом обычно c:/users/\u0026ldquo;имя пользователя\u0026rdquo; и в компьютерной терминологии обозначается просто значком тилда — \u0026ldquo;~\u0026rdquo;, потому что в терминале в неё попасть можно через тилду. Под Линуксом разумеется можно попасть через тилду. Под Виндовсом тилда вызывает домашнюю директорию только в линуксоподобном теминале, например Bash. Который вам тоже придётся рано или поздно поставить, потому что иначе вы не научитесь работать с Git(вы же запомнили слово GitHub вверху?).\nБез упоминания слов Linux, Bash, Git стать программистом сложно. По этому лучший совет от меня - выписывать все оставшиеся непонятными слова и искать их в поиске. Языки программирования мало чем отличаются от обычных иностранных языков. Кому-то они даются легко, а кому-то сложно. Если вы из второй категории, то сжимаем зубы и зубрим.\nGit #     Термин Ссылка Пояснение     Git https://git-scm.com/downloads Git - это очень популярная технология контроля версий, используемая при разработке програмного обеспечения и веб-приложений. Онлайн инструкция на русском языке   Github https://github.com/ Популярный сервис для хранения Git-репозиториев. С 2018 года принадлежит Microsoft   Bitbucket https://bitbucket.org/ Популярный сервис для хранения Git-репозиториев. Принадлежит Atlassian и очень тесно интегрирован с популярными IT-приложениями этой формы как Trello или Jira   Gitlab https://gitlab.com/ Альтернативный сервис для хранения Git-репозиториев.    Вам не надо скачивать и ставить всё это сразу. Но когда первый страх пройдёт, когда вы начнёте разбираться с HTML - вернитесь и попробуйте разобраться с GIT. Мне на это понадобилось несколько попыток. Примерно с пятой я начал разбираться и не вздрагивать при слове Git.\nЯ не мог не сказать про тилду, линукс, bash-терминал и Git. Уже более чем в половине видеоуроков для начинающих люди показывают всё с маков или линуксов и активно используют \u0026ldquo;~\u0026rdquo; не объясняя что это. Это очень важное сокращение, которое я тоже активно буду использовать. Потому что для меня WEB - это мир иксов(Linux, Unix, Mac OS X).\nОчень краткая методичка по работе с Git.\nКебаб из верблюдов и змей #  Второй вопрос, который у вас должен был возникнуть почему папка названа большими и два слова не разделены минусом. Вопрос очень хороший. Спасибо Андрей, что задал его. Отвечать будет тоже Андрей.\nЛинукс различает написание строчных и прописных букв(маленькие и большие), а виндовс нет. И как бы вы не назвали файл или папку, вы должны помнить, что если вы будете хранить бэкап(резервную копию) на своём компьютере, то \u0026ldquo;одинаковые\u0026rdquo; файлы могут привести к проблемам. В HTML в принципе стараются писать всё маленькими буквами(строчными) и соединять слова через тире. Для домашнего компьютера я больше предпочитаю \u0026ldquo;CamelCaseNotation\u0026rdquo;, когда всё пишется маленькими буквами, без тире, но начальные буквы каждого слова пишут с большой буквы, так принято например в языке программирования Java. Другой вариант написания через \u0026ldquo;-\u0026rdquo; называется kebab-case или lisp-case. Всё понятно? Но вы зря расслабились, это ещё не конец. У нас есть Snake case. Это змейка \u0026ldquo;foo_bar\u0026rdquo;. Но и это было бы слишком просто. Есть UPPER_SNAKE_CASE и lower_snake_case. Запутались? Давайте табличку сделаем.\n   Название термина Пример Ссылка на википедию     CamelCase HelloWorld.java Распространённая система обозначения переменных и файлов в Java, Pascal   snake_case регистр_длинный_как_змея Распространённая система обозначения переменных в Perl, Python, PHP, Ruby   kebab-case шашлычный-регистр Язык Lisp использует такой регистр. Или Gatsby.js    Система, которой вы будете пользоваться не имеет большого значения, это скорее зависит от того на какой машине вы работаете и с какими технологиями. Самое главное, что бы вы были последовательными. Иногда это вообще не ваш вопрос, а политика фирмы. Спросите шефа как работает ваша фирма и следуйте указаниям. Порой это требования клиента. И от проекта к проекту настройки могут отличаться.\nВозвращаясь к эдиторам. Иногда на фирме есть стандарт, который нельзя нарушать или технически не очень удобно использовать другой.\nConvention #  Таких религиозных вопросов в работе будет немало. Обычно для каждого языка есть конвенции(Convention). Конвенция - это свод правил, которые программисты выбрали для данного стэка(технология). Если хотите, своеобразное джентльменское соглашение Запрос \u0026ldquo;CSS Naming Conventions\u0026rdquo; выдаёт правила написания кода для CSS, которым вы будете следовать, если дойдёте до главы \u0026ldquo;CSS - это вооооообще лёхка!\u0026rdquo;\nДомашнее задание #   Выбрать один или несколько рабочих браузеров. Установить, если требуется. Например chrome, opera, firefox. Поставить среду разработки. Visual Studio Code, Webstorm или тот который нравится.  "});index.add({'id':45,'href':'/school/java/oop-course/','title':"02 - Введение в ООП",'content':"Введение в ООП — Java online #  Курс ориентирован на тех, кто уже изучил базовый курс Java.\nВ среднем один урок - 2-5 часов освоения и 3-5 часов самостоятельное закрепление материала.\nУроки регулярно дополняются.\nК данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки. Скоро будет ссылка.  "});index.add({'id':46,'href':'/school/java/oop-course/002-java-oop-method-overloading-polymorphism/','title':"Java-OOP 02 - Перегрузка методов в Java Overloadin",'content':"Перегрузка методов (Method Overloading) #  В Java несколько методов из одного класса могут иметь одно название.\nОдно название и несколько методов #  Давайте сразу рассмотрим пример.\npublic class Calculator { public static int addition(int a, int b) { return a + b; } public static double addition(double a, double b) { return a + b; } } Очевидное-невероятное, но Java сама выбирает подходящий метод, для решения проблемы.Если мы передадим ей два int, то выберется первый метод, если два double, то JDK выберет самостоятельно нижний метод.\nМы можем создать метод с двумя long или с двумя String.\npublic static double addition(String a, String b) { return a + b; } Каждый раз сигнатура метода будет меняться и Java выбирает подходящий.\nСигнатура метода #  Сигнатура метода - это название метода и принимаемые им параметры. У метода выше сигнатурой называется addition(int a, int b). При изменении параметров меняется и сигнатура.\n  The signature of the method declared above is: calculateAnswer(double, int, double, double);\n  Два метода имеют одинаковую сигнатуру, если они имеют одинаковые имена и типы аргументов. Таким образом, возвращаемый тип метода или его модификатор доступа не является частью сигнатуры метода.\nКоличество принимаемых атрибутов #  Мы можем менять не только типы \u0026ldquo;переменных\u0026rdquo;, но и их количество.\nВ наш класс Calculator мы можем добавить новые методы:\npublic class Calculator { public static int addition(int a, int b) { return a + b; } public static double addition(double a, double b) { return a + b; } public static double addition(String a, String b) { return a + b; } public static int addition(int a, int b, int c) { return a + b; } public static double addition(double a, double b, double c) { return a + b; } public static double addition(String a, String b, String c) { return a + b; } } Сигнатура не должна повторяться. Java видит название метода и шесть разных вариантов переменных:\n Два инта Три инта Два double Три double Два String Три String  Вполне возможно передать один String и один int. Но это можно сделать лишь единожды. Сигнатура каждый раз должна отличаться.\nПерегрузка методов позволяет прописать свои свойства даже для простого сложения. В главе, в которой мы знакомились с Assert мы прописывали максимальное значение Integer. С помощью перегрузки мы должны прописать правильный и корректный метод для каждого типа данных. Возможно и для Vararg понадобится свой метод.\nПерегрузка важная часть полиморфизма, в объектно ориентированном программировании.\nЗабегая вперёд в Java три важные части или даже кита, на которых она стоит.\nТри(четыре) кита на которых стоит Java #   Наследование - inheritance. Инкапсуляция - encapsulation. Полиморфизм - polymorphism.  перегрузка - overloading. переопределение - overriding   Абстракция - data abstraction.  Очень часто абстракцию не указывают как несущую часть ООП, считая её частью наследования. Я для себя истину не выяснил. В спорах участвовать мне лень. Вам я привожу оба существующих мнения.\nВ течении следующей дюжины глав я попробую осветить все эти термины.\nПолиморфизм #  Здесь могло бы стоять определение. Но это очень обширная тема, проходящая через всё ООП. По этому пока просто запомните, что перегрузка входит в определение полиморфизма.\nДополнительные ссылки #   Defining Methods - Oracle. Перегрузка и нейминг методов. Method Overloading and Overriding in Java - baeldung. На этой странице затронут и overriding.  "});index.add({'id':47,'href':'/school/java/oop-course/003-java-oop-constructor-this/','title':"Java-OOP 03 - Конструктор в Java и ключевое слово this - введение в Java-OOP",'content':"Конструктор в Java и ключевое слово this- введение в Java-OOP 003 #    Стройка   Создание объектов в Java часто сравнивает с обычной стройкой в жизни. И английский constructor и русский конструктор связаны со строительством напрямую.\nПринципиально, конструктор - это просто метод. Просто метод который создаёт объекты. В связи с тем, что это очень важный метод и является краеугольным камнем всей парадигмы ООП, то у этого метода есть привилегия.\nКонструкторы (методы по которым создаются объекты) - пишутся в java всегда с большой буквы.\nЭто помогает понять, что сейчас создаётся объект.\nНесмотря на его маленькие отличия это всего лишь метод. Метод с помощью которого мы можем создать объект.\nВ некоторых ситуациях нам достаточно создать пустой объект, без всяких полей, в других нам нужны объекты с параметрами.\nНапример, мы не можем общаться с пользователем сайта, не зная его емайла и ника. Если мы говорим о базе данных школы, то мы не можем \u0026ldquo;создать ученика\u0026rdquo; без имени, фамилии, года рождения и возможно без документа(номера документа) подтверждающего личность это тоже не всегда возможно.\nСитуации и в жизни и в коде могут встретиться разные и потому мы можем встретить в ином классе целое семейство конструктов. На сайте существуют различные страницы. На некоторых есть фотография, на некоторых нет. Для создания различных объектов одного типа используют разные конструкторы.\nИногда в классе нет вообще ни одного конструктора. Именно с такого примера мы и начнём.\nОбъект есть, конструктора нет #  На нашем (условном) сайте есть статьи и мы создаём Article класс, который поможет нам с ними работать.\npublic class Article { } class Test { public static void main(String[] args) { Article art = new Article(); } } Мы можем создать тестовый класс в том же файле. Мы должны знать, что модификатор доступа Public может применятся только к тому классу, который назван так же как и файл. Дополнительный класс в нашем файле скорее вспомогательный. Этим правилом мы и воспользовались для простоты.\nПри создании объекта мы использовали пустой конструктор, конструктор без параметров. Но мы его не создавали в классе Article. Так откуда же он взялся?\nJava создаёт один стандартный пустой конструктор сразу по умолчанию в каждом классе. Нам не обязательно прописывать пустой конструктор. Но как только мы прописываем хоть одно правило создания экземпляра объекта, то мы переписываем стандартное поведение Java. И если нам всё ещё нужен пустой конструктор, то мы должны его прописать самостоятельно.\nКонструктор - это специальный метод, не имеющий возвратного значения. Этот метод называется так же как и класс экземпляр которого он должен создать.\nВ конструкторе мы можем указать начальные или стандартные значения будущих объектов.\npublic class Article { String title; String announce; String fullText; public Article() { title = \u0026#34;unknown\u0026#34;; announce = \u0026#34;unknown\u0026#34;; fullText = \u0026#34;unknown\u0026#34;; } } Для чего нужно создавать много разных конструкторов? #  Много конструкторов обычно и не нужно. В рамках обучения можно создать несколько разных вариантов, в обычной жизни делают ровно столько, сколько используется другими частями программы. Чаще всего ровно один.\npublic class Book { private String title; private String author; private String isbn; private int page; private int year; public Book() { } public Book(String bookTitle, String bookAuthor, int bookYear) { title = bookTitle; author = bookAuthor; year = bookYear; } public Book(String bookTitle, String bookAuthor, String bookIsbn, int bookPage) { title = bookTitle; author = bookAuthor; isbn = bookIsbn; page = bookPage; } } this #  This это ссылка на самого себя, на класс, по которому создаются объекты.\nПростейшее применение this уместно в классе выше. Что бы не придумывать новые переменные для конструкторов, отличающиеся от переменных класса, но созвучные им. Мы используем this и как бы говорим: \u0026quot; ЭТА переменная из ПОЛЯ КЛАССА будет равна тому значению, которое мы получим из переменной в сигнатуре конструктора.\u0026quot;\npublic Book(String title, String author, int year) { this.title = title; this.author = author; this.year = year; } public Book(String title, String author, String isbn, int page) { this.title = title; this.author = author; this.isbn = isbn; this.page = page; } Другой пример использования this указан в официальной документации и я просто попытаюсь прочитать его для вам.\npublic class Rectangle { private int x, y; private int width, height; public Rectangle() { this(0, 0, 1, 1); } public Rectangle(int width, int height) { this(0, 0, width, height); } public Rectangle(int x, int y, int width, int height) { this.x = x; this.y = y; this.width = width; this.height = height; } ... } Строчка \u0026ldquo;this(0, 0, 1, 1);\u0026rdquo; указывает на конструктор в этом же методе. И такой конструктор, которые принимает 4 параметра есть - \u0026ldquo;public Rectangle(int x, int y, int width, int height)\u0026rdquo;. Вот этот this и вызывает СОБСТВЕННЫЙ конструктор.\nДополнительные ссылки #   Providing Constructors for Your Classes - официальная документация A Guide to Constructors in Java - www.baeldung.com/java-constructors Guide to the this Java Keyword this от baeldung Using the this Keyword - от Oracle  Домашнее задание #   Сколько различных конструкторов можно создать, если у нас девять различных полей класса? Допустим int, double, String, char, long, float, byte, short, boolean.  "});index.add({'id':48,'href':'/school/java/oop-course/004-java-oop-encapsulation-get-set/','title':"Java-OOP 04 - Инкапсуляция - encapsulation",'content':"Инкапсуляция - encapsulation #  В слове инкапсуляция корень капсула. Если мы спрячем в \u0026ldquo;капсулу\u0026rdquo; параметры объекта, то это и будет инкапсуляцией.\n  Инкапсуляция - encapsulation   Зачем нужна инкапсуляция? #  Во-первых, к некоторым параметрам не должно быть доступа ни у других программ, ни у пользователей, ни у (даже!) программистов. Например:\n Поле день рождения в программе паспортного стола. Посмотреть его можно. Изменить нельзя. Это поле должно быть создано в месте с записью о человеке и позже его менять нельзя. Второй пример банковские счета. Никто не должен иметь возможность изменить состояние счёта просто вписав в поле 1_000_000€. Хороший пример с комментарием пользователя на форуме. Его можно создать, изменить, удалить. Но может это сделать не любой, а только сам пользователь или например админ, модератор сайта. Хороший пример пожалуй реализован в некоторых играх дополненной реальности. В зависимости от того, где находится пользователь, появляется доступ к различным параметрам игры - игровым боссам, кладам и так далее. То есть координаты нашего расположения берутся напрямую из телефона. И ни у кого нет возможности повлиять на эти данные.  Надеюсь вопрос зачем - решён.\nКак в Java реализована инкапсуляция? #  В Java есть модификаторы доступа, с которыми мы уже знакомились и использовали. С помощью этих модификаторов мы можем гибко влиять на видимость наших полей и методов.\nМодификаторы доступа в Java #     _ Class Package Subclass(same pkg) Subclass(diff pkg) World     public + + + + +   protected + + + +    no modifier + + +     private +        Самый закрытый доступ у модификатора private. Он разрешает доступ только методам этого же класса. Самая высокая ступень видимости у public. Любой метод может получить доступ к полю. Разницу между protected и отсутствием модификатора можно увидеть при работе с наследованием.\npublic class Cat { private String name; private int age; private String breed; private boolean pass; public Cat(String name, int age, String breed) { this.name = name; this.age = age; this.breed = breed; } void move() { System.out.println(\u0026#34;Я двигаюсь!!!\u0026#34;); } } Какие части программы надо инкапсулировать(скрывать)? #  Принципиально вопрос надо ставить по другому. Какие не надо? Все параметры класса должны быть защищены. И только для тех параметров, которых необходимо можно изменить модификатор.\nТо есть, если нет необходимости всегда private.\nКак посмотреть данные скрытого поля или даже изменить? #  В нашем классе с котом есть конструктор, который создаёт котика без паспорта прививок. Если мы сделаем ему паспорт, то мы можем создать метод, который меняет значение поля. Метод изменяющий поле называют \u0026ldquo;сетер\u0026rdquo;.\npublic void setPass(boolean pass) { this.pass = pass; } Мы передаём новое значение и изменяем его. В название поля всегда есть слово set и потому их так и прозвали.\nМетод, который показывает нам значение поля, называется гетер. Потому что в название метода всегда есть get.\npublic boolean isPass() { return pass; } Ну почти всегда. Всегда если это не boolean. Запомните это, пожалуйста. Гетеры для остальных полей класса Cat:\npublic String getName() { return name; } public int getAge() { return age; } public String getBreed() { return breed; } Как мы видим конвенция для названия метода достаточно проста. Используй get, is или set и само название поли и соедини их через CamelCase нотацию.\nСам класс теперь выглядит вот так.\npublic class Cat { private String name; private int age; private String breed; private boolean pass; public Cat(String name, int age, String breed) { this.name = name; this.age = age; this.breed = breed; } public String getName() { return name; } public int getAge() { return age; } public String getBreed() { return breed; } public boolean isPass() { return pass; } public void setPass(boolean pass) { this.pass = pass; } void move() { System.out.println(\u0026#34;Я двигаюсь!!!\u0026#34;); } } Обратите внимание, что сетеры это методы без возврата переменных. Они просто исполняемые и что-то меняют в объекте. А гетеры у нас всегда что-то должны возвращать.\nОчень часто (и такое будет в домашнем задании) лепят гетеры ко всем полям класса. Разумно делать только те гетеры и тем более сетеры, которые действительно нужны.\nДомашнее задание #   Создайте если ещё не создали класс книги. Добавьте параметры в свои книги. Всего должно быть около 10. Создайте метод закладки для книги. Сделайте ко всем полям гетеры и сетеры(практики ради). Создайте 10 объектов книги. Создайте массив из этих 10 объектов. Отсортируйте массив поочерёдно по автору, по году издания, по количеству страниц.  "});index.add({'id':49,'href':'/school/java/oop-course/005-java-oop-inheritance/','title':"Java-OOP 05 - наследование - inheritance",'content':"Наследование - inheritance #  При разработке приложения для предприятия мы можем столкнуться с тем, что у различных профессий или должностей существуют различные параметры(поля класса) и поведение(методы).\nПростейший пример университет. В нём есть студенты, преподаватели, научные и технические работники. У всех этих преподавателей должен быть пропуск. Например в зависимости от типа пропуска различные скидки в университетской столовой(например).\nДавайте создадим класс Студента, Препода, и Работника.\npublic class Student { private String firstName; private String secondName; private String uniID; void study(){ } } public class Teacher { private String firstName; private String secondName; private String uniID; void teach(){ } } public class Worker { private String firstName; private String secondName; private String uniID; void work(){ } } На самой ранней стадии написания поля мы видим, что в нашем приложении будут 3 класса, которые содержат повторяющийся код. Такого следует избегать и мы можем вынести общую часть в родительский класс и назовём его как-то в стиле человек, персон, пользователь. Если вы не против, то я создам класс Person и в классе Person напишу конструктор для инстанцирование(создание) объектов с типом данных Person.\npublic class Person { private String firstName; private String secondName; private String uniID; public Person(String firstName, String secondName, String uniID) { this.firstName = firstName; this.secondName = secondName; this.uniID = uniID; } }  После создания класса Person мы можем указать нашему уже созданному выше классу Student с помощью ключевого слова extends, что его родительский Person. Так как в родительском классе отсутствует \u0026ldquo;пустой\u0026rdquo; конструктор, то мы обязаны(IDEA недвусмысленно намекнёт нам об этом) создать собственный конструктор, желательно реализовав родительские поля класса.\n   Редудантные(повторяющиеся) поля, которые у нас были до этого мы можем удалить.  Тогда мы получим вот такое:\npublic class Student extends Person { public Student(String firstName, String secondName, String uniID) { super(firstName, secondName, uniID); } void study() { } } Мы можем наследовать не только какие-то поля, мы можем наследовать методы. Давайте создадим в Персоне метод eats\nvoid eats(){ System.out.println(\u0026#34;Обед в 13:00\u0026#34;); } А потом переопределим его в Student:\n@Override void eats() { super.eats(); System.out.println(\u0026#34;Ужин в 18:00\u0026#34;); } В данный момент переопределённый метод использует родительский, как он есть и добавляет свою собственную строчку.\nАннотация @Override #  Аннотация @Override указывает, что далее мы собираемся переопределять метод родительского класса.\nПри этом, если в родительском классе не окажется метода с аналогичной сигнатурой, то мы получим предупреждение компилятора о том, что хотя мы и собирались что-то переопределить, по факту этого не произошло.\nНа этом действие аннотации заканчивается.\nТаким образом, аннотация никак не влияет на сам факт переопределения метода - при совпадении сигнатур с методом базового класса он и так будет переопределен, независимо от наличия, либо отсутствия этой аннотации. Аннотация служит лишь для контроля успешности действия при сборке проекта.\nВ случае отсутствия аннотации @Override и не совпадении сигнатур (в результате ошибки) с методом, который мы собирались переопределять - случится страшное - очень трудноуловимая ошибка, когда вы думаете, что должно бы переопределяться, а по факту имеете отдельный независимый метод, который скорее всего вообще не выполняется. При этом компилятор считает, что с его точки зрения все в порядке - хотите собственный метод в классе-наследнике - нет проблем. И молчит.\ntoString #  Все классы в Java по умолчанию являются дочерними классами самого главного класса в Java Object. Мы можем наследовать некоторые методы главного класса. Один из них метод \u0026ldquo;toString\u0026rdquo;. Это тот метод, который переопределяется чаще всего. В нём программист обычно выводит информацию о своём объекте.\nВ студенте мы можем реализовать такой код:\n@Override public String toString() { return super.toString(); } А в персоне:\n@Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;firstName=\u0026#39;\u0026#34; + firstName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, secondName=\u0026#39;\u0026#34; + secondName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, uniID=\u0026#39;\u0026#34; + uniID + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } Такая запись toString() де-факто стандарт Java. Старайтесь в таком стиле записывать информацию о ваших объектах.\nНаш класс Student теперь выглядит вот так.\npublic class Student extends Person { public Student(String firstName, String secondName, String uniID) { super(firstName, secondName, uniID); } @Override void eats() { super.eats(); } @Override public String toString() { return super.toString(); } void study() { } } Класс Person вот так:\npublic class Person { private String firstName; private String secondName; private String uniID; public Person(String firstName, String secondName, LocalDate birthDate, String uniID) { this.firstName = firstName; this.secondName = secondName; this.uniID = uniID; } void eats(){ System.out.println(\u0026#34;Обед в 13:00\u0026#34;); } @Override public String toString() { return \u0026#34;Person{\u0026#34; + \u0026#34;firstName=\u0026#39;\u0026#34; + firstName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, secondName=\u0026#39;\u0026#34; + secondName + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, uniID=\u0026#39;\u0026#34; + uniID + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#39;}\u0026#39;; } } Помните, что модификатор доступа у переопределённого класса должен быть уровнем не ниже родительского. То есть, если у базового(Person) класса он был public, то и у дочернего(Student) он тоже должен быть public.\nЗапрет наследования #  Мы можем запретить наследовать с помощью ключевого слова final. Тогда наш класс может начинаться так:\npublic final class Human { final void eats(){ System.out.println(\u0026#34;Обед в 13:00\u0026#34;); } } Класс Human не может иметь наследников.\npublic class Alien { final void eats(){ System.out.println(\u0026#34;Обед в 13:00\u0026#34;); } } В классе Alien финализирован метод. Это значит, что дочерние классы не смогу его наследовать.\nСоздание объектов #  Давайте я создам трёх студентов тремя способами.\npublic class Main { public static void main(String[] args) { Student pasha = new Student(\u0026#34;Паша\u0026#34;, \u0026#34;Алеексеев\u0026#34;, \u0026#34;12345\u0026#34;); Person sasha = new Student(\u0026#34;Саша\u0026#34;, \u0026#34;Семёнов\u0026#34;, \u0026#34;3425345\u0026#34;); Object dasha = new Student(\u0026#34;Дарья\u0026#34;, \u0026#34;Иванова\u0026#34;, \u0026#34;3425345\u0026#34;); Student newStudent = (Student) dasha; } } Наш студент является объектом, персоной и студентом. Теоретически мы можем создавать наш объект так, как нам это нужно для сверки, складирования или передачи данных.\nПриведение типов данных работает именно так, как показано на примере.\nПример с котиком #  Давайте попробуем вспомнить школьную биологию и котиков - википедиа:\n  наследование в java      Научная классификация тип     Домен Эукариоты   Царство Животные   Тип Хордовые   Класс Млекопитающие   Отряд Хищные   Семейство Кошачьи   Род Кошки   Вид Лесной кот   Подвид Кошка    Кошка является одновременно животным, хордовой, хищницей.\nПримерно эта же мысль реализована в Java.\nTypes of Inheritance #  Различные типы наследования:   Java не поддерживает множественное наследование. Папа может быть только один.\nДомашнее задание #   Допишите классы Person, Student, Teacher, Worker Добавьте в них дополнительные параметры общие в родительский и уникальные в дочерние. Добавьте методы ходить, оплата за учёбу, выплата зарплаты Создайте массив студентов, учителей, рабочих и персон. Создайте метод удаления, добавление, изменения элементов из массива. Отсортируйте массивы по возрасту. Создайте базовый класс домашних животных и несколько дочерних классов: кот, собака, попугай, канарейка, рыбка, свинка, лошадь, гусь.  Продумайте какие поля у объектов общие, а какие уникальные Добавьте методы в родительский класс и переопределите их в дочерних: есть, пить, издавать звуки, двигаться    Дополнительные ссылки #   Object - docs.oracle.com Inheritance - docs.oracle.com  "});index.add({'id':50,'href':'/school/java/oop-course/001-java-object-introduction-chapter-1/','title':"Java-OOP 01 - Первые объекты",'content':"Первые объекты в Java - введение в Java-OOP 001 #  Введение в объектно-ориентированное программирование(Object-Oriented Programming) продолжает курс - Басовый курс Java.\nJava является объектно-ориентированным языком. Хотя на сегодня в ООП умеют играть все популярные языки. Это новшество на конец прошлого века, сегодня уже добавлено даже в старые языки, изначально не поддерживающие ООП (например php, javascript).\nООП очень важная тема. И всё что было до этого было просто разминкой перед настоящей Java.\nОчевидно, что в работе, например при создании сайтов достаточно элементов, которые повторяются.\nК примеру статьи, в статьях присутствует заголовок, дата публикации, возможно дата редактирования, автор, сама статья, фотография в анонсе, может быть в статье выделен отдельно анонс, возможно у статьи есть комментарии и оценка пользователей.\nПомимо статей на сайте есть комментарии, у которых есть автор, время публикации, текст комментария.\nСтатьи и комментарии у нас обычно пишут живые люди. У людей есть ник, имя, фамилия, емайл, время регистрации. Люди пишут статьи и оставляют комментарии, загружают фотографии.\nДавайте просто попробуем создать шаблон для наших повторяющихся объектов. И для примера возьмём утку.\n  Java создание класса Duck   public class Duck { String breed;\t// порода утки \tint age;\t// возраст утки \tString color;\t// раскраска утки \t// утка плавает, утка крякает, утка летает, утка ест \tvoid swims() { System.out.println(\u0026#34;Duck swims\u0026#34;); } void quacks() { System.out.println(\u0026#34;Duck quacks\u0026#34;); } void flies() { System.out.println(\u0026#34;I CAN FLY!!!\u0026#34;); System.out.println(\u0026#34;I fly!\u0026#34;); } void eats() { System.out.println(\u0026#34;Duck eats\u0026#34;); } } Давайте в мейне создадим пару экземпляров нашего класса.\npublic static void main(String[] args) { Duck greyDuck = new Duck(); greyDuck.age = 4; greyDuck.breed = \u0026#34;anasPlatyrhynchos\u0026#34;; greyDuck.color = \u0026#34;grey\u0026#34;; greyDuck.flies(); } I CAN FLY!!! I fly! Я создал экземпляр нового СЛОЖНОГО типа данных(он пишется с ЗАГЛАВНОЙ буквы). Тип данных Duck, переменная greyDuck и завершил инициализацию магической формулой с уже знакомым нам new оператором. Многие ругают Java именно за эту длинную инициализацию объектов. Нам просто надо запомнить.\nИ так мы создали экземпляр объекта УТКА. после чего инициализировали те параметры утки, которые нам были известны и нужны. Можно было и не все. И вызвали метод утки \u0026ldquo;летит\u0026rdquo;. И утка полетела.\nМы создали объекты, инициализировали то, что мы знали о них. И запустили методы, которые нам были нужны. Результат можно посмотреть в сообщениях терминала.\nУтки и люди вполне могут быть в одной программе, например в игре. Или в обучении. Есть метод Rubber duck debugging или по-русски метод утёнка.\nСуть метода в том, что бы рассказывать утёнку о своих методах решения задачи.\nА пока создадим новый шаблон для наших объектов Car:\npublic class Car { String modelName; String motorID; String color; int tiles; int doors; int mileage; void move(int km) { System.out.println(\u0026#34;Машина проехала \u0026#34; + km); mileage += km; } } class CarTest { public static void main(String[] args) { Car myNewCar = new Car(); myNewCar.move(100); System.out.println(myNewCar.mileage); myNewCar.move(300); System.out.println(myNewCar.mileage); } } Класс это основа языка Java. И именно класс определяет объект. Класс лежит в основе ООП-принципа.\nВсё что вы делаете в Java должно быть написано в Java. До сих пор мы не использовали всю силу классов. Мы просто запускали в классе метод мейн и его примитивные инструкции.\nCreating New Class Instances #  Важно понимать, что класс определяет новый тип данных. Класс это шаблон объекта, а объект это \u0026ldquo;instance\u0026rdquo; класса. Instance или экземпляр класса являются синонимами слова объект.\n\u0026ldquo;Мы создаём объект класса Car. Мы создаём экземпляр класса Car\u0026rdquo;\nclass ИмяКласса { тип названиеПеременной_1; тип названиеПеременной_2; тип названиеПеременной_NN; тип имяМетода_1(список парамтров){ // Тело метода  } тип имяМетода_2(список парамтров){ // Тело метода  } тип имяМетода_NN(список парамтров){ // Тело метода  } } Person и BMI в ООП #  public class Main { public static void main(String[] args) { System.out.println(bmiIndex(100, 175)); int[] array = {5, 3, 8, 9, 1, 10, 34, 12}; Person person1 = new Person(); person1.height = 175; person1.weight = 100; System.out.println(bmiIndex(person1.weight, person1.height)); person1.bmiIndex(); double test = person1.bmi; System.out.println(test); } public static double bmiIndex(double m, double h) { h = h / 100; return m / (h * h); } } public class Person { String name; double weight; double height; double bmi; public Person(){ } public Person(double w, double h){ bmiIndex(); } public void bmiIndex() { double m, h; m = weight; h = height; h = h / 100; bmi = m / (h * h); } } Повторение #  Модификаторы доступа играют важную роль в программировании. С помощью модификаторов мы делаем часть методов, объектов, переменных \u0026ldquo;невидимыми\u0026rdquo; для других классов, защищая их от изменения извне. Существует 4 типа модификаторов доступа:\n private; default; protected; public.  Модификаторы доступа. Private, protected, default, public #  Private — наиболее строгий модификатор доступа. Он ограничивает видимость данных и методов пределами одного класса.\nDefault — package visible.\nProtected — package visible.\nProtected data member and method are only accessible by the classes of the same package and the subclasses present in any package. You can also say that the protected access modifier is similar to default access modifier with one exception that it has visibility in sub classes.\nPublic — Кто угодно может этим пользоваться.\n   _ Class Package Subclass(same pkg) Subclass(diff pkg) World     public + + + + +   protected + + + +    no modifier + + +     private +        Дополнительная литература #   https://docs.oracle.com/javase/tutorial/java/javaOO/objectcreation.html https://www.baeldung.com/java-classes-objects  Домашнее задание #   Создать класс лебедь - Swan. И несколько его экземпляров. Чем различаются ваши лебеди? Какие у них атрибуты? Какие методы? Создать класс книги: название, isbn, автор, год издания, количество страниц, переплёт, жанр, рейтинг, цена(, возможно параметры, которые придумаете сами). Создать 5 экземпляров этого класса: азбука, война и мир, книга о вкусной и полезной пище, и два своих примера. Использовать в названиях переменных осмысленный английский язык.  "});index.add({'id':51,'href':'/school/database/','title':"Database",'content':"Введение в реляционные базы данных #  Этот курс врядли заменит хороший учебник по SQL. Но вполне может облегчить вход в работу с ними.\nSQL - это язык, который помогает общаться с базами данных. СУБД - система управления базами данных. MySQL - один тип из множества различных баз данных.\nДавайте пошагово попробуем разобраться что это.\n"});index.add({'id':52,'href':'/school/frontend/html/','title':"Html",'content':"Введение в HTML #  По мере написания будут появляться новые главы. Творческих успехов и вам.\nВведение\n"});index.add({'id':53,'href':'/school/job-interview/','title':"Job Interview",'content':"Вопросы на собеседование #  Мало разбираться. Надо пройти собеседование. А на собеседовании задают вопросы.\n"});index.add({'id':54,'href':'/school/java/exercises/','title':"Exercises",'content':"Задачи для курса введение в веб-программирование. #  "});index.add({'id':55,'href':'/school/tools/','title':"Tools",'content':"Java #  К данному курсу ведётся:\n Git-репозиторий с кодом и видео уроки.  "});index.add({'id':56,'href':'/posts/hello/','title':"У меня снова есть блог",'content':"Блогер это навсегда #  Около 5 лет у меня не было блога. И вот у меня снова появилось желание, а мои возможности позволяют выбирать из большего, чем 10 лет назад.\nНадеюсь до конца лета я смогу выложить свой курс введения в веб-программирование с первым языком обучения Java.\nПроверьте сами, вдруг получилось. На секундочку, сам канал сделал ещё 4 года назад - 17.10.2016.\n  ночной берлин   "});index.add({'id':57,'href':'/posts/','title':"Blog",'content':""});index.add({'id':58,'href':'/school/database/01-sql-intro/','title':"01 Sql Intro",'content':"https://ru.hexlet.io/challenges/rdb_basics_highest_salary https://ru.hexlet.io/courses/rdb-basics\nhttps://stepik.org/lesson/27115/step/1?unit=8685\nhttps://www.coursera.org/learn/data-bases-intr https://habr.com/ru/post/487654/\nhttps://habr.com/ru/hub/sql/ http://sql-language.ru/sqldatetype.html https://metanit.com/sql/sqlserver/3.3.php\nhttps://site-do.ru/db/sql2.php https://proselyte.net/tutorials/sql/sql-data-types/ https://unetway.com/tutorial/sql-funkcii\nhttps://habr.com/ru/post/517188/\nhttps://habr.com/ru/company/otus/blog/531332/ https://habr.com/ru/post/506070/ https://habr.com/ru/company/mailru/blog/266811/ https://www.sql.ru/docs/sql/u_sql/ch1.shtml\nhttps://beesql.blogspot.com/ https://sql-academy.org/ru/guide https://javarush.ru/groups/posts/1952-vvedenie-v-sql https://sql-ex.ru/\nhttps://javarush.ru/groups/posts/2946-java-proekt-ot-a-do-ja-razbiraem-bazih-dannihkh-i-jazihk-sql\nhttps://tproger.ru/translations/java-jdbc-example/ http://openbook.rheinwerk-verlag.de/javainsel9/javainsel_24_006.htm\nhttps://www.google.com/search?q=sql+und+java\u0026amp;sxsrf=ALeKk025Q32qkeTkSpEfbeGEqz1nQihW8Q%3A1607287436887\u0026amp;source=lnt\u0026amp;tbs=cdr%3A1%2Ccd_min%3A1%2F1%2F2019%2Ccd_max%3A\u0026amp;tbm=\n"});index.add({'id':59,'href':'/school/frontend/html/05-html-table/','title':"05 Html Table",'content':"Таблицы и табличная вёрстка #  Кстати глагол верстать применяется и к работе фронтендера, когда он с помощью HTML и CSS \u0026ldquo;делает страницу\u0026rdquo;.\nЗа те 30 лет, что существует интернет и страницы и их вёрстка значительно и неоднократно менялись. Один из типов html-вёрстки называется табличной. И несмотря на то, что сейчас такая вёрстка не рекомендуется к использованию мы её рассмотрим.\nИ рассмотрим мы её(табличную вёрстку) не только в академических целях. До сих пор в вёрстке писем может использоваться табличная вёрстка и HTML4 стандарт. Миллионы компьютеров с Microsoft Outlook 2000 никуда не делись. А значит и нам надо понимать как это работает.\nПример таблицы в HTML:\n\u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;2\u0026#34;\u0026gt;The table header\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;The table body\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;with two columns\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; Результат работы\n  таблица в опере   Я бы не сказал, что то что я вижу на экране меня как-то впечатлило. Давайте попробуем добавить вот такую сточку:\n\u0026lt;table border = \u0026#34;1\u0026#34; cellPadding = \u0026#34;10\u0026#34; cellSpacing = \u0026#34;2\u0026#34; align=\u0026#34;center\u0026#34;\u0026gt;\u0026lt;/code\u0026gt; Результат:\n  таблица с бордером в опере   А каждого тега могут быть атрибуты, которые влияют на его отображение. Мы использовали 4 из них: border, cellPadding, cellSpacing, align.\nBorder изменяет толщину рамки вокруг ячеек таблицу.\nCellPadding отделяет текст внутри таблицы от края таблицы. Избавляет от налипания и помогает читаемости.\nCellSpacing - расстояние между ячейками таблицы.\nAlign - выравнивает нашу таблицу по центру или краям.\nBgcolor - добавляет цвет фона в таблице. Добавьте самостоятельно bgcolor=\u0026ldquo;yellow\u0026rdquo; и посмотрите.\nДополнительные ссылки. #   Доступные в HTML4 свойства таблицы  "});index.add({'id':60,'href':'/school/frontend/java-script/01-js-intro/','title':"01 Js Intro",'content':""});index.add({'id':61,'href':'/school/frontend/xml_svg/01-xml-intro/','title':"01 Xml Intro",'content':""});index.add({'id':62,'href':'/school/frontend/xml_svg/02-xml-svg/','title':"02 Xml Svg",'content':"SVG #  \u0026lt;svg height=\u0026#34;100\u0026#34; width=\u0026#34;100\u0026#34; xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u0026gt; \u0026lt;circle cx=\u0026#34;50\u0026#34; cy=\u0026#34;50\u0026#34; r=\u0026#34;40\u0026#34; stroke=\u0026#34;yellow\u0026#34; stroke-width=\u0026#34;3\u0026#34; fill=\u0026#34;blue\u0026#34;/\u0026gt; \u0026lt;/svg\u0026gt; "});index.add({'id':63,'href':'/school/hidden/','title':"Hidden",'content':"This page is hidden in menu #  Quondam non pater est dignior ille Eurotas #  Latent te facies #  Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\n Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor  Cum honorum Latona #  O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); }  Fronde cetera dextrae sequens pennis voce muneris #  Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); Тестовое вставка видео    "});index.add({'id':64,'href':'/school/java/basic-course/011-java-string-possibilities-and-more/','title':"011 Java String Possibilities and More",'content':"Возможности различных типов данных, литералов в Java — введение в Java 011 #  В четвёртом уроке мы затронули преобразования одних типов данных в другие. Давайте для начала посмотрим, что именно мы тогда учили.\nЯвные и неявные преобразования #  Значения, передаваемые переменным, можно привести в тот тип данных, которые переменная может принять. Вручную или автоматически, или явно и неявно.\n  преобразование типов данных   Расширение типа (widening Casting), которое можно проследить на схеме с помощью стрелок, происходит автоматически. Это преобразование меньшего типа данных в типа большего размера: byte -\u0026gt; short -\u0026gt; char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double.\nСужение типа (narrowing Casting) — преобразование типа данных большего размера в тип данных меньшего размера — делается вручную: double -\u0026gt; float -\u0026gt; long -\u0026gt; int -\u0026gt; char -\u0026gt; short -\u0026gt; byte\nString to int and double #  Помимо уже надеюсь привычного преобразования переменных и литералов из int в double И обратно мы можем большее.\nString number = \u0026quot;10\u0026quot;; int result = Integer.parseInt(number); System.out.println(result); Parse #  English\nThe software parses and filters the incoming data.  Русский\nПрограммное обеспечение разбирает и фильтрует поступающие данные.   int result = Integer.parseInt(\u0026#34;709\u0026#34;); Java разбирает на составные части наш строковый литерал и если в нём содержится целочисленное значение, то успешно записывает его в переменную с типом данных int.\nString.valueOf(3.14) #  Если у нас будет в строковом литерале десятичная дробь, то мы тоже можем \u0026ldquo;вытянуть\u0026rdquo; её.\ndouble pi = 3.14; String myPi = String.valueOf(pi); Магия строки: String to char #  charAt - Что это за символ? #  Мы можем взять из стрингастрокового литерала любой символ и записать его в переменную с типом данных char.\nString name = \u0026quot;Андрей\u0026quot;; char myChar = name.charAt(2); Мы можем узнать числовое значение символьного литерала с помощью хитрости:\nSystem.out.println(0 + myChar); И это нам должно напомнить, что любой чар-литерал легко преобразовывается в инт-литерал. Давайте посмотрим всё сначала и вместе:\nString name = \u0026#34;Андрей\u0026#34;; char myChar = name.charAt(2); System.out.println(0 + myChar); int myInt = myChar; System.out.println(myInt); substring #  Чар-литерал является частью строки. Точно так же мы можем даже \u0026ldquo;вырезать\u0026rdquo; любой символ из строкового литерала.\nString name = \u0026quot;Андрей\u0026quot;; String myLittleString = name.substring(0, 1); Но (пока) он так и останется строковым литералом, просто содержащим в себе один символ. Конечно же существуют ещё несколько возможностей разложить весь стринг на составные части, перебрать их и взять нужный. Но давайте пока разберёмся с\nchar myChar = \u0026quot;Андрей\u0026quot;.charAt(2); // так тоже теоретически можно писать Документация и доступные методы #  Я взял первых семь методов из официальной документации:\n   Modifier and Type Метод Пояснение     char charAt(int index) Returns the char value at the specified index.   int codePointAt(int index) Returns the character (Unicode code point) at the specified index.   int codePointBefore(int index) Returns the character (Unicode code point) before the specified index.   int codePointCount(int beginIndex, int endIndex) Returns the number of Unicode code points in the specified text range of this String.   int compareTo(String anotherString) Compares two strings lexicographically.   int compareToIgnoreCase(String str) Compares two strings lexicographically, ignoring case differences.   String concat(String str) Concatenates the specified string to the end of this string.    Ещё раз и \u0026ldquo;по-русски\u0026rdquo; #     Метод Перевод     charAt(int index) Возвращает значение символа по указанному индексу.   codePointAt(int index) Возвращает символ (Unicode code point) в указанном индексе.   codePointBefore(int index) Возвращает символ (точка Юникода) перед указанным индексом.   codePointCount(int beginIndex, int endIndex) Возвращает количество символов Юникода в указанном текстовом диапазоне данной строки.   compareTo(String anotherString) Сравнивает две строки лексикографически.   compareToIgnoreCase(String str) Сравнивает две строки лексикографически, игнорируя case написания   concat(String str) Конкатенирует эту строку на конец другой строки.    Лично мне перевод мало что сказал. Давайте посмотрим на примерах, что мы можем сделать.\ncharAt мы уже разобрали выше в этой же статье.\ncodePointAt(int index) - пример использования #  String testStr = \u0026#34;Группа студентов\u0026#34;; int result = testStr.codePointAt(1); System.out.println(\u0026#34;Результат проверки метода codePointAt = \u0026#34; + result); На экране мы увидим:\nРезультат проверки метода codePointAt = 1088 codePointBefore(int index) - пример использования #  String str = \u0026#34;I love Java\u0026#34;; System.out.println(\u0026#34;String = \u0026#34; + str); int result = str.codePointBefore(1); System.out.println(\u0026#34;Character(unicode point) = \u0026#34; + result);\tНа экране мы увидим:\nString = I love Java Character(unicode point) = 73 codePointCount(int beginIndex, int endIndex) - пример использования #  System.out.println(); String str = \u0026#34;Мы учимся в школе Telran\u0026#34;; System.out.println(\u0026#34;Оригинальная строка : \u0026#34; + str); // codepoint from index 1 to index 10 int ctc = str.codePointCount(3, 10); // prints character from index 1 to index 10 System.out.println(\u0026#34;Считаем символы = \u0026#34; + ctc); На экране мы увидим:\nОригинальная строка : Мы учимся в школе Telran Считаем символы = 7 compareTo(String anotherString) - пример использования #  Значение 0, если аргумент является строкой, лексикографически равной этой строке; значение меньше 0, если аргумент является строкой, лексикографически большей, чем эта строка; и значение больше 0, если аргумент является строкой, лексикографически меньшей, чем эта строка.\nЛексикографический порядок — отношение линейного порядка на множестве слов над некоторым упорядоченным алфавитом Sigma. Своё название лексикографический порядок получил по аналогии с сортировкой по алфавиту в словаре.\nString str1 = \u0026#34;Строка для теста\u0026#34;; String str2 = \u0026#34;Строка для теста\u0026#34;; String str3 = \u0026#34;Другая строка для теста\u0026#34;; int result = str1.compareTo( str2 ); System.out.println(result); result = str2.compareTo( str3 ); System.out.println(result); result = str3.compareTo( str1 ); System.out.println(result); Результат проверки compareTo(String anotherString):\n0 13 -13 compareToIgnoreCase(String str) - пример использования #  String str1 = \u0026#34;Строка для теста\u0026#34;; String str2 = \u0026#34;сТрОкА дЛя тЕсТа\u0026#34;; String str3 = \u0026#34;Другая строка для теста\u0026#34;; int result = str1.compareToIgnoreCase(str2); System.out.println(result); result = str2.compareToIgnoreCase(str3); System.out.println(result); result = str3.compareToIgnoreCase(str1); System.out.println(result); Результат проверки compareToIgnoreCase(String str):\n0 13 -13 concat(String str) - пример использования #  String str = \u0026#34;Привет\u0026#34;; str = str.concat(\u0026#34; Мир\u0026#34;); System.out.println(str); Результат проверки concat(String str):\nПривет Мир К каждому типу данных существует множество стандартных методов. Важно уметь читать документацию и пользоваться поисковиками.\nДомашнее задание #  Разобраться с методами:\n contains(CharSequence s) endsWith(String suffix) equals(Object anObject) equalsIgnoreCase(String anotherString) isEmpty() length() replace(char oldChar, char newChar) startsWith(String prefix) startsWith(String prefix, int toffset) substring(int beginIndex) toLowerCase() toUpperCase() trim()  Дополнительные ссылки #   Oфициальная документация к String  "});index.add({'id':65,'href':'/school/java/basic-course/012-java-methods-void-return/','title':"012 Java Methods Void Return",'content':"Методы в Java немного подробнее: возвратные и исполняющие — введение в Java 012 #  Главный метод класса #  public static void main(String[] args) Каждый раз пишем эту магическую строку что бы запустить нашу программу. MAIN - обозначает точку входа в программу. Мы можем один раз написать этот метод в главном классе, например Main:\npublic class Main { public static void main(String[] args) { // просто тестирование  } } Следующим методом мы можем написать метод сложения двух целых чисел. Название метода addition мы пишем с маленькой буквы.\n\tstatic void addition (){ int a = 4; int b = 5; int c = a + b; System.out.println(c); } И тогда мы можем в нашей точке входа запустить(вызвать) метод сложения и весь наш класс тогда будет выглядеть вот так:\npublic class Main { public static void main(String[] args) { addition(); } static void addition() { int a = 4; int b = 5; int c = a + b; System.out.println(c); } } Создание класса #  Точно также мы можем создать совсем новый класс для вычисления целых чисел. И назвать его Calculator, и в нём написать наш метод:\npublic class Calculator { static void addition() { int a = 4; int b = 5; int c = a + b; System.out.println(c); } } Аргументы #  Мы можем сделать метод принимающим параметры(атрибуты, аргументы), например так:\n\tstatic void addition (int a, int b){ System.out.println(a+b); } Тогда запустить этот метод в Main можно, давайте сначала подумаем как, а потом попробуем посмотреть:\nCalculator.addition(a, b); //Запускать метод мы можем один или несколько раз Calculator.addition(4, 7); Calculator.addition(17, 25); Метод сам по себе у нас может быть нетронутым и только в месте его вызова мы \u0026ldquo;манипулируем\u0026rdquo; с аргументами.\nТипы методов #  Принципиально в Java два типа методов:\n Исполняемые (void). Эти методы просто исполняют команды. Возвратные. Эти методы всегда что-то возвращают.  Пример метода, который возвращает значение int:\npublic static int devide() { int a = 0; return a; } Пример метода, который возвращает int и принимает два int аргумента\npublic static int devide(int a, int b) { return a / b; } Пример метода, который принимает String, а возвращает int:\npublic static int vornameAndName(String vorname, String name) { int result = vorname.length() + name.length(); return result; } Очень важно понимать, что main вход в программу, с этого метода начинаются необходимые действия. Например на условной кассе в магазине в точке мейн запускается процесс подсчитывания стоимости продуктов, и после этого стоимость передаётся в метод вывода чека на печать и ещё раз на экране у кассира. Нет хороших или плохих методов, удобных или неудобных; это просто инструменты и левша может использовать другие инструменты чем правша. \u0026ldquo;Правильность\u0026rdquo; особо нигде не прописана.\nЕщё один пример. Нам надо поехать в отпуск:\npublic class Main { public static void main(String[] args) { weGoOnVacation(); } static void weGoOnVacation() { // псевдометод, который описывает, что надо сделать что бы поехать в отпуск \tbookFlights(); bookHotel(); packUp(); callTaxi(); excellentMood(); } static void excellentMood() { //каждый из этих методов описывает как добиться поставленной цели. а может вызывать и другие дополнительные методы. \t// например для хорошего настроения нужно отключиться от работы и улететь туда где тепло\t\t} } Зарезервированные слова #     Нельзя использовать в переменных     abstract double int super   boolean else interface switch   break extends long synchronized   byte final native this   case finally new throw   catch float package throws   char for private transient*   class goto* protected try   const* if public void   continue implements return volatile   default import short while   do instanceof static     Модификаторы доступа. Private, protected, default, public #   private; default; protected; public.  Private — наиболее строгий модификатор доступа. Он ограничивает видимость данных и методов пределами одного класса.\nDefault — package visible.\nProtected — package visible.\nProtected data member and method are only accessible by the classes of the same package and the subclasses present in any package. You can also say that the protected access modifier is similar to default access modifier with one exception that it has visibility in sub classes.\nPublic — Кто угодно может этим пользоваться.\n   _ Class Package Subclass(same pkg) Subclass(diff pkg) World     public + + + + +   protected + + + +    no modifier + + +     private +        Модификатор static в Java #  Static показывает, что это метод или переменная класса. На данном этапе большего нам знать пока не надо.\npublic class HelloStatic { private static int count = 10; public static void main(String args[]) { System.out.println(count); //compile time error \t} } Дополнительные материалы #   https://www.oreilly.com/library/view/think-java/9781491929551/ch04.html https://docs.oracle.com/javase/tutorial/java/javaOO/returnvalue.html https://www.baeldung.com/java-methods Ещё раз ссылка с конвенцией (договор о правописании и синтаксисе) - https://www.oracle.com/technetwork/articles/javaee/codeconventions-135099.html https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html  Домашнее задание #   Давайте попробуем написать методы для вычисления площади и периметра фигур: квадрата, прямоугольника, треугольника, круга. И один раз напишем их исполняющими, а один раз возвратными. В обоих случаях методы должны принимать необходимые данные для вычисления: как радиус, длину сторон или прочее. Давайте напишем генератор паролей. Методу передаётся длина пароля. И метод генерирует пароль используя латиницу, цифры и некоторые спецсимволы(на ваш выбор). Подсказка - использовать только те знания, которые были уже изучены. Существует как минимум два(на самом деле 222) разных подхода к решению этой проблемы. Не бойтесь пробовать.  "});index.add({'id':66,'href':'/school/java/basic-course/013-java-while-dowhile/','title':"013 Java While Dowhile",'content':"Цикл While и Do While — введение в Java 013 #  Это самая лёгкая глава. Потому что цикл while — родной брат цикла for.\nПример:\npublic class WhileWeAreYoung { public static void main(String[] args){ int i = 0; while(i \u0026lt; 10){ System.out.println(i); i++; } } } Изученный цикл for мы бы написали так:\npublic static void main(String[] args) { for (int i = 0; i \u0026lt; 10 ; i++){ System.out.println(i); } } В цикле for стоит условие, и в while стоит условие. While цикл только проверяет правильность условия. В какой-то мере while может заменить связку for + if: \u0026ldquo;пока дети младше 18 лет — алкоголь не продавать\u0026rdquo;.\nИногда мы можем предполагать, что операция запустит бесконечный процесс или процесс, который невозможно выполнить современными средствами. Тогда нам помогает break — выход из цикла.\nНапример, такое возможно при подсчёте степени двойки (вспоминаем задачу про шахматную доску) или при подсчёте точного числа PI или при вычислении ряда Фибоначчи.\nwhile (true){ System.out.println(i); i++; if (i \u0026gt; 20) //код break; // выход из цикла } Если вам он кажется достаточно спорным, помните, что ситуации бывают разными.\nУ цикла while есть кузен do-while:\ndo { Команда(); } while(Булевое выражение) Например:\n// Декларирование и инициализация переменной int i = 0; // Команда, которая будет выполнена минимум один раз do { // Команда выполняется трижды System.out.println(\u0026quot;i равно \u0026quot;+ i); // Инкриментирование переменной i+=10; } // Условие выхода из цикла while(i \u0026lt;= 20); Цикл while называют циклом с предусловием.\nЦикл do while — циклом с постусловием.\nВ первом случае (while) код будет выполнен, согласно данным входа, во втором случае (do while) код будет выполнен минимум один раз, и только потом будет проверка на выход из цикла.\nЦикл — определение #  Циклы — это разновидность управляющих конструкций для организации многократного выполнения одного и того же участка кода.\nКод внутри такой управляющей конструкции выполняется циклично. Каждое выполнение кода — это итерация цикла. Количество итераций регулируется условием цикла. Код, который выполняется внутри цикла, называют телом цикла.\nПример использования while #  78 из десятичной системы переводим в двоичные 1001110.\n78 : 2 = 39 остаток: 0 39 : 2 = 19 остаток: 1 19 : 2 = 9 остаток: 1 9 : 2 = 4 остаток: 1 4 : 2 = 2 остаток: 0 2 : 2 = 1 остаток: 0 1 : 2 = 0 остаток: 1 Решение с помощью while\npublic static String convertDecimalToBinary(int decimal) { int remainder; String output = \u0026quot;\u0026quot;; while (decimal \u0026gt; 0) { remainder = (decimal % 2); output = Integer.toString(remainder) + output; decimal = decimal / 2; } return output; } Дополнительные материалы #  While, Do While: https://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html\nДомашнее задание #   Перепишите примеры из урока 10 с использованием новых знаний. Попробуйте написать вложенные циклы с помощью While и Do-While  "});index.add({'id':67,'href':'/school/java/basic-course/014-java-scanner/','title':"014 Java Scanner",'content':"Scanner — введение в Java 014 #  Я хочу ввести немного магии в наши программы. Мы уже пользовались и пользуемся для вывода результатов командой System.out.println(). Возможность ввода данных через терминал в программу также существует.\nimport java.util.Scanner; public class WhileScanner { public static void main(String[] args) { Scanner input = new Scanner(System.in); int old; System.out.println(\u0026#34;Сколько тебе лет? \u0026#34;); old = input.nextInt(); while (old \u0026gt;= 18){ System.out.println(\u0026#34;Ты можешь купить на вечер что-то более крепкое, чем чай\u0026#34;); break; // выход из цикла \t} input.close(); // сканер нужно закрывать. \t} } Удачное ли использование цикла while в примере выше?\nМы снова используем внешнюю библиотеку и в первой строчке мы её импортируем.\nВ строчке Scanner input = new Scanner(System.in); мы объявляем переменную input, которая будет отвечать за введённые в терминал данные.\nОбратите внимание на оператор new – с его помощью мы работаем с \u0026ldquo;непростыми данными\u0026rdquo;. Позже мы к нему вернёмся.\nПока же просто воспользуемся \u0026ldquo;сканером\u0026rdquo; и присвоим значение введённых данных переменной нашей old. С помощью old = input.nextInt(); мы передаём введённые целочисленные данные. Мы можем \u0026ldquo;перехватывать\u0026rdquo; данные любого типа. Просто мы должны записывать их в соответствующие переменные.\nОбязательно закрывайте Scanner \u0026quot; input.close();\u0026quot;\nДополнительные материалы #  Подробнее о Scanner\nДомашнее задание #   Напишите программу, которой надо представиться. Данные, которые спрашивает машина: имя, фамилия, пол, возраст, e-mail. Для считывания данных типа String используйте метод next(): input.next() Напишите программу, которая принимает из \u0026ldquo;сканера\u0026rdquo; возраст человека в строке и отдаёт его в вашу переменную int. В четвёртой главе(char, String) мы коротко рассматривали один из способов передачи такой информации. Напишите программу, которой надо представиться. Данные, которые спрашивает машина: имя, фамилия, пол, возраст, e-mail. Для считывания данных типа String используйте метод next(): input.next()  Интерактивные программы - игры #   Компьютер загадывает число от 1 до n. У пользователя k попыток отгадать. После каждой неудачной попытки компьютер сообщает меньше или больше загаданное число. В конце игры текст с результатом (или “Вы угадали”, или “Попытки закончились”). Президент приходит к власти если набрал 51% голосов избирателей. Создайте машину для ввода результатов выборов.  "});index.add({'id':68,'href':'/school/java/basic-course/015-java-binary-and-decimal-issue/','title':"015 Java Binary and Decimal Issue",'content':"Двоичная, десятичная, восьмеричная и прочие системы в Java и преобразования между ними — введение в Java 015 #    символы майя   Для усвоения этого урока достаточно знать циклы for (while, do-while), оператор выбора switch, условный оператор **if **, знание и уверенное пользование арифметическим оператором modulo.\nЭто один из лучших примеров, который показывает, что первоначально абсолютно неподъёмная задача при решении оказывается не такой уж и страшной.\nМы уже рассматривали во главе, которая знакомила нас с while как из десятичных чисел получить двоичные.\nПовторение, 78 превращаем в 1001110.\n78 : 2 = 39 остаток: 0 39 : 2 = 19 остаток: 1 19 : 2 = 9 остаток: 1 9 : 2 = 4 остаток: 1 4 : 2 = 2 остаток: 0 2 : 2 = 1 остаток: 0 1 : 2 = 0 остаток: 1 Давайте переведём двоичное число в десятичное. Давайте возьмём уже известное нам число 1001110. В одном байте восемь битов. Число 1001110 состоит из семи цифр. В таких случая часто дописывают недостающие ноли и 100_1110 превращается в 0100_1110. Это удобно и очень важно при визуализации чисел.\n   Порядковый номер цифры в числе 7 6 5 4 3 2 1 0     Степени двойки 2^7 2^6 2^5 2^4 2^3 2^2 2^1 2^0   Чему в итоге равны степени 128 64 32 16 8 4 2 1   Пример двоичного числа 0 1 0 0 1 1 1 0   Как считается десятичное 0*128 1*64 0*32 0*16 1*8 1*4 1*2 0*1   Результат вычислений 0 64 0 0 8 4 2 0    Сумма чисел из последней строчки 64+8+4+2 = 78\nЕсли с приведёнными примерами всё понятно, то можно перейти дальше и записать оба примера в Java.\nПереведём число из десятичной системы в двоичную, пока не забыли.\npublic static String convertDecimalToBinary(int decimal) { int remainder; String output = \u0026quot;\u0026quot;; while (decimal \u0026gt; 0) { remainder = (decimal % 2); output = Integer.toString(remainder) + output; decimal = decimal / 2; } return output; } И обратно из двоичной в десятичную\npublic static int convertBinaryToDecimal(int binaryDigit) { int decimal = 0; int n = 0; int temp = 0; while (binaryDigit \u0026gt; 0) { temp = binaryDigit % 10; decimal += temp * Math.pow(2, n); binaryDigit = binaryDigit / 10; n++; } return decimal; } Замечу, что это простейший метод преобразования, который работает только с целыми числами больше нуля. Однако краткость этого метода должна помочь понять суть методики. Единственное, что стоит особенно подчеркнуть - результат работы метода строковое значение.\nЕсли поработать над читаемостью метода convertDecimalToBinary, то мы заметим, что у нас (как минимум) дважды используется magicNumber 2 . Если мы догадаемся назвать это число systemIndex, то это будет частью решения метода convertDecimalToAnything.\npublic static String convertDecimalToAnything(int decimalDigit, int systemIndex) { int remainder; String output = \u0026quot;\u0026quot;; while (decimalDigit \u0026gt; 0) { remainder = (decimalDigit % systemIndex); output = Integer.toString(remainder) + output; decimalDigit = decimalDigit / systemIndex; } return output; } Теоретически, можно подумать как из бинарной системы перевести числа в любую другую систему. Но зачем? Если есть метод преобразования бинарного числа в десятичную систему, а потом в любую другую.\nУ нас только одна проблема, наша система работает с числами систем меньше десятичной. Для того, что бы нам одолеть системы свыше десятичной, нам надо понять, что происходит с числом, когда его делят на 11, 12, 13, 14, 15, 16 и так далее. И здесь нам должен помочь switch, который будет перехватывать результаты деления свыше 10 и подставлять в output вместо числовых значений буквенные A, B, C, D, E, F и так далее.\nРекомендую в рамках Java ограничиться целыми позитивными числами до шестнадцатеричной системы. Она нам важна, так как в ней информатике хранят цветовую гамму.\nДополнительные ссылки #   Бинарные(двоичные) числа в Java - официальная документация. Троичный компьютер  Шестнадцатеричная система Двадцатиричная система Шести десятеричная Двенадцатеричная система счисления Цифры майя Пример применения - https://smallseotools.com/de/rgb-to-hex/  Домашнее задание #   Ознакомиться со всеми дополнительными ссылками. Написать метод, который \u0026ldquo;вычитывает из строковых литералов десятичные и двоичные числа. Используйте метод - \u0026quot; Integer.parseInt(); Написать свой собственный класс ConvertDigits  добавить интерактивность, общение программы с пользователем. не использовать цикл while.    Задачи с очень повышенным уровнем сложности. #   Написать метод, который решает вопрос с делением на числа из систем свыше десятичной - 11-16. (Факультатив)Написать метод перевода числа из \u0026ldquo;любой\u0026rdquo; системы в десятичную. // Мы вернёмся к этому методу в будущем.  "});index.add({'id':69,'href':'/school/java/basic-course/016-java-ternary-operator/','title':"016 Java Ternary Operator",'content':"Тернарный оператор \u0026ldquo;?:\u0026rdquo; — введение в Java 016 #  Выражение:\nif (условие) { number = 10; } else { number = -10; } Можно заменить на\nnumber = (условие) ? 10 : -10; То есть ?: укороченный условный оператор if, if-else из седьмого урока\nпеременная = (выражение) ? значение if true : значение if false public static void ternar(int schoolАttestat){ String resultAtHome = \u0026quot;\u0026quot;; resultAtHome = (schoolАttestat \u0026gt;= 3) ? \u0026quot;Ребёнок переходит в следуюший класс\u0026quot; : \u0026quot;Ребёнок остаётся на второй год\u0026quot;; System.out.println( \u0026quot;Результат учёбы за год: \u0026quot; + resultAtHome); } Ещё пример для закрепления:\nclass TernarOperator { public static void main(String[] args) { Double kelvin = -273.15; String result; result = (kelvin \u0026gt; 0.0) ? \u0026#34;positive\u0026#34; : \u0026#34;not positive\u0026#34;; System.out.println(number + \u0026#34; is \u0026#34; + result); } } Рекурсивный метод нахождения факториала для будущего урока можно записать так:\n static int fact(int num) { return ((num \u0026gt; 1) ? num * fact(num - 1) : 1); } Тернарный оператор применяют когда абсолютно простая операция может иметь два варианта развития. Это так называемый синтаксический сахар. Помогает быстрее и лаконичнее писать код.\nЯ несколько раз видел, как тернарный оператор вкладывают один в другого. Я не буду приводить пример, потому что моё личное мнение - такой код абсолютно нечитаем.\nДополнительная ссылка #   https://www.baeldung.com/java-ternary-operator Спорный пример использования тернарного оператора в JS - Несколько болезненный тройной вложенный тернарный оператор.  Домашнее задание #   Даны два числа, a и b. Верните большее из них. Не используйте никаких методов из библиотеки Math. Покажите работу тернарного оператора. getMeMax(15, 5) → 15 getMeMax(4, 16) → 16 getMeMax(20, 100) → 100  Даны два числа, a и b. Верните меньшее из них. Не используйте никаких методов из библиотеки Math. Покажите работу тернарного оператора. getMeMin(15, 45) → 15 getMeMin(44, 16) → 16 getMeMin(200, 100) → 100  Даны два строковых значения. Верните идущее по алфавиту раньше. myFirstCompareTo(\u0026quot;Berlin\u0026quot;, \u0026quot;Moscow\u0026quot;); → \u0026quot;Berlin\u0026quot; myFirstCompareTo(\u0026quot;Minsk\u0026quot;, \u0026quot;Moscow\u0026quot;); → \u0026quot;Minsk\u0026quot; myFirstCompareTo(\u0026quot;Kyiv\u0026quot;, \u0026quot;Paris\u0026quot;); → \u0026quot;Kyiv\u0026quot; myFirstCompareTo(\u0026quot;Могилёв\u0026quot;, \u0026quot;Потсдам\u0026quot;); → \u0026quot;Могилёв\u0026quot;  Повторите пример из ссылки выше в Java.  "});index.add({'id':70,'href':'/school/java/basic-course/017-java-recursion-intro/','title':"017 Java Recursion Intro",'content':"Рекурсивные методы в Java — введение в Java 017 #    рекурсия экрана   Многие из нас пытались сфотографировать себя в зеркале так, что бы в зеркале было снова изображение фотографирующего в зеркале и так до бесконечности. Это и есть частный случай рекурсии. В программировании это - метод, вызывающий(повторяющий) сам себя.\nРекурсия в программировании #  Давайте попробуем найти факториал числа\npublic class Factorial{ static int calculateFactorial(int n){ int result = 1; for (int i = 1; i \u0026lt;=n; i ++){ result = result*i; } return result; }\tpublic static void main(String[] args){ System.out.println(calculateFactorial(4)); } } То же самое можно сделать и рекурсивным способом\n// Вычисление факториала числа public class Factorial{ public static void main(String[] args) { System.out.println(fact(5)); } static int fact(int digits) { if (digits \u0026gt; 1) { return digits * fact(digits - 1); // здесь переменная умножается на метод \t} else { return 1; } } } Ещё раз:\n{ if (digits \u0026lt;= 1) // Базовый случай { return 1; } else { return digits * fact(digits - 1); // рекурсивный вызов с аргументом, который стремится к базовoму случаю. } Рекурсия и тернарный оператор вместе #  static int fact(int num) { return ((num \u0026gt; 1) ? num * fact(num - 1) : 1); } Рекурсия в программировании – это вызов функцией самой себя с другими аргументами. Во избежание бесконечного цикла самозапуска внутри функции должно быть условие выхода (digits \u0026lt;= 1). Рекурсивная функция вызывает себя с аргументами, которые стремятся к базовому случаю (digits - 1).\nЧисла Фибоначчи #  Решение задачи обычным способом:\npublic class Fibonaci { public static void main(String[] args){ int n0 = 1; int n1 = 1; int n2; System.out.print(n0+\u0026#34; \u0026#34;+n1+\u0026#34; \u0026#34;); for(int i = 3; i \u0026lt;= 11; i++){ n2=n0+n1; System.out.print(n2+\u0026#34; \u0026#34;); n0=n1; n1=n2; } System.out.println(); } } Рекурсивное решение\nstatic int calculateFibonaci(int n){ if (n == 0){ return 0; } if (n == 1){ return 1; } else{ return calculateFibonaci(n - 1) + calculateFibonaci(n - 2); } } Дополнительные материалы #   Рекурсия - https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D1%8F Фибоначчи - https://ru.wikipedia.org/wiki/%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8 Java-recursion - https://www.baeldung.com/java-recursion  "});index.add({'id':71,'href':'/school/java/basic-course/018-java-array/','title':"018 Java Array",'content':"Массивы в Java — введение в Java 018 #  Давайте представим себе книжную полку на которой стоит множество книг. Или камеру хранения на вокзале со множеством ячеек. У каждой ячейки есть номер и в каждой из них может находиться чемодан.\n  Массив в реальной жизни - камера хранения   В Java тоже есть похожие \u0026ldquo;книжные полки\u0026rdquo; или \u0026ldquo;камеры хранения\u0026rdquo;. Называются они массивами и в массиве мы можем хранить множество переменных одного типа. То есть на книжной полке с книгами не может стоять любимая ваза. Только книги. Если вазы так нужны, то мы можем выделить для всех ваз отдельную полку.\n  Массив в реальной жизни   Java - это строго типизированный язык программирования. И именно здесь она проявляет строгость. Данные одного типа можно хранить только с данными этого же типа.\nМассив определение в Java #  Массив — это однородная (пронумерованная) структура данных, в которой хранится конечное число элементов.\nОдин элемент - одна ячейка.\nОбъявление массива #  Пример объявления(декларации) dataType[] arrayName;\nint[] myArray; String[] user; double[] gpsPoints; boolean[] truthTable; char[] cyrillicAlphabet; Срабатывает и такой синтаксис объявления массива dataType arrayName[];:\nint myArray[]; String user[]; double gpsPoints[]; boolean truthTable[]; char cyrillicAlphabet[]; Этот синтаксис наследован от языка C, который является родным папой Явы. Его можно встретить, это не является ошибкой. Но рекомендуется использовать первый вариант.\nИнициализация происходит с помощью знакомого нам по Scanner оператора new, массивы также можно объявлять и инициализировать одновременно:\n\u0026lt;\u0026lt;ИмяУжеОбъявленнойПеременной\u0026gt;\u0026gt; = new \u0026lt;\u0026lt;типДанных\u0026gt;\u0026gt; \u0026lt;\u0026lt;ДлинаМассива\u0026gt;\u0026gt; int[] field; field = new int[10]; //в массиве 10 ячеек. String[] fourSeasons = new String[] {\u0026quot;Vivaldi\u0026quot;, \u0026quot;Tchaikovsky\u0026quot;, \u0026quot;Astor Piazzolla\u0026quot;, \u0026quot;Stephen Edwin King\u0026quot;}; int[] numberFibonacci = new int[] {0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144} String[] germanCity = new String[] {\u0026quot;Berlin\u0026quot;, \u0026quot;München\u0026quot;, \u0026quot;Dresden\u0026quot;,\u0026quot;Hamburg\u0026quot;,\u0026quot;Köln\u0026quot;,\u0026quot;Potsdam\u0026quot;} То есть мы можем задать пустой массив определённого размера или заполненный массив, где длина массива очевидна. Инициализированный массив не может быть неопределённого размера.\nДавайте на последнем примере посчитаем элементы в массиве и общее количество знаков, к примеру.\npublic static void germanCity() { String[] germanCity = new String[]{\u0026quot;Berlin\u0026quot;, \u0026quot;München\u0026quot;, \u0026quot;Dresden\u0026quot;, \u0026quot;Hamburg\u0026quot;, \u0026quot;Köln\u0026quot;, \u0026quot;Potsdam\u0026quot;}; int allGermanCity = germanCity.length; int allLetter = 0; for (int i = 0; i \u0026lt; allGermanCity - 1; i++) { allLetter = allLetter + germanCity[i].length(); } System.out.println(\u0026quot;allGermanCity: \u0026quot; + allGermanCity); System.out.println(\u0026quot;allLetter: \u0026quot; + allLetter); } Дополнительные материалы #  Полезно и обязательно стоит почитать:\n Официальный сайт - https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html Русскоязычная адоптация - https://javarush.ru/groups/posts/massivy-java https://www.baeldung.com/java-arrays-guide  Домашнее задание #  Постарайтесь не гуглить чужие решения. Все нужные знания у вас есть. Гуглите методы, которые вам могут понадобиться:\n Заполните массив случайным числами и выведете максимальное, минимальное и среднее значение. Для генерации случайного числа используйте метод Math.random(), который возвращает значение в промежутке [0, 1]. Напишите программу, которая выводит на консоль простые числа в промежутке от [2, 100]. Используйте для решения этой задачи оператор \u0026ldquo;%\u0026rdquo; (остаток от деления) и циклы.  "});index.add({'id':72,'href':'/school/java/basic-course/019-java-foreach/','title':"019 Java Foreach",'content':"For-Each Loop — введение в Java 019 #  Мы изучали цикл for, где в определённом диапазоне мы перебирали элементы. Существует брат уже изученного цикла - for each (фор ич). For each позволяет просмотреть все элементы массива не обращаясь к ним по индексу. Например:\npublic class Main { public static void main(String[] args) { int[] arr = new int[]{1, 2, 3, 4, 5, 6}; printArray(arr); } public static void printArray(int[] inputArray) { System.out.println(\u0026#34;Начинаем печатать массив\u0026#34;); for (int element : inputArray) { System.out.print(element + \u0026#34;, \u0026#34;); } System.out.println(); System.out.println(\u0026#34;Конец печати массива\u0026#34;); } } For each отличается от for тем, что он проработает со всеми элементами массива, а for только с теми , на которые попал шаг.\nВыгодное отличие, благодаря этому нам не надо указывать с какого элемента начинать работать и длину массива.\nЕдинственное, помните, что foreach не изменит массив. И в цикле распечатки сработают. Но массив останется неизменным. Попробуйте сами.\npublic static void arrayTryAndCry() { int arrayLength = 10; int[] myArray = new int[arrayLength]; for (int element : myArray) { element = element + (int) (Math.random() * 100); System.out.print(element + \u0026#34;, \u0026#34;); } System.out.println(); printArray(myArray); } Так происходит потому, что изменить содержимое массива мы можем только обратившись к отдельному элементу по индексу.\nНесмотря на данное ограничение цикл foreach является достаточно популярным и его следует знать.\nДомашнее задание #   Распечатайте с помощью foreach строковый массив Распечатайте с помощью foreach массив символов.  "});index.add({'id':73,'href':'/school/java/basic-course/020-java-varargs/','title':"020 Java Varargs",'content':"Variable arguments - Varargs — введение в Java 020 #  Давайте сложим два числа:\npublic class Main { public static void main(String[] args) { sum(2, 3); } private static int sum(int a, int b) { return a + b; } } Удобно находить сумму, но не очень. Ведь если надо найти сумму трёх чисел, надо писать другой метод:\npublic class Main { public static void main(String[] args) { sum(2, 3, 5); } private static int sum(int a, int b, int c) { return a + b + c; } } А если надо найти сумму трёх чисел? десяти? В конце месяца надо посчитать оплату за все рабочие дни. Дней каждый месяц разное количество, разное количество праздников, прогулов, больничных. Так что вопрос закономерный. Что делать, если мы не знаем сколько значений нам надо сложить?\nОтвет кроется в ключевом слове Varargs.\npublic class MyVarargs { public static void main(String[] args) { System.out.println(sum(2, 3, 4, 7, 9)); } private static int sum(int... allDigits) { int result = 0; for (int digit : allDigits) { result = result + digit; } return result; } } Метод sum принимает любое количество целочисленных переменных. Об этом нам говорит эта запись (**int\u0026hellip; allDigits **). И дальше мы можем работать с переменными, как будто у нас есть массив данных.\nЕсли хотите, то Varargs принимает распакованный массив как аргумент метода и подготавливает его для нас на лету.\n  — Может ли такой метод принимать другие данные?\n— Ответ да. Но с оговорками. Variable arguments могут быть приняты лишь единожды и они принимаются последними.\n  public class MyLovelyVarargs { public static void main(String[] args) { System.out.println(sum(\u0026#34;мой интересный массив\u0026#34;, 2, 3, 4, 7, 9)); } private static int sum(String arrayName, int... allDigits) { int result = 0; for (int digit : allDigits) { result = result + digit; } return result; } } Домашнее задание #   Напишите метод, который принимает динамичное количество городов Германии и выводит их столбиком. Создайте новый массив, в котором города записаны от коротких имён к длинным.  "});index.add({'id':74,'href':'/school/java/basic-course/021-java-multi-dimensional-array/','title':"021 Java Multi Dimensional Array",'content':"Многомерные массивы в Java — введение в Java 021 #  Давайте повторим, что такое массив\nМассив #  Массив — это совокупность однотипных переменных, для обращения к которым используется общее имя. Java допускает создание массивов любого типа, которые могут иметь одно или несколько измерений.\n  многомерный массив на примере февраля   static void month() { int[][] monthCalendar; monthCalendar = new int[4][7]; for (int outer = 0; outer \u0026lt; monthCalendar.length; outer++) { for (int inner = 0; inner \u0026lt; monthCalendar[outer].length; inner++) { monthCalendar[outer][inner] = outer*7 + inner + 1; System.out.println(monthCalendar[outer][inner]); } } System.out.println(\u0026#34;Plz Computer, print me element [1][3], I expect 11: \u0026#34; + monthCalendar[1][3]); } Я создал массив с четырьмя строчками и семью столбиками. Создал два фор цикла для инициализации массива. Во внешнем цикле я обхожу столбики, во внутреннем цикле я обхожу строчки. В программировании отсчёт начинается с нуля, а не с единицы и формула инициализации дней февраля равна порядковый номер строчки умноженный на семь плюс порядковый номер столбика.\nМожно создать трёхмерный и четырёхмерный массив. Если будете играться, то имейте в виду, что с увеличением многомерности вы увеличивайте потребляемые мощности. Для ознакомления с основами программирования достаточно двухмерного массива(уверенного использования) и понятия, что массив может состоять из массивов. И массивы могут быть разными, как и длина строчек и столбцов. По этому есть такое понятие как длина массива и длина измерения массива.\nДвумерный массив #  Двумерный массив - это массив одномерных массивов. Если вам нужен двумерный массив, то используйте пару квадратных скобок. Доступ к конкретному элементу массива осуществляется по его индексу.\nString[][] myArray = new String[5][3]; myArray[0][0] = \u0026#34;1\u0026#34;; myArray[0][1] = \u0026#34;Матвеев\u0026#34;; myArray[0][2] = \u0026#34;№01978434\u0026#34;; myArray[1][0] = \u0026#34;2\u0026#34;; myArray[1][1] = \u0026#34;Васечкин\u0026#34;; myArray[1][2] = \u0026#34;№21321434\u0026#34;; myArray[2][0] = \u0026#34;3\u0026#34;; myArray[2][1] = \u0026#34;Сидоров\u0026#34;; myArray[2][2] = \u0026#34;№412345678\u0026#34;; myArray[3][0] = \u0026#34;4\u0026#34;; myArray[3][1] = \u0026#34;Петечкин\u0026#34;; myArray[3][2] = \u0026#34;№587654321\u0026#34;; myArray[3][0] = \u0026#34;4\u0026#34;; myArray[3][1] = \u0026#34;Герасимов\u0026#34;; myArray[3][2] = \u0026#34;№79898321\u0026#34;;    ID ученика Фамилия ученика Номер паспорта     1 Матвеев №01978434   2 Васечкин №21321434   3 Сидоров №412345678   4 Петечкин №587654321   5 Герасимов №79898321    Трёхмерный массив фиксированной длины:\nint[][][] a1 = new int[10][20][30]; Многомерные и несимметричные массивы #  byte[][][] byteArray = { { {0, 1, 2}, {1, 2, 3}, {3, 4, 5} }, { {1, 2, 3}, {2, 3, 4}, {5, 6, 7} } }; int[][] a1 = new int[5][];// двумерный массив с 5 строками a1[0] = new int [1]; a1[1] = new int [2]; a1[2] = new int [3]; a1[3] = new int [4]; a1[4] = new int [5]; for (int[] array : a1) { for (int element : array) { System.out.print(element + \u0026#34; \u0026#34;); } System.out.println(); } 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 int[][] example = { {1}, {2, 2}, {3, 3, 3}, {4, 4, 4, 4}, {5, 5, 5, 5, 5} }; Класс java.util.Arrays содержит методы для работы с массивами.\n copyOf() − предназначен для копирования массива copyOfRange() − копирует часть массива toString() − позволяет получить все элементы в виде одной строки fill() − заполняет массив переданным значением (удобно использовать, если нам необходимо значение по умолчанию для массива) equals() − проверяет на идентичность массивы deepEquals() − проверяет на идентичность массивы массивов  int arr[] = {2, 2, 1, 8, 3, 2, 2, 4, 2}; // To fill complete array with a particular value Arrays.fill(arr, 10); System.out.println(\u0026#34;Array completely filled with 10\\n\u0026#34; + Arrays.toString(arr)); System.out.printf(\u0026#34;Modified arr[] : %s\u0026#34;, Arrays.toString(arr)); Домашнее задание #   Создать таблицу умножения(Пифагора) для младших классов при помощи двумерного массива.   Таблица Пифагора    Создайте массив размерностью 5 на 6 и заполните его случайными числами (в диапазоне от 0 до 99 ). Выведите на консоль третью строку Просуммируйте все элементы двумерного массива. Дан двумерный массив, содержащий отрицательные и положительные числа. Выведете на экран номера тех ячеек массива, которые содержат отрицательные числа. Отсортируйте элементы в строках двумерного массива по возрастанию Даны матрицы С и D размерностью 3 на 3 и заполненные случайными числами в диапазоне от 0 до 99.  Выполните по отдельности сначала сложение, потом умножения матриц друг на друга. Выведете исходные матрицы и результат вычислений на консоль.    Дополнительные материалы #   Multi-Dimensional Arrays In Java Многомерные массивы  "});index.add({'id':75,'href':'/school/java/basic-course/022-java-public-static-void-main/','title':"022 Java Public Static Void Main",'content':"Что же это такое — public static void main(String[] args) — введение в Java 022 #  Давайте попробуем приподнять завесу тайны с метода, который мы писали чаще всего. Надо всё-таки понимать хоть немного, то что мы пишем.\nМы уже знаем, что такое main - точка входа в нашу программу. Мы знаем что такое void - это просто метод который выполняет код. Пришло время понять, что мы знаем, что String[] args это просто переменная args, которая является строковым массивом.\nДавайте попробуем программировать без IDE по олдскульному.\nСоздадим файл Main.java\npublic class Main { public static void main(String[] args) { for (String str : args) { System.out.println(\u0026#34;My arguments = \u0026#34; + str); } } } Надеюсь мы ещё помним цикл фор ич, с помощью которого я хочу распечатать массив args.\nВыйдем в консоль или терминал:\nСкомпилируем файл:\njavac Main.java и запустим:\njava Main ich lerne deutsch на экране мы получим:\nMy arguments = ich My arguments = lerne My arguments = deutsch Теперь мы должны в принципе осознавать, что String[] это массив, args имя переменной массива. И что при запуске мы можем передать эти аргументы, и в теле метода обработать.\nЕщё раз. Наш метод принимает массив и выводит его на экран. При запуске программы в терминале мы передаём эти аргументы. Точно так же мы могли не вывести их на экран, а в зависимости от проверки выполнить команды. Например при передаче кодового слова кофе -\u0026gt; запустить метод готовки кофе.\nДомашнее задание #  Напишите программу, которая запускает метод готовки кофе, если переданный аргумент в командной строке \u0026ldquo;coffee\u0026rdquo; или \u0026ldquo;c\u0026rdquo;.\n"});index.add({'id':76,'href':'/school/java/basic-course/023-java-return-break-continue/','title':"023 Java Return Break Continue",'content':"Операторы перехода break, continue, return — введение в Java 023 #  Оператор break #    пример работы оператора break   С оператором break мы познакомились в шестом уроке во время знакомства с оператором выбора Switch. С помощью break мы выходим из вариантов выбора.\nПрерывание цикла #  С помощью break можно выходить из цикла.\npublic static void searchFor () { for (int i = 0; i \u0026lt;= 20; i++) { if (i == 4) { break; // выйти из цикла при i равной 4.  } System.out.println(\u0026#34;Значение i: \u0026#34; + i); } System.out.println(\u0026#34;Цикл завершен.\u0026#34;); } Я могу себе представить такой вариант выхода из бесконечных методов или рекурсивных, где через оператор break мы указываем условия выхода.\n// Использование break для выхода из while-цикла. import java.util.Scanner; class UserInputSum { public static void main(String[] args) { Double number, sum = 0.0; Scanner input = new Scanner(System.in); while (true) { System.out.print(\u0026#34;Enter a number: \u0026#34;); number = input.nextDouble(); if (number \u0026lt; 0.0) { break; } sum += number; } System.out.println(\u0026#34;Sum = \u0026#34; + sum); } } В языках постарше Java был оператор goto - перейти к определённой строчке. Break не должен и не может заменить оператор, который в Java не внесли создатели. Но зоны видимости и break позволяют делать интересные вещи:\npublic class MyBreak { static void quarantine(boolean quarantine) { // мы создаём зону \tquarantineZone: { if (quarantine) { break quarantineZone; // выход из зоны карантина \t} System.out.println(\u0026#34;Мы в картантине\u0026#34;); } } } Но я буду согласен с вами, если вы скажите, что решить вопрос с карантином можно было бы и через if-else.\nОператор continue #  Оператор continue имеет смысл и стоит использовать только в циклах. С его помощью можно завершить шаг и перейти к следующему кругу.\n// Демонстрирует continue. public class MyContinue { public static void main(String[] args) { for (int i = 0; i \u0026lt; 10; i++) { System.out.print(i + \u0026#34; \u0026#34;); if (i % 2 == 0) { continue; } System.out.println(\u0026#34;\u0026#34;); } } } /* Вывод в терминале 0 1 2 3 4 5 6 7 8 9 */ Оператор return #  Return мы знаем из урока номер 12 про методы.\nОператор return используют для выполнения явного выхода из метода. Оператор можно использовать в любом месте метода для возврата управления тому объекту, который вызвал данный метод. Таким образом, return прекращает выполнение метода, в котором он находится.\n// Демонстрирует return. public class MyReturn { static void quarantine(Boolean quarantine) { quarantineZone: { if (quarantine) { return; // выход из программы \t} System.out.println(\u0026#34;Мы в картантине\u0026#34;); } } } Как мы видим return можно использовать и в исполняем методе, а не только в возвратном. Не уверен, что эти операторы с завтрашнего дня надо активно использовать, но знать их надо.\nМетки #  \u0026ldquo;quarantineZone:\u0026rdquo; в предыдущем коде - метка.\nДополнительные ссылки #   Операции с метками, branching statements The Java continue and break Keywords  Домашнее задание #   Напишите программу, которая выводит на консоль простые числа в промежутке от [2, 100].\nИспользуйте для решения этой задачи оператор \u0026ldquo;%\u0026rdquo; (остаток от деления) и циклы. Используйте циклы с метками.  "});index.add({'id':77,'href':'/school/java/basic-course/026-java-magic-color/','title':"026 Java Magic Color",'content':""});index.add({'id':78,'href':'/school/java/basic-course/028-java-sorting-algorithms-02-coctail-and-comb-sort/','title':"028 Java Sorting Algorithms 02 Coctail and Comb Sort",'content':"Сортировка расчёской(Combsort) и сортировка перемешиванием(Cocktail sort) — введение в Java 028 #  Обе сортировки базируются на пузырьковой сортировке и вносят в неё некоторые улучшения. По этому мы их и рассмотрим вместе. Давайте начнём с коктейльной сортировки.\nСортировка перемешиванием(Cocktail sort) #    Cocktail sort   Cocktail sort - шейкерная сортировка, двунаправленная, коктейльная, сортировка перемешиванием.\nВ пузырьковой сортировке мы проходимся раз за разом, от начала массива до его конца и проверяем попарные элементы и если надо меняем их местами.\nЕсли задуматься, то становится очевидным, что нам незачем каждый раз идти до конца, ведь за один проход мы вытаскиваем самый \u0026ldquo;тяжёлый\u0026rdquo; элемент наверх. И возможно, что если мы после каждого прохода будем уменьшать диапазон, то сэкономим компьютерное время.\nЕсли задуматься глубже, то мы может проходить по массиву не только от начала до конца, но и из конца в начало. И если в обычном проходе мы вытаскивали тяжелые элементы, то на обратном пути мы можем подбирать самый лёгкий элемент и снова уменьшать диапазон сверяемых элементов.\nСамое позднее, когда динамичные начало и конец нашего массива встретятся - сортировка будет закончена.\nВзяв за основу эти два принципа мы и попробуем улучшить нашу пузырьковую сортировку.\nПомимо самой коктейльной сортировки я создам вспомогательные методы для создания и копирования созданного массива. Так как это теоретически помогает отсортировать массив разными способами и сравнить их.\nimport java.util.Arrays; public class CocktailSort { public static void main(String[] args) { int[] array = createArray(10); int[] newArray = myNewCopyArray(array); System.out.println(\u0026#34;Оригинал массива \u0026#34; + Arrays.toString(array)); System.out.println(\u0026#34;Копия массива \u0026#34; + Arrays.toString(newArray)); System.out.println(\u0026#34;Коктейльная сортировка \u0026#34; + Arrays.toString(cocktailSort(newArray))); } private static int[] cocktailSort(int[] array) { int start = 0; int end = array.length - 1; while (start \u0026lt;= end) { boolean swapped = false; for (int j = start; j \u0026lt; end; j++) { if (array[j] \u0026gt; array[j + 1]) { int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; swapped = true; } } end--; for (int k = end; k \u0026gt; start; k--) { if (array[k] \u0026lt; array[k - 1]) { int temp = array[k - 1]; array[k - 1] = array[k]; array[k] = temp; swapped = true; } } start++; if (!swapped) { break; } } return array; } private static int[] myNewCopyArray(int[] array) { int[] copy = new int[array.length]; for (int i = 0; i \u0026lt; array.length; i++) { copy[i] = array[i]; } return copy; } private static int[] createArray(int length) { int[] myArray = new int[length]; for (int i = 0; i \u0026lt; length; i++) { myArray[i] = (int) (Math.random() * 100); } return myArray; } } Прошу заметить, что принципиально только 4 первые строчки метода cocktailSort чем то могут привлечь начинающего программиста. Создание переменной start, и end, объявление массива while, которые следит за обеими переменными и дополнительная проверка на \u0026ldquo;отсортированность\u0026rdquo; - swapped. Всё остальное мы как встречали в методе bubbleSort.\nСортировка расчёской (Combsort) #    Сортировка расчёской   В сортировке расчёской ставится под сомнение эффективность шага равного единице. На эту тему написано несколько диссертаций суть которых сводится к тому, что динамичным шагом устраняются черепахи. Черепахами в сортировке называют неудачно расположенные элементы, которые по закону подлости оказались не в том месте. В нашем случае это тяжёлые элементы в самом начале списка.\nВ сортировке расчёской, которая вычёсывает черепах мы начинаем с шага равной длине, а потом каждый раз уменьшаем его деля на константу. Константа равна 1.24733095.\nПример:\nimport java.util.Arrays; public class CombSort { public static void main(String[] args) { int[] array = createArray(30); System.out.println(Arrays.toString(array)); System.out.println(Arrays.toString(comb(array))); } public static int[] comb(int[] array) { final double stepConstant = 1.24733095; int step = array.length; while (step \u0026gt; 1) { step = (int) (step / stepConstant); System.out.println(step); for (int i = 0; step + i \u0026lt; array.length; i++) { if (array[i] \u0026gt; array[i + step]) { swap(array, i, i + step); } } } return array; } public static void swap(int[] array, int x, int y) { int temp = array[x]; array[x] = array[y]; array[y] = temp; } private static int[] createArray(int length) { int[] myArray = new int[length]; for (int i = 0; i \u0026lt; length; i++) { myArray[i] = (int) (Math.random() * 100); } return myArray; } } Прошу заметить, что переменные можно поменять не только как я показал в - 24-м уроке, но и написав свой собственный метод и передав ему массив и два индекса для обмена.\n  Дополнительные ссылки #   Сортировка перемешиванием О сортировках (пузырьковой, быстрой, расческой) - https://habr.com/ru/post/357640/ Описание алгоритмов сортировки и сравнение их производительности - https://habr.com/ru/post/335920/  "});index.add({'id':79,'href':'/school/java/basic-course/029-java-sorting-algorithms-03-insertionsort/','title':"029 Java Sorting Algorithms 03 Insertionsort",'content':"Сортировка вставками - Insertion Sort — введение в Java 029 #  Сортировка вставками - делит условно массив на две части. В левой собирается отсортированная часть, а из правой части берутся элементы и по очереди ставятся на своё место. Пожалуй, это самый близкий метод сортировки к обычному человеческому мышлению. Берём по одному и ставим на своё место.\nЧасто возникает вопрос, как можно узнать, что левая часть отсортирована? Давайте представим, что у нас есть полное собрание сочинений какого-нибудь политика. Или нет, лучше пусть у нас дома будет полная энциклопедия Брокгауза и Ефрона.\n  энциклопедия Брокгауза и Ефрона   86 полутомов. Пронумерованных. Прекрасный пример контейнера с информацией, массива. Одна беда. Представьте себе, что в библиотеке играли дети, и все книги оказались на полу. На полу они лежат в беспорядке и неотсортированные.\nМы берём первую книгу с пола и нам попадается том 27. Мы ставим эту книгу на книжную полку, и в этот момент массив становится отсортированным. Несмотря на то, что в массиве всего один элемент.\nМы берём следующую книгу и подносим её к уже отсортированной, что бы посмотреть где её ставить справа или слева. И в итоге выставляем все книги по порядку.\nИменно так и работает Insertion Sort, или сортировка вставками.\nДавайте посмотрим сортировку в танце:\n  Псевдокод:\nfor j = 2 to A.length do key = A[j] i = j-1 while (i \u0026gt; 0 and A[i] \u0026gt; key) do A[i + 1] = A[i] i = i - 1 end while A[i+1] = key end for И ещё раз более быстрая визуализация в работе.\n  Несмотря на огромное предисловие сам код достаточно компактен и сортировка считается одной из простых сортировок.\nСортировка вставками, java-code: #  public class InsertionSort { public static void main(String[] args) { System.out.println(\u0026#34;Сортировка массива\u0026#34;); int[] array = {22, 100, 55, 33, 88, 7}; insertionSortImperative(array); System.out.println(Arrays.toString(array)); } private static void insertionSortImperative(int[] input) { for (int i = 1; i \u0026lt; input.length; i++) { // временная переменная, которая хранит значение  int newElement = input[i]; // цикл начался не с нуля, а с единицы - location предыдущее МЕСТО от элемента массива  int location = i - 1; System.out.println(\u0026#34;i или круг = \u0026#34; + i); System.out.println(newElement); System.out.println(input[location]); System.out.println(\u0026#34;**\u0026#34;); // пока значение от location больше значения элемента проверки  while (location \u0026gt;= 0 \u0026amp;\u0026amp; input[location] \u0026gt; newElement) { System.out.println(\u0026#34;Находимся в цикл while при i = \u0026#34; + i); System.out.println(newElement); System.out.println(input[location]); System.out.println(\u0026#34;++\u0026#34;); // присвоить значению на котором был элемент проверки значение предыдущего  input[location + 1] = input[location]; location = location - 1; // Декремент location  } input[location + 1] = newElement; // значению location+1 передаём значение из памяти  } } } Сортировка вставками. Рекурсия, java-code: #  public class InsertionSortRecursion { public static void main(String[] args) { int[] arr = {10, 6, 3, 9, 15, 27}; insertionSortRecursive(arr); System.out.println(Arrays.toString(arr)); } public static void insertionSortRecursive(int[] input) { insertionSortRecursive(input, input.length); } private static void insertionSortRecursive(int[] input, int i) { if (i \u0026lt;= 1) { return; } insertionSortRecursive(input, i - 1); int key = input[i - 1]; int j = i - 2; while (j \u0026gt;= 0 \u0026amp;\u0026amp; input[j] \u0026gt; key) { input[j + 1] = input[j]; j = j - 1; } input[j + 1] = key; } } Объяснение рекурсии в данной сортировке - https://www.baeldung.com/java-insertion-sort.\nДополнительные ссылки #   Очень интересная и полезная статья о сортировке - https://juja.com.ua/java/algorithms/sorting-optimizing/ Немного болье, чем просто сортировка вставками - https://habr.com/ru/post/422085/ Сортировки вставками, ещё статья - https://habr.com/ru/post/415935/ https://www.codeflow.site/ru/article/java-insertion-sort https://github.com/eugenp/tutorials/tree/master/algorithms-sorting  "});index.add({'id':80,'href':'/school/java/basic-course/030-java-sorting-algorithms-04-shuttlesort/','title':"030 Java Sorting Algorithms 04 Shuttlesort",'content':"Челночная сортировка (Shuttle Sort) — введение в Java 030 #  (В разработке)\npublic class Shuttle { public static int[] shuttleSort(int[] array) { for (int i = 0; i \u0026lt; array.length - 1; i++) { // primary pass  if (array[i] \u0026gt; array[i + 1]) { int j = i - 1; int temp = array[i + 1]; // small value to move back  array[i + 1] = array[i]; while (j \u0026gt;= 0 \u0026amp;\u0026amp; array[j] \u0026gt; temp) { // go back  array[j + 1] = array[j]; // shuttle values forward  j = j - 1; } // end secondary pass  array[j + 1] = temp; // insert small value further back  } // else no secondary pass  } // end all passes  return array; } } "});index.add({'id':81,'href':'/school/java/basic-course/031-java-sorting-algorithms-05-quicksort/','title':"031 Java Sorting Algorithms 05 Quicksort",'content':"Быстрая сортировка, сортировка Хоара - quicksort — введение в Java 031 #  (В разработке)\nimport java.util.Arrays; public class QuickSort { public static void quickSort(int[] array, int low, int high) { if (array.length == 0) return; //завершить выполнение, если длина массива равна 0  if (low \u0026gt;= high) return;//завершить выполнение если уже нечего делить  // выбрать опорный элемент  int middle = low + (high - low) / 2; int opora = array[middle]; // разделить на подмассивы, который больше и меньше опорного элемента  int i = low, j = high; while (i \u0026lt;= j) { while (array[i] \u0026lt; opora) { i++; } while (array[j] \u0026gt; opora) { j--; } if (i \u0026lt;= j) {//меняем местами  int temp = array[i]; array[i] = array[j]; array[j] = temp; i++; j--; } } // вызов рекурсии для сортировки левой и правой части  if (low \u0026lt; j) quickSort(array, low, j); if (high \u0026gt; i) quickSort(array, i, high); } public static void main(String[] args) { int[] x = {8, 0, 4, 7, 3, 7, 10, 12, -3}; System.out.println(\u0026#34;Было\u0026#34;); System.out.println(Arrays.toString(x)); int low = 0; int high = x.length - 1; quickSort(x, low, high); System.out.println(\u0026#34;Стало\u0026#34;); System.out.println(Arrays.toString(x)); } }  https://otus.ru/nest/post/788/ https://www.youtube.com/watch?v=eNUM23f6g-s https://www.youtube.com/watch?v=9CBRBSWTl-E https://www.youtube.com/watch?v=PrxjH8R-kE8 https://www.youtube.com/watch?v=wWjPUoWcjJo\u0026amp;list=PL58qjcU5nk8vl5zPGFSTG0hLQ9YGFKp0p\u0026amp;index=6 https://www.codeflow.site/ru/article/java-quicksort https://java-master.com/%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B9-%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8-quick-sort-%D0%B2-java/ Быстрая сортировка  "});index.add({'id':82,'href':'/school/java/basic-course/032-java-sorting-algorithms-big-o/','title':"032 Java Sorting Algorithms Big O",'content':"Оценка сложности алгоритмов, или Что такое О(log n) — введение в Java 032 #  Существует множество способов сортировки данных.\nНапример:\n Пузырьковая сортировка - Bubble Sort  Сортировка перемешиванием, шейкерная сортировка, коктейльная сортировка Сортировка расчёской   Сортировка выбором - Selection Sort Сортировка вставками - Insertion Sort Челночная сортировка - Shuttle Sort Сортировка Шелла - Shell sort Быстрая сортировка - quickSort Сортировка слиянием - merge sort Пирамидальная сортировка «Сортировка кучей» - Heapsort Сортировка подсчётом - Counting Sort Поразрядная сортировка - Radix Sort  Первая часть этого списка перечисляет простые сортировки. Вторая часть сортировок уже посложнее. Сложнее они могут быть не только для человека, но и для компьютера. Если для одной программы надо выполнить меньшее количество операций, то можно говорить о сложности алгоритма вычислений.\nЛогарифм #  "});index.add({'id':83,'href':'/school/java/basic-course/033-java-binary-tree/','title':"033 Java Binary Tree",'content':"Двоичное дерево — введение в Java 033 #  Введение От выбора заветной пары джинсов из гардероба до выбора следующего фильма для просмотра с партнером, человеческая жизнь наполнена поиском вещей.\nВ то время как в повседневной жизни люди обычно ищут между несколькими, если не дюжиной вещей. Компьютерам приходится иметь дело с поиском по данным сравнительно больших объемов по их размеру и количеству.\nЭто требует от компьютера наличия эффективного метода для максимально эффективного поиска внутри своих массивов и коллекций.\nВозможность поиска информации в коллекции является одной из основных функциональных точек приложения.\nДвоичный поиск Двоичный поиск (иногда известный как Логарифмический поиск) - это широко распространенный алгоритм для поиска отсортированного массива по позиции заданного элемента.\nОн работает по принципу \u0026ldquo;разделяй и властвуй\u0026rdquo;, сравнивая целевой элемент со средним элементом массива. Если найдено совпадение - его позиция возвращается, в противном случае, если целевой элемент меньше среднего, то он не может находиться справа от среднего элемента.\nПоэтому правая половина массива (включая средний элемент) отбрасывается, а поиск продолжается на левой половине массива с использованием того же подхода.\nАналогично, если целевой элемент больше среднего, он не может находиться в месте, предшествующем середине массива. Поэтому левая половина массива отбрасывается, а поиск продолжается в правой половине.\nЭто повторяется до тех пор, пока не будет найдено совпадение.\nМы можем сделать это предположение просто потому, что знаем, что массив отсортирован заранее. Если бы он не был отсортирован, мы не смогли бы реализовать двоичный поиск.\nВот визуальное представление того, как работает Бинарный Поиск:\npublic static int iterativeSearch(int[] arrayToSearch, int element) { int lowIndex = 0; int highIndex = arrayToSearch.length-1; // Holds the position in array for given element  // Initial negative integer set to be returned if no match was found on array  int elementPos = -1; // If lowIndex less than highIndex, there\u0026#39;s still elements in the array  while (lowIndex \u0026lt;= highIndex) { int midIndex = (lowIndex + highIndex) / 2; if (element == arrayToSearch[midIndex]) { elementPos = midIndex; break; } else if (element \u0026lt; arrayToSearch[midIndex]) { highIndex = midIndex-1; } else if (element \u0026gt; arrayToSearch[midIndex]) { lowIndex = midIndex+1; } } return elementPos; } public static int recursiveSearch(int[] arrayToSearch, int element) { return recursiveSearch(arrayToSearch, element, 0, arrayToSearch.length-1); } private static int recursiveSearch(int[] arrayToSearch, int element, int lowIndex, int highIndex) { // If lowIndex surpasses highIndex, the element has not been found  if (lowIndex \u0026gt; highIndex) return -1; // Default assumption is that the element is not found  int elementPos = -1; int midIndex = (lowIndex + highIndex) / 2; if (element == arrayToSearch[midIndex]) { elementPos = midIndex; } else if (element \u0026lt; arrayToSearch[midIndex]) { recursiveSearch(arrayToSearch, element, lowIndex, midIndex-1); } else if (element \u0026gt; arrayToSearch[midIndex]) { recursiveSearch(arrayToSearch, element, midIndex+1, highIndex); } return elementPos; } https://stackabuse.com/binary-search-in-java/\n"});index.add({'id':84,'href':'/school/java/basic-course/034-java-try-catch-finally/','title':"034 Java Try Catch Finally",'content':"Exception — введение в Java 034 #  Предположим, что пишем программу для кофеавтомата.\nПри выборе капучино, наш автомат собирает напиток из воды, кофе, молока. Мы же ему написали:\n Возьми одну порцию воды Возьми одну порцию кофе Возьми порцию молока Сделай по рецепту кофе.  Если одного из ингридиентов не будет, то автомат не сможет сделать кофе и возможно зависнет в ожидании ингредиентов или поломается и техник должен будет перезапускать его заново.\nПодобные непонятные ситуации возникают при выполнении недопустимых действий, как деление на ноль; при запросе данных, которых больше нет, например сайт, который был указан для отправки сообщений временно или вообще больше не работает.\nСитуации могут быть ожидаемы(всегда при работе с записью на диск, а вдруг у пользователя нет прав?) или из опыта работы прошлых лет (вода в кофейном автомате иногда заканчивается).\nСуть в том, что ошибки надо отловить, а программу довести до конца. Ведь если воды в кофейном автомате на вокзале нет, то деньги надо вернуть, отослать сигнал бедствия офис-менеджеру или технику по емайлу и выключить автомат.\nДавайте посмотрим на примере.\npublic static void main(String[] args){ int[] array = new int[5]; int element = array[5]; } При запуске этого метода мы получим ошибку:\nException in thread \u0026#34;main\u0026#34; java.lang.ArrayIndexOutOfBoundsException: 5 at TestTryCatch.main(TestTryCatch.java:9) В ошибке говорится, что у нас ArrayIndexOutOfBoundsException, что логично, ведь на пятом месте в массиве будет шестой элемент, а у нас массив всего из пяти элементов. И нам советуется попробовать трай кэтч TestTryCatch. Давайте попробуем:\n  public class TestTryCatch { public static void main(String[] args){ /*\tint[] array = new int[5]; int element = array[5];*/ testArr(); } static void testArr(){ // инициализация массива с пятью элементами. \tint[] array = new int[5]; try { int element = array[5]; // это условие никогда не будет выполнено \t// потому что у нас в этом месте ошибка \tSystem.out.println(\u0026#34;Я НИКОГДА НЕ УВИЖУ ТЕРМИНАЛ\u0026#34;); } catch (ArrayIndexOutOfBoundsException ex) { System.out.println(\u0026#34;Мы поймали ошибку\u0026#34;); } // выполнение оставшейся части программы \tSystem.out.println(\u0026#34;Область видимости программы вне блока try catch\u0026#34;); } } Прошу заметить, что оператор catch знал какая ошибка может возникнуть и словил именно её - попытку взять несуществующий элемент. Если у нас будет другая ошибка, то мы её не словим. Если мы добавим в блок try строчку int a = 5/0;, то наша программа завершится новым Exception.\nException in thread \u0026quot;main\u0026quot; java.lang.ArithmeticException: / by zero at TestTryCatch.testArr(TestTryCatch.java:16) at TestTryCatch.main(TestTryCatch.java:10) В такой ситуации мы можем добавить finally\npublic class TestTryCatch { public static void main(String[] args) { /*\tint[] array = new int[5]; int element = array[5];*/ testArr(); } static void testArr() { // инициализация массива с пятью элементами. \tint[] array = new int[5]; try { int a = 5 / 0; int element = array[5]; // это условие никогда не будет выполнено \t// потому что у нас в этом месте ошибка \tSystem.out.println(\u0026#34;Я НИКОГДА НЕ УВИЖУ ТЕРМИНАЛ\u0026#34;); } catch (ArrayIndexOutOfBoundsException ex) { System.out.println(\u0026#34;Мы поймали ошибку\u0026#34;); } finally { System.out.println(\u0026#34;Выполнение финального блока: шеф всё плохо, посмотри код\u0026#34;); } // выполнение оставшейся части программы \tSystem.out.println(\u0026#34;Область видимости программы вне блока try catch\u0026#34;); } } Домашнее задание #  Есть номера домов в текстовом формате. Используя Integer.parseInt попытаться спарсить различные строки. Возможные ошибки отловить и вывести на экран полезную для оператора информацию.\nПодсказка:\nString str1 = \u0026#34;123\u0026#34;; int num1 = Integer.parseInt(str); String str2 = \u0026#34;№123\u0026#34;; int num2 = Integer.parseInt(str2); Проверьте возможно ли оператор catch использовать несколько раз:\ntry { //code } catch (ExceptionType1 e1) { // catch block } catch (ExceptionType1 e2) { // catch block } finally { // finally block always executes } Дополнительные материалы #  https://docs.oracle.com/javase/tutorial/essential/exceptions/try.html\n"});index.add({'id':85,'href':'/school/java/basic-course/035-java-creating-a-jar-file-/','title':"035 Java Creating a J a R File ",'content':"JAR - Java Archive — введение в Java 035 #  Приложения обычно делают, что бы они использовались. Java приложения обычно собираются в JAR-файл.\nДумаю разумно уже сейчас узнать как собираются JAR приложения, потому что это совсем не сложно, ну и у JAR файлов есть один приятный бонус. Мы можем использовать их как собственную библиотеку.\nСоздание JAR #  Давайте просто попробуем в IDEA создать наш JAR-файл.\nЗаходим в меню File -\u0026gt; Project Structure.\n  Создание JAR, первый шаг   Переходим в подменю Artifacts и нажимаем на плюсик в следующей колонке.\n  Создание JAR, второй шаг   Выбираем создание JAR from modules with dependencies\n  Создание JAR, третий шаг   Выбираем директорию куда должен создаться файл и возможную точку входа в программу (Main-class).\n  Создание JAR, четвёртый шаг   В итоге у нас должно было получиться что-то вроде этого.\nПосле этого заходим в меню Build-\u0026gt; Build Artifacts\nВ директории out стоит поискать наш созданный JAR.\nКак добавить в проект уже имеющиеся наработки. #  https://commons.apache.org/proper/commons-lang/download_lang.cgi https://github.com/pengrad/java-telegram-bot-api/releases\nДополнительные материалы #  https://docs.oracle.com/javase/tutorial/deployment/jar/build.html\nДомашнее задание #   Создать JAR библиотеку подсчитывания BMI и высчитывания сжигаемых колорий. Создать JAR библиотеку проверки високосного года. Создать JAR библиотеку генерации пароля.  "});index.add({'id':86,'href':'/school/java/basic-course/036-java-ressourcen/','title':"036 Java Ressourcen",'content':"Ресурсы и умение ими пользоваться — введение в Java 036 #  Мы немного оторвёмся от самого кодинга и осмотримся по сторонам.\nЯве исполнилось четверть века и за эти годы появилось множество статей, книг, рефератор, полезных и конечно же бесполезных ресурсов. И в этом хаосе мы попробуем найти островки логики и порядка.\n Сайт Oracle - именно там лежит официальная документация к языку. Им надо научиться пользоваться и научиться читать документацию. С умением читать официальную документацию Oracle программистом будет стать намного легче. Нас прежде всего интерисует Java восьмой и выше версии. Baeldung - сайт посвящённый фреймворку Java Spring, самой Java, JVM, Kotlin и всему окружению. Сайт начинался одним энтузиастом и превратился в серьёзный проект. Javarush - на сайте множество хорошего и полезного контента. И этот контент очень часто полезный, на русском языке и бесплатный. Github - десятки тысяч Java - проектов начинающих программистов занимаются тем же, что и вы. Пишут \u0026ldquo;Hello World\u0026rdquo;, расчёт процентов вклада банка, труб в бассейне и прочих задач, которые решают все начинающие программисты в самом начале своего пути. Многие из этих проектов лежат в паблике и гитхаб предоставляет возможность просматривать эти проекты и искать в них на ключевые слова. bitbucket.org и gitlab.com предлагают такой же сервис, как и github. Вполне возможно, что вам они тоже смогу помочь. stackoverflow.com - самый полезный сайт для программистов. Обычно там уже задан тот вопрос, который вас мучает и даже получен ответ и не один. Хабр - прекрасный технический ресурс на русском языке с новостями и мануалами от новичков и опытных программистов. Medium.com - подпишитесь на технический хаб своего развития и получается регулярные обновления в удбоной для вас форме. Coursera - главное не купить, а пройти. На сайте достаточно полноценных курсов программирования. Udemy - ещё один ресурс с хорошими курсами. Youtube.com/ - здесь так много интересных каналов, что советовать только один, это обижать другие. Spring - Существует мнение, что бэкенд сайта может быть только на строготипизированном языке. За бэкенд на Java отвечает фреймворк Spring. regex101 - сайт, который должен помогать с регулярными выражениями. hackerrank - на сайте регулярно появляются новые задачи в популярных языках, алгоритмах, базах данных и прочих цифровых науках. И там можно решать задачи на скорость, соревнуясь с друзьями.  Книги #  Очень тяжело советовать книги. Для начинающих с картинками. Для продвинутых с непонятными формулами. Я перечислю книги для тех, кто в самом начале пути, с небольшими пояснениями.\nВы можете покупать любую книгу, которая описывает Java 8 и выше. На данный момент, 2020-ый год, обучение основам Java на восьмой или выше версии ни чем друг от друга не отличается. И скорее всего не будет отличаться и в будущем. Java славится своей стабильностью, постоянностью и обратной совместимостью.\n Чистый код. Создание, анализ и рефакторинг - Robert Martin. Эта книга будет полезна вам уже сейчас. С примерами автор поясняет что такое хороший, а что такое плохой код. Очень рекомендую.    Чистый код   \u0026ldquo;Изучаем Java\u0026rdquo;, O´Reilly - Head First Java. Некоторые вещи там действительно рассказаны неплохо. Для начинающих и с \u0026ldquo;картинками\u0026rdquo;. Это не самая обязательная книга, но она даёт взглянуть на Java простым взглядом. Эту книгу можно вполне брать для второго мнения к любому уроку для закрепления материала. Издательство O´Reilly страется выпускать качественный материал.    Изучаем Java    Effective Java - Joschua Bloch. Полезная книга, для всех Java - программистов. Эта книга поможет вам, если вы решите соединить свой дальнейший путь с Java.   Effective Java     Паттерны проектирования, O´Reilly - Например «Head First. Паттерны проектирования. Обновленное юбилейное издание» от Эрик Фримен, Элизабет Фримен, Кэтти Сьерра, Берт Бейтс.   Паттерны проектирования     «Приёмы объектно-ориентированного проектирования. Паттерны проектирования» - паттерны проектирования от «Банда четырёх»: Эрих Гамма, Ричард Хелм, Ральф Джонсон, Джон Влиссидес. Эту книгу учат не только джависты. Банда четырёх широко известна. Обязательное чтиво.   Паттерны проектирования. Банда четырёх     Алгоритмы. Теория и практическое применение, Род Стивенс. Надеюсь, вы понимаете важность алгоритмов.   Алгоритмы     \u0026ldquo;Полное руководство Java\u0026rdquo;, Герберт Шилдт - The Complete Reference, Herbert Schildt. Я признаюсь, что сам ещё не осилил всю книгу. Один из моих учителей практически молился на этого автора. Для продвинутых.     MySQL по максимуму - Oreilly - Бэрон Шварц, Петр Зайцев, Вадим Ткаченко. Базы данных для тех, кто хочет с ними работать.     Тестирование Дот Ком, или Пособие по жестокому обращению с багами в интернет-стартапах. Художественная книга о тестировании.     Домашнее задание #   Зарегистрироваться на Github, bitbucket, gitlab, habr, medium, stackoverflow, hackerrank. Создать себе емайл для работы /цифровой личности. Выбери себе отдельный браузер для работы. В работе с сайтами используй разные пароли. Пароли можно хранить например здесь https://lastpass.com/ План развития разработчика - https://javarush.ru/groups/posts/2398-java-plan-deystviy Если вы будете продолжать обучение, то эта ссылка поможет вам очень сильно - https://habr.com/ru/post/488144/. Немного о современной Java и JDK.  "});index.add({'id':87,'href':'/school/java/exercises/08-exercises-java/','title':"08 Exercises Java",'content':"Массивы, введение — 08 #   Заполните массив случайным числами и выведете максимальное, минимальное и среднее значение. Для генерации случайного числа используйте метод Math.random(), который возвращает значение в промежутке [0, 1]. Напишите программу, которая выводит на консоль простые числа в промежутке от [2, 100]. Используйте для решения этой задачи оператор \u0026ldquo;%\u0026rdquo; (остаток от деления) и циклы. Перевести String с именем и фамилией в массив Char. Внести все чётные цифры от нуля до 100 в массив int. Создать заполненый массив с именем, фамилией, отчеством. Сгенерировать 100 раз случайное число от нуля до 100, записать их в массив.  Посчитать среднее значение элементов, узнать минимальное и максимальное значение в массиве. отсортировать по порядку все значения в массиве.   Как поменять элементы массива в обратном порядке? Поменяйте. Дан массив целых чисел и ещё одно целое число(передаётся аргументами). Удалите все вхождения этого числа из массива (пропусков быть не должно). Дано два массива int. Сложите по порядку элементы между собой и верните итоговый массив. Объявите массив char и заполните его кирилическим алфавитом. Создать метод, который принимает аргументами имя, фамилию, емайл и если эти поля не пустые, то выдают сообщение о том, что данные успешно записаны, в противном случае, что данных для записи недостаточно. Поле емайл проверить на наличие знака \u0026quot;@\u0026quot;-at, не собачка, а эт! и точки. Найти количество различных элементов массива. Пример: для 1 4 5 1 1 3 ответ 4. Дан массив. Перемешать его элементы случайным образом так, чтобы каждый элемент оказался на новом месте. Сгенерируйте массив со случайными числами. Как поменять элементы массива в обратном порядке? Поменяйте.  "});index.add({'id':88,'href':'/school/java/exercises/13-exercises-java-string-01/','title':"13 Exercises Java String 01",'content':"Доброе утро, String - уно #   Given a string name, e.g. \u0026ldquo;Bob\u0026rdquo;, return a greeting of the form \u0026ldquo;Hello Bob!\u0026rdquo;. helloName(\u0026quot;Bob\u0026quot;) → \u0026quot;Hello Bob!\u0026quot; helloName(\u0026quot;Alice\u0026quot;) → \u0026quot;Hello Alice!\u0026quot; helloName(\u0026quot;X\u0026quot;) → \u0026quot;Hello X!\u0026quot;  Given an \u0026ldquo;out\u0026rdquo; string length 4, such as \u0026ldquo;\u0026laquo;\u0026raquo;\u0026rdquo;, and a word, return a new string where the word is in the middle of the out string, e.g. \u0026ldquo;\u0026laquo;word\u0026raquo;\u0026rdquo;. Note: use str.substring(i, j) to extract the String starting at index i and going up to but not including index j. makeOutWord(\u0026quot;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026quot;, \u0026quot;Yay\u0026quot;) → \u0026quot;\u0026lt;\u0026lt;Yay\u0026gt;\u0026gt;\u0026quot; makeOutWord(\u0026quot;\u0026lt;\u0026lt;\u0026gt;\u0026gt;\u0026quot;, \u0026quot;WooHoo\u0026quot;) → \u0026quot;\u0026lt;\u0026lt;WooHoo\u0026gt;\u0026gt;\u0026quot; makeOutWord(\u0026quot;[[]]\u0026quot;, \u0026quot;word\u0026quot;) → \u0026quot;[[word]]\u0026quot;  Given a string of even length, return the first half. So the string \u0026ldquo;WooHoo\u0026rdquo; yields \u0026ldquo;Woo\u0026rdquo;. firstHalf(\u0026quot;WooHoo\u0026quot;) → \u0026quot;Woo\u0026quot; firstHalf(\u0026quot;HelloThere\u0026quot;) → \u0026quot;Hello\u0026quot; firstHalf(\u0026quot;abcdef\u0026quot;) → \u0026quot;abc\u0026quot;  Given 2 strings, return their concatenation, except omit the first char of each. The strings will be at least length 1. nonStart(\u0026quot;Hello\u0026quot;, \u0026quot;There\u0026quot;) → \u0026quot;ellohere\u0026quot; nonStart(\u0026quot;java\u0026quot;, \u0026quot;code\u0026quot;) → \u0026quot;avaode\u0026quot; nonStart(\u0026quot;shotl\u0026quot;, \u0026quot;java\u0026quot;) → \u0026quot;hotlava\u0026quot;  Given a string, return a string length 1 from its front, unless front is false, in which case return a string length 1 from its back. The string will be non-empty. theEnd(\u0026quot;Hello\u0026quot;, true) → \u0026quot;H\u0026quot; theEnd(\u0026quot;Hello\u0026quot;, false) → \u0026quot;o\u0026quot; theEnd(\u0026quot;oh\u0026quot;, true) → \u0026quot;o\u0026quot;  Given a string, return true if it ends in \u0026ldquo;ly\u0026rdquo;. endsLy(\u0026quot;oddly\u0026quot;) → true endsLy(\u0026quot;y\u0026quot;) → false endsLy(\u0026quot;oddy\u0026quot;) → false  Given a string of odd length, return the string length 3 from its middle, so \u0026ldquo;Candy\u0026rdquo; yields \u0026ldquo;and\u0026rdquo;. The string length will be at least 3. middleThree(\u0026quot;Candy\u0026quot;) → \u0026quot;and\u0026quot; middleThree(\u0026quot;and\u0026quot;) → \u0026quot;and\u0026quot; middleThree(\u0026quot;solving\u0026quot;) → \u0026quot;lvi\u0026quot;  Given 2 strings, a and b, return a new string made of the first char of a and the last char of b, so \u0026ldquo;yo\u0026rdquo; and \u0026ldquo;java\u0026rdquo; yields \u0026ldquo;ya\u0026rdquo;. If either string is length 0, use \u0026lsquo;@\u0026rsquo; for its missing char. lastChars(\u0026quot;last\u0026quot;, \u0026quot;chars\u0026quot;) → \u0026quot;ls\u0026quot; lastChars(\u0026quot;yo\u0026quot;, \u0026quot;java\u0026quot;) → \u0026quot;ya\u0026quot; lastChars(\u0026quot;hi\u0026quot;, \u0026quot;\u0026quot;) → \u0026quot;h@\u0026quot;  Given a string, if the string begins with \u0026ldquo;red\u0026rdquo; or \u0026ldquo;blue\u0026rdquo; return that color string, otherwise return the empty string. seeColor(\u0026quot;redxx\u0026quot;) → \u0026quot;red\u0026quot; seeColor(\u0026quot;xxred\u0026quot;) → \u0026quot;\u0026quot; seeColor(\u0026quot;blueTimes\u0026quot;) → \u0026quot;blue\u0026quot;  Given a string, return a new string made of 3 copies of the first 2 chars of the original string. The string may be any length. If there are fewer than 2 chars, use whatever is there. extraFront(\u0026quot;Hello\u0026quot;) → \u0026quot;HeHeHe\u0026quot; extraFront(\u0026quot;ab\u0026quot;) → \u0026quot;ababab\u0026quot; extraFront(\u0026quot;H\u0026quot;) → \u0026quot;HHH\u0026quot;  Given a string and a second \u0026ldquo;word\u0026rdquo; string, we\u0026rsquo;ll say that the word matches the string if it appears at the front of the string, except its first char does not need to match exactly. On a match, return the front of the string, or otherwise return the empty string. So, so with the string \u0026ldquo;hippo\u0026rdquo; the word \u0026ldquo;hi\u0026rdquo; returns \u0026ldquo;hi\u0026rdquo; and \u0026ldquo;xip\u0026rdquo; returns \u0026ldquo;hip\u0026rdquo;. The word will be at least length 1. startWord(\u0026quot;hippo\u0026quot;, \u0026quot;hi\u0026quot;) → \u0026quot;hi\u0026quot; startWord(\u0026quot;hippo\u0026quot;, \u0026quot;xip\u0026quot;) → \u0026quot;hip\u0026quot; startWord(\u0026quot;hippo\u0026quot;, \u0026quot;i\u0026quot;) → \u0026quot;h\u0026quot;  Given two strings, a and b, return the result of putting them together in the order abba, e.g. \u0026ldquo;Hi\u0026rdquo; and \u0026ldquo;Bye\u0026rdquo; returns \u0026ldquo;HiByeByeHi\u0026rdquo;. makeAbba(\u0026quot;Hi\u0026quot;, \u0026quot;Bye\u0026quot;) → \u0026quot;HiByeByeHi\u0026quot; makeAbba(\u0026quot;Yo\u0026quot;, \u0026quot;Alice\u0026quot;) → \u0026quot;YoAliceAliceYo\u0026quot; makeAbba(\u0026quot;What\u0026quot;, \u0026quot;Up\u0026quot;) → \u0026quot;WhatUpUpWhat\u0026quot;  Given a string, return a new string made of 3 copies of the last 2 chars of the original string. The string length will be at least 2. extraEnd(\u0026quot;Hello\u0026quot;) → \u0026quot;lololo\u0026quot; extraEnd(\u0026quot;ab\u0026quot;) → \u0026quot;ababab\u0026quot; extraEnd(\u0026quot;Hi\u0026quot;) → \u0026quot;HiHiHi\u0026quot;  Given a string, return a version without the first and last char, so \u0026ldquo;Hello\u0026rdquo; yields \u0026ldquo;ell\u0026rdquo;. The string length will be at least 2. withoutEnd(\u0026quot;Hello\u0026quot;) → \u0026quot;ell\u0026quot; withoutEnd(\u0026quot;java\u0026quot;) → \u0026quot;av\u0026quot; withoutEnd(\u0026quot;coding\u0026quot;) → \u0026quot;odin\u0026quot;  Given a string, return a \u0026ldquo;rotated left 2\u0026rdquo; version where the first 2 chars are moved to the end. The string length will be at least 2. left2(\u0026quot;Hello\u0026quot;) → \u0026quot;lloHe\u0026quot; left2(\u0026quot;java\u0026quot;) → \u0026quot;vaja\u0026quot; left2(\u0026quot;Hi\u0026quot;) → \u0026quot;Hi\u0026quot;  Given a string, return a version without both the first and last char of the string. The string may be any length, including 0. withoutEnd2(\u0026quot;Hello\u0026quot;) → \u0026quot;ell\u0026quot; withoutEnd2(\u0026quot;abc\u0026quot;) → \u0026quot;b\u0026quot; withoutEnd2(\u0026quot;ab\u0026quot;) → \u0026quot;\u0026quot;  Given a string and an int n, return a string made of the first and last n chars from the string. The string length will be at least n. nTwice(\u0026quot;Hello\u0026quot;, 2) → \u0026quot;Helo\u0026quot; nTwice(\u0026quot;Chocolate\u0026quot;, 3) → \u0026quot;Choate\u0026quot; nTwice(\u0026quot;Chocolate\u0026quot;, 1) → \u0026quot;Ce\u0026quot;  Given a string, return true if \u0026ldquo;bad\u0026rdquo; appears starting at index 0 or 1 in the string, such as with \u0026ldquo;badxxx\u0026rdquo; or \u0026ldquo;xbadxx\u0026rdquo; but not \u0026ldquo;xxbadxx\u0026rdquo;. The string may be any length, including 0. Note: use .equals() to compare 2 strings. hasBad(\u0026quot;badxx\u0026quot;) → true hasBad(\u0026quot;xbadxx\u0026quot;) → true hasBad(\u0026quot;xxbadxx\u0026quot;) → false  Given two strings, append them together (known as \u0026ldquo;concatenation\u0026rdquo;) and return the result. However, if the concatenation creates a double-char, then omit one of the chars, so \u0026ldquo;abc\u0026rdquo; and \u0026ldquo;cat\u0026rdquo; yields \u0026ldquo;abcat\u0026rdquo;. conCat(\u0026quot;abc\u0026quot;, \u0026quot;cat\u0026quot;) → \u0026quot;abcat\u0026quot; conCat(\u0026quot;dog\u0026quot;, \u0026quot;cat\u0026quot;) → \u0026quot;dogcat\u0026quot; conCat(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;) → \u0026quot;abc\u0026quot;  Given a string, return true if the first 2 chars in the string also appear at the end of the string, such as with \u0026ldquo;edited\u0026rdquo;. frontAgain(\u0026quot;edited\u0026quot;) → true frontAgain(\u0026quot;edit\u0026quot;) → false frontAgain(\u0026quot;ed\u0026quot;) → true  Given a string, if a length 2 substring appears at both its beginning and end, return a string without the substring at the beginning, so \u0026ldquo;HelloHe\u0026rdquo; yields \u0026ldquo;lloHe\u0026rdquo;. The substring may overlap with itself, so \u0026ldquo;Hi\u0026rdquo; yields \u0026ldquo;\u0026rdquo;. Otherwise, return the original string unchanged. without2(\u0026quot;HelloHe\u0026quot;) → \u0026quot;lloHe\u0026quot; without2(\u0026quot;HelloHi\u0026quot;) → \u0026quot;HelloHi\u0026quot; without2(\u0026quot;Hi\u0026quot;) → \u0026quot;\u0026quot;  Given a string, if the first or last chars are \u0026lsquo;x\u0026rsquo;, return the string without those \u0026lsquo;x\u0026rsquo; chars, and otherwise return the string unchanged. withoutX(\u0026quot;xHix\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX(\u0026quot;xHi\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX(\u0026quot;Hxix\u0026quot;) → \u0026quot;Hxi\u0026quot;  The web is built with HTML strings like \u0026ldquo;Yay\u0026rdquo; which draws Yay as italic text. In this example, the \u0026ldquo;i\u0026rdquo; tag makes and which surround the word \u0026ldquo;Yay\u0026rdquo;. Given tag and word strings, create the HTML string with tags around the word, e.g. \u0026ldquo;Yay\u0026rdquo;. makeTags(\u0026quot;i\u0026quot;, \u0026quot;Yay\u0026quot;) → \u0026quot;\u0026lt;i\u0026gt;Yay\u0026lt;/i\u0026gt;\u0026quot; makeTags(\u0026quot;i\u0026quot;, \u0026quot;Hello\u0026quot;) → \u0026quot;\u0026lt;i\u0026gt;Hello\u0026lt;/i\u0026gt;\u0026quot; makeTags(\u0026quot;cite\u0026quot;, \u0026quot;Yay\u0026quot;) → \u0026quot;\u0026lt;cite\u0026gt;Yay\u0026lt;/cite\u0026gt;\u0026quot;  Given a string, return the string made of its first two chars, so the String \u0026ldquo;Hello\u0026rdquo; yields \u0026ldquo;He\u0026rdquo;. If the string is shorter than length 2, return whatever there is, so \u0026ldquo;X\u0026rdquo; yields \u0026ldquo;X\u0026rdquo;, and the empty string \u0026quot;\u0026quot; yields the empty string \u0026ldquo;\u0026rdquo;. Note that str.length() returns the length of a string. firstTwo(\u0026quot;Hello\u0026quot;) → \u0026quot;He\u0026quot; firstTwo(\u0026quot;abcdefg\u0026quot;) → \u0026quot;ab\u0026quot; firstTwo(\u0026quot;ab\u0026quot;) → \u0026quot;ab\u0026quot;  Given 2 strings, a and b, return a string of the form short+long+short, with the shorter string on the outside and the longer string on the inside. The strings will not be the same length, but they may be empty (length 0). comboString(\u0026quot;Hello\u0026quot;, \u0026quot;hi\u0026quot;) → \u0026quot;hiHellohi\u0026quot; comboString(\u0026quot;hi\u0026quot;, \u0026quot;Hello\u0026quot;) → \u0026quot;hiHellohi\u0026quot; comboString(\u0026quot;aaa\u0026quot;, \u0026quot;b\u0026quot;) → \u0026quot;baaab\u0026quot;  Given a string, return a \u0026ldquo;rotated right 2\u0026rdquo; version where the last 2 chars are moved to the start. The string length will be at least 2. right2(\u0026quot;Hello\u0026quot;) → \u0026quot;loHel\u0026quot; right2(\u0026quot;java\u0026quot;) → \u0026quot;vaja\u0026quot; right2(\u0026quot;Hi\u0026quot;) → \u0026quot;Hi\u0026quot;  Given a string of even length, return a string made of the middle two chars, so the string \u0026ldquo;string\u0026rdquo; yields \u0026ldquo;ri\u0026rdquo;. The string length will be at least 2. middleTwo(\u0026quot;string\u0026quot;) → \u0026quot;ri\u0026quot; middleTwo(\u0026quot;code\u0026quot;) → \u0026quot;od\u0026quot; middleTwo(\u0026quot;Practice\u0026quot;) → \u0026quot;ct\u0026quot;  Given a string and an index, return a string length 2 starting at the given index. If the index is too big or too small to define a string length 2, use the first 2 chars. The string length will be at least 2. twoChar(\u0026quot;java\u0026quot;, 0) → \u0026quot;ja\u0026quot; twoChar(\u0026quot;java\u0026quot;, 2) → \u0026quot;va\u0026quot; twoChar(\u0026quot;java\u0026quot;, 3) → \u0026quot;ja\u0026quot;  Given a string, return a string length 2 made of its first 2 chars. If the string length is less than 2, use \u0026lsquo;@\u0026rsquo; for the missing chars. atFirst(\u0026quot;hello\u0026quot;) → \u0026quot;he\u0026quot; atFirst(\u0026quot;hi\u0026quot;) → \u0026quot;hi\u0026quot; atFirst(\u0026quot;h\u0026quot;) → \u0026quot;h@\u0026quot;  Given a string of any length, return a new string where the last 2 chars, if present, are swapped, so \u0026ldquo;coding\u0026rdquo; yields \u0026ldquo;codign\u0026rdquo;. lastTwo(\u0026quot;coding\u0026quot;) → \u0026quot;codign\u0026quot; lastTwo(\u0026quot;cat\u0026quot;) → \u0026quot;cta\u0026quot; lastTwo(\u0026quot;ab\u0026quot;) → \u0026quot;ba\u0026quot;  Given two strings, append them together (known as \u0026ldquo;concatenation\u0026rdquo;) and return the result. However, if the strings are different lengths, omit chars from the longer string so it is the same length as the shorter string. So \u0026ldquo;Hello\u0026rdquo; and \u0026ldquo;Hi\u0026rdquo; yield \u0026ldquo;loHi\u0026rdquo;. The strings may be any length. minCat(\u0026quot;Hello\u0026quot;, \u0026quot;Hi\u0026quot;) → \u0026quot;loHi\u0026quot; minCat(\u0026quot;Hello\u0026quot;, \u0026quot;java\u0026quot;) → \u0026quot;ellojava\u0026quot; minCat(\u0026quot;java\u0026quot;, \u0026quot;Hello\u0026quot;) → \u0026quot;javaello\u0026quot;  Given a string, return a version without the first 2 chars. Except keep the first char if it is \u0026lsquo;a\u0026rsquo; and keep the second char if it is \u0026lsquo;b\u0026rsquo;. The string may be any length. Harder than it looks. deFront(\u0026quot;Hello\u0026quot;) → \u0026quot;llo\u0026quot; deFront(\u0026quot;java\u0026quot;) → \u0026quot;va\u0026quot; deFront(\u0026quot;away\u0026quot;) → \u0026quot;aay\u0026quot;  Given a string, if one or both of the first 2 chars is \u0026lsquo;x\u0026rsquo;, return the string without those \u0026lsquo;x\u0026rsquo; chars, and otherwise return the string unchanged. This is a little harder than it looks. withoutX2(\u0026quot;xHi\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX2(\u0026quot;Hxi\u0026quot;) → \u0026quot;Hi\u0026quot; withoutX2(\u0026quot;Hi\u0026quot;) → \u0026quot;Hi\u0026quot;   © - codingbat.com\n"});index.add({'id':89,'href':'/school/java/exercises/16-exercises-java-recursion-01/','title':"16 Exercises Java Recursion 01",'content':"Задачи для курса Java-basic - рекурсия #   Given n of 1 or more, return the factorial of n, which is n * (n-1) * (n-2) \u0026hellip; 1. Compute the result recursively (without loops).\nДано N большее либо равное 1. Вернуть факториал N = n * (n-1) * (n-2) \u0026hellip;. 1. Вычислить результат рекурсивно (без циклов). factorial(1) → 1 factorial(2) → 2 factorial(3) → 6  We have bunnies standing in a line, numbered 1, 2, \u0026hellip; The odd bunnies (1, 3, ..) have the normal 2 ears. The even bunnies (2, 4, ..) we\u0026rsquo;ll say have 3 ears, because they each have a raised foot. Recursively return the number of \u0026ldquo;ears\u0026rdquo; in the bunny line 1, 2, \u0026hellip; n (without loops or multiplication).\nУ нас есть очередь из кроликов и мы получаем количество стоящих в этой очереди кроликов. У нечётных кроликов по два уха. А у чётных кроликов вроде как по три уха. Это из-за того, что они все подняли ногу. Посчитайте количество видимых нами \u0026ldquo;ушей\u0026rdquo;. Не использовать циклы или умножение. bunnyEars2(0) → 0 bunnyEars2(1) → 2 bunnyEars2(2) → 5  Given a non-negative int n, return the count of the occurrences of 7 as a digit, so for example 717 yields 2. (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). Дано положительное целочисленное N. Верните количество семёрок в числе. 717 - вернёт 2. Обратите внимание, что модуло 10 даёт вам правую цифру(126 % 10 равно 6), а деление на 10 удалит правую цифру(126 / 10 равно 12). Авторы задачи были к нам слишком добры и практически решили её прямов условии. count7(717) → 2 count7(7) → 1 count7(123) → 0  Given a string, compute recursively (no loops) the number of lowercase \u0026lsquo;x\u0026rsquo; chars in the string.\nПолучив строку, вычислите рекурсивно (без циклов) количество строчных символов \u0026lsquo;x\u0026rsquo; в строке. countX(\u0026quot;xxhixx\u0026quot;) → 4 countX(\u0026quot;xhixhix\u0026quot;) → 3 countX(\u0026quot;hi\u0026quot;) → 0  Given a string, compute recursively (no loops) a new string where all appearances of \u0026ldquo;pi\u0026rdquo; have been replaced by \u0026ldquo;3.14\u0026rdquo;.\nПолучив строку, вычислите рекурсивно (без циклов) новую строку, в которой все появления \u0026ldquo;pi\u0026rdquo; были заменены на \u0026ldquo;3.14\u0026rdquo;. changePi(\u0026quot;xpix\u0026quot;) → \u0026quot;x3.14x\u0026quot; changePi(\u0026quot;pipi\u0026quot;) → \u0026quot;3.143.14\u0026quot; changePi(\u0026quot;pip\u0026quot;) → \u0026quot;3.14p\u0026quot;  Given a string, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a \u0026ldquo;*\u0026rdquo;. pairStar(\u0026quot;hello\u0026quot;) → \u0026quot;hel*lo\u0026quot; pairStar(\u0026quot;xxyy\u0026quot;) → \u0026quot;x*xy*y\u0026quot; pairStar(\u0026quot;aaaa\u0026quot;) → \u0026quot;a*a*a*a\u0026quot;  Count recursively the total number of \u0026ldquo;abc\u0026rdquo; and \u0026ldquo;aba\u0026rdquo; substrings that appear in the given string. countAbc(\u0026quot;abc\u0026quot;) → 1 countAbc(\u0026quot;abcxxabc\u0026quot;) → 2 countAbc(\u0026quot;abaxxaba\u0026quot;) → 2  Given a string, compute recursively the number of times lowercase \u0026ldquo;hi\u0026rdquo; appears in the string, however do not count \u0026ldquo;hi\u0026rdquo; that have an \u0026lsquo;x\u0026rsquo; immedately before them. countHi2(\u0026quot;ahixhi\u0026quot;) → 1 countHi2(\u0026quot;ahibhi\u0026quot;) → 2 countHi2(\u0026quot;xhixhi\u0026quot;) → 0  Given a string and a non-empty substring sub, compute recursively the number of times that sub appears in the string, without the sub strings overlapping. strCount(\u0026quot;catcowcat\u0026quot;, \u0026quot;cat\u0026quot;) → 2 strCount(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;) → 1 strCount(\u0026quot;catcowcat\u0026quot;, \u0026quot;dog\u0026quot;) → 0  We have a number of bunnies and each bunny has two big floppy ears. We want to compute the total number of ears across all the bunnies recursively (without loops or multiplication). bunnyEars(0) → 0 bunnyEars(1) → 2 bunnyEars(2) → 4  We have triangle made of blocks. The topmost row has 1 block, the next row down has 2 blocks, the next row has 3 blocks, and so on. Compute recursively (no loops or multiplication) the total number of blocks in such a triangle with the given number of rows. triangle(0) → 0 triangle(1) → 1 triangle(2) → 3  Given a non-negative int n, compute recursively (no loops) the count of the occurrences of 8 as a digit, except that an 8 with another 8 immediately to its left counts double, so 8818 yields 4. Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). count8(8) → 1 count8(818) → 2 count8(8818) → 4  Given a string, compute recursively (no loops) the number of times lowercase \u0026ldquo;hi\u0026rdquo; appears in the string. countHi(\u0026quot;xxhixx\u0026quot;) → 1 countHi(\u0026quot;xhixhix\u0026quot;) → 2 countHi(\u0026quot;hi\u0026quot;) → 1  Given a string, compute recursively a new string where all the \u0026lsquo;x\u0026rsquo; chars have been removed. noX(\u0026quot;xaxb\u0026quot;) → \u0026quot;ab\u0026quot; noX(\u0026quot;abc\u0026quot;) → \u0026quot;abc\u0026quot; noX(\u0026quot;xx\u0026quot;) → \u0026quot;\u0026quot;  Given a string, compute recursively a new string where all the lowercase \u0026lsquo;x\u0026rsquo; chars have been moved to the end of the string. endX(\u0026quot;xxre\u0026quot;) → \u0026quot;rexx\u0026quot; endX(\u0026quot;xxhixx\u0026quot;) → \u0026quot;hixxxx\u0026quot; endX(\u0026quot;xhixhix\u0026quot;) → \u0026quot;hihixxx\u0026quot;  Given a string, compute recursively (no loops) the number of \u0026ldquo;11\u0026rdquo; substrings in the string. The \u0026ldquo;11\u0026rdquo; substrings should not overlap. count11(\u0026quot;11abc11\u0026quot;) → 2 count11(\u0026quot;abc11x11x11\u0026quot;) → 3 count11(\u0026quot;111\u0026quot;) → 1  Given a string that contains a single pair of parenthesis, compute recursively a new string made of only of the parenthesis and their contents, so \u0026ldquo;xyz(abc)123\u0026rdquo; yields \u0026ldquo;(abc)\u0026rdquo;. parenBit(\u0026quot;xyz(abc)123\u0026quot;) → \u0026quot;(abc)\u0026quot; parenBit(\u0026quot;x(hello)\u0026quot;) → \u0026quot;(hello)\u0026quot; parenBit(\u0026quot;(xy)1\u0026quot;) → \u0026quot;(xy)\u0026quot;  Given a string and a non-empty substring sub, compute recursively if at least n copies of sub appear in the string somewhere, possibly with overlapping. N will be non-negative. strCopies(\u0026quot;catcowcat\u0026quot;, \u0026quot;cat\u0026quot;, 2) → true strCopies(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;, 2) → false strCopies(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;, 1) → true  The fibonacci sequence is a famous bit of mathematics, and it happens to have a recursive definition. The first two values in the sequence are 0 and 1 (essentially 2 base cases). Each subsequent value is the sum of the previous two values, so the whole sequence is: 0, 1, 1, 2, 3, 5, 8, 13, 21 and so on. Define a recursive fibonacci(n) method that returns the nth fibonacci number, with n=0 representing the start of the sequence. fibonacci(0) → 0 fibonacci(1) → 1 fibonacci(2) → 1  Given a non-negative int n, return the sum of its digits recursively (no loops). Note that mod (%) by 10 yields the rightmost digit (126 % 10 is 6), while divide (/) by 10 removes the rightmost digit (126 / 10 is 12). sumDigits(126) → 9 sumDigits(49) → 13 sumDigits(12) → 3  Given base and n that are both 1 or more, compute recursively (no loops) the value of base to the n power, so powerN(3, 2) is 9 (3 squared). powerN(3, 1) → 3 powerN(3, 2) → 9 powerN(3, 3) → 27  Given a string, compute recursively (no loops) a new string where all the lowercase \u0026lsquo;x\u0026rsquo; chars have been changed to \u0026lsquo;y\u0026rsquo; chars. changeXY(\u0026quot;codex\u0026quot;) → \u0026quot;codey\u0026quot; changeXY(\u0026quot;xxhixx\u0026quot;) → \u0026quot;yyhiyy\u0026quot; changeXY(\u0026quot;xhixhix\u0026quot;) → \u0026quot;yhiyhiy\u0026quot;  Given a string, compute recursively a new string where all the adjacent chars are now separated by a \u0026ldquo;*\u0026rdquo;. allStar(\u0026quot;hello\u0026quot;) → \u0026quot;h*e*l*l*o\u0026quot; allStar(\u0026quot;abc\u0026quot;) → \u0026quot;a*b*c\u0026quot; allStar(\u0026quot;ab\u0026quot;) → \u0026quot;a*b\u0026quot;  We\u0026rsquo;ll say that a \u0026ldquo;pair\u0026rdquo; in a string is two instances of a char separated by a char. So \u0026ldquo;AxA\u0026rdquo; the A\u0026rsquo;s make a pair. Pair\u0026rsquo;s can overlap, so \u0026ldquo;AxAxA\u0026rdquo; contains 3 pairs \u0026ndash; 2 for A and 1 for x. Recursively compute the number of pairs in the given string. countPairs(\u0026quot;axa\u0026quot;) → 1 countPairs(\u0026quot;axax\u0026quot;) → 2 countPairs(\u0026quot;axbx\u0026quot;) → 1  Given a string, return recursively a \u0026ldquo;cleaned\u0026rdquo; string where adjacent chars that are the same have been reduced to a single char. So \u0026ldquo;yyzzza\u0026rdquo; yields \u0026ldquo;yza\u0026rdquo;. stringClean(\u0026quot;yyzzza\u0026quot;) → \u0026quot;yza\u0026quot; stringClean(\u0026quot;abbbcdd\u0026quot;) → \u0026quot;abcd\u0026quot; stringClean(\u0026quot;Hello\u0026quot;) → \u0026quot;Helo\u0026quot;  Given a string, return true if it is a nesting of zero or more pairs of parenthesis, like \u0026ldquo;(())\u0026rdquo; or \u0026ldquo;((()))\u0026rdquo;. Suggestion: check the first and last chars, and then recur on what\u0026rsquo;s inside them. nestParen(\u0026quot;(())\u0026quot;) → true nestParen(\u0026quot;((()))\u0026quot;) → true nestParen(\u0026quot;(((x))\u0026quot;) → false  Given a string and a non-empty substring sub, compute recursively the largest substring which starts and ends with sub and return its length. strDist(\u0026quot;catcowcat\u0026quot;, \u0026quot;cat\u0026quot;) → 9 strDist(\u0026quot;catcowcat\u0026quot;, \u0026quot;cow\u0026quot;) → 3 strDist(\u0026quot;cccatcowcatxx\u0026quot;, \u0026quot;cat\u0026quot;) → 9   Рекурсия с массивами #   Given an array of ints, compute recursively if the array contains somewhere a value followed in the array by that value times 10. We\u0026rsquo;ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array220([1, 2, 20], 0) → true array220([3, 30], 0) → true array220([3], 0) → false  Given an array of ints, compute recursively if the array contains a 6. We\u0026rsquo;ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array6([1, 6, 4], 0) → true array6([1, 4], 0) → false array6([6], 0) → true  Given an array of ints, compute recursively the number of times that the value 11 appears in the array. We\u0026rsquo;ll use the convention of considering only the part of the array that begins at the given index. In this way, a recursive call can pass index+1 to move down the array. The initial call will pass in index as 0. array11([1, 2, 11], 0) → 1 array11([11, 11], 0) → 2 array11([1, 2, 3, 4], 0) → 0   © - codingbat.com\n"});index.add({'id':90,'href':'/school/java/exercises/17-exercises-java-recursion-02/','title':"17 Exercises Java Recursion 02",'content':"Задачи для курса Java-basic - рекурсия #   Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target? This is a classic backtracking recursion problem. Once you understand the recursive backtracking strategy in this problem, you can use the same pattern for many problems to search a space of choices. Rather than looking at the whole array, our convention is to consider the part of the array starting at index start and continuing to the end of the array. The caller can specify the whole array simply by passing start as 0. No loops are needed \u0026ndash; the recursive calls progress down the array. groupSum(0, [2, 4, 8], 10) → true groupSum(0, [2, 4, 8], 14) → true groupSum(0, [2, 4, 8], 9) → false  Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with these additional constraints: all multiples of 5 in the array must be included in the group. If the value immediately following a multiple of 5 is 1, it must not be chosen. (No loops needed.)  groupSum5(0, [2, 5, 10, 4], 19) → true groupSum5(0, [2, 5, 10, 4], 17) → true groupSum5(0, [2, 5, 10, 4], 12) → false  Given an array of ints, is it possible to divide the ints into two groups, so that the sum of one group is a multiple of 10, and the sum of the other group is odd. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitOdd10(). (No loops needed.) splitOdd10([5, 5, 5]) → true splitOdd10([5, 5, 6]) → false splitOdd10([5, 5, 6, 1]) → true  Given an array of ints, is it possible to choose a group of some of the ints, beginning at the start index, such that the group sums to the given target? However, with the additional constraint that all 6\u0026rsquo;s must be chosen. (No loops needed.) groupSum6(0, [5, 6, 2], 8) → true groupSum6(0, [5, 6, 2], 9) → false groupSum6(0, [5, 6, 2], 7) → false  Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target, with this additional constraint: if there are numbers in the array that are adjacent and the identical value, they must either all be chosen, or none of them chosen. For example, with the array {1, 2, 2, 2, 5, 2}, either all three 2\u0026rsquo;s in the middle must be chosen or not, all as a group. (one loop can be used to find the extent of the identical values). groupSumClump(0, [2, 4, 8], 10) → true groupSumClump(0, [1, 2, 4, 8, 1], 14) → true groupSumClump(0, [2, 4, 4, 8], 14) → false  Given an array of ints, is it possible to divide the ints into two groups, so that the sum of the two groups is the same, with these constraints: all the values that are multiple of 5 must be in one group, and all the values that are a multiple of 3 (and not a multiple of 5) must be in the other. (No loops needed.) split53([1, 1]) → true split53([1, 1, 1]) → false split53([2, 4, 2]) → true  Given an array of ints, is it possible to choose a group of some of the ints, such that the group sums to the given target with this additional constraint: If a value in the array is chosen to be in the group, the value immediately following it in the array must not be chosen. (No loops needed.) groupNoAdj(0, [2, 5, 10, 4], 12) → true groupNoAdj(0, [2, 5, 10, 4], 14) → false groupNoAdj(0, [2, 5, 10, 4], 7) → false  Given an array of ints, is it possible to divide the ints into two groups, so that the sums of the two groups are the same. Every int must be in one group or the other. Write a recursive helper method that takes whatever arguments you like, and make the initial call to your recursive helper from splitArray(). (No loops needed.) splitArray([2, 2]) → true splitArray([2, 3]) → false splitArray([5, 2, 3]) → true   © - codingbat.com\n"});index.add({'id':91,'href':'/school/java/exercises/21-exercises-java-additional-01/','title':"21 Exercises Java Additional 01",'content':"Задачи от Евгения - факультатив фирмы ТелРан #   Given a String with different braces, check if the order of braces is correct. Every next brace can be an opening brace or should close a previous opening brace. Given a long, check if it is a palindrom Given a string with capital letters, small letters and symbols, return a string with capital letters turned into small, ans small into capital. Symbols remain unchanged.  "});index.add({'id':92,'href':'/school/java/exercises/22-exercises-java-additional-02/','title':"22 Exercises Java Additional 02",'content':"Неотсортированные задачи #   Дан int массив с рядом чисел с шагом один. Найти отсутствующий элемент. В случае если всё на месте вернуть минус один. Решите задачу тремя разными способами. findElements([1, 2, 4, 5, 6]) -\u0026gt; 3 findElements([0, 1, 2, 3, 5, 6]) -\u0026gt; 4 findElements([0, 1, 2, 3, 4, 5]) -\u0026gt; -1 //  you have a String array, for example {Petya, Kolya, Olya, Katya}. Write a method that will ask the user what is his name, if this name is in the array, then the method print: “Hello, name!”. And if the name is not in the array - \u0026ldquo;Sorry, we don\u0026rsquo;t know each other\u0026rdquo;.   "});index.add({'id':93,'href':'/school/java/exercises/solution/03-java-exercises-solution-string-01/','title':"03 Java Exercises Solution String 01",'content':""});index.add({'id':94,'href':'/school/java/exercises/solution/04-java-exercises-solution-string-02/','title':"04 Java Exercises Solution String 02",'content':""});index.add({'id':95,'href':'/school/java/exercises/solution/05-java-exercises-solution-string-03/','title':"05 Java Exercises Solution String 03",'content':"Добрый вечер, String - трес. Решение #  public class StringTresExercise { public static void main(String[] args) { System.out.println(countYZ(\u0026quot;fez day\u0026quot;)); // exp.2 System.out.println(countYZ(\u0026quot;day fez\u0026quot;)); // exp.2 System.out.println(countYZ(\u0026quot;day fyyyz\u0026quot;)); // exp.2 System.out.println(countYZ(\u0026quot;tel ran\u0026quot;)); // exp. 0 System.out.println(countYZ(\u0026quot;xyx,xzy\u0026quot;)); // exp. 1 System.out.println(countYZ(\u0026quot;London is the capital of Great Britain\u0026quot;)); // exp. 0 System.out.println(gHappy(\u0026quot;xxggxx\u0026quot;)); // exp. true System.out.println(gHappy(\u0026quot;xxgxx\u0026quot;)); // exp. false System.out.println(gHappy(\u0026quot;xxggyygxx\u0026quot;)); // exp. false } private static int countYZ(String s) { int wordsNumber = 0; for (int i = 1; i \u0026lt; s.length(); i++) { char tempChar = s.charAt(i); //if (s.charAt(i) == ' ' \u0026amp;\u0026amp; (s.charAt(i - 1) == 'y' || s.charAt(i - 1) == 'z')) { if (!Character.isLetter(tempChar) \u0026amp;\u0026amp; (s.charAt(i - 1) == 'y' || s.charAt(i - 1) == 'z')) { wordsNumber++; } } if (s.endsWith(\u0026quot;y\u0026quot;) || s.endsWith(\u0026quot;z\u0026quot;)) { wordsNumber++; } return wordsNumber; } private static boolean gHappy(String str) { int count = 0; int unhappyG = 0; for (int i = 0; i \u0026lt; str.length(); i++) { if (str.charAt(i) == 'g' \u0026amp;\u0026amp; (str.charAt(i - 1) == 'g' || str.charAt(i + 1) == 'g')) count++; else if (str.charAt(i) == 'g') unhappyG++; } if (count \u0026gt; 0 \u0026amp;\u0026amp; unhappyG == 0) return true; else if (count == 0 \u0026amp;\u0026amp; unhappyG \u0026gt; 0) return false; return false; } }"});index.add({'id':96,'href':'/school/java/exercises/solution/21-java-eugen/','title':"21 Java Eugen",'content':"Задачи от Жени #   Given a String with different braces, check if the order of braces is correct. Every next brace can be an opening brace or should close a previous opening brace. Given a long, check if it is a palindrom Given a string with capital letters, small letters and symbols, return a string with capital letters turned into small, ans small into capital. Symbols remain unchanged.   public class Palindrom { // given a long, check if it is a palindrom public static void main(String[] args) { System.out.println(isPalindrom(912345)); System.out.println(isPalindrom(912219)); }\npublic static boolean isPalindrom(long number) { String input = \u0026quot;\u0026quot;; String reversed = \u0026quot;\u0026quot;; input = String.valueOf(number); for (int i = input.length() - 1; i \u0026gt;= 0; i--) { reversed = reversed + input.charAt(i); } if (input.equals(reversed)) { return true; } else { return false; } }  }\npublic class CapitalSmallLetters { // given a string with capital letters, small letters and symbols, return a string with capital letters turned // into small, ans small into capital. Symbols remain unchanged. public static void main(String[] args) { System.out.println(makeCapitalAndSmallLetters(\u0026ldquo;AbRa CaDaBrA!?*\u0026quot;)); }\npublic static String makeCapitalAndSmallLetters(String input) { String result = \u0026quot;\u0026quot;; for (int i = 0; i \u0026lt; input.length(); i++) { if (Character.isUpperCase(input.charAt(i))) { result += input.substring(i, i + 1).toLowerCase(); } else { result += input.substring(i, i + 1).toUpperCase(); } } return result; }  }\nimport java.util.ArrayDeque; import java.util.Arrays; import java.util.Deque;\npublic class CorrectBraces { //given a String with different braces, check if the order of braces is correct. Every next brace can // be an opening brace or should close a previous opening brace.\npublic static void main(String[] args) { System.out.println(checkBraces(\u0026quot;[{}([[]])]\u0026quot;)); //exp. true System.out.println(checkBraces(\u0026quot;[{}([}[]])])\u0026quot;)); //exp. false } public static boolean checkBraces(String input) { String[] arr = new String[input.length()]; //String res = \u0026quot;\u0026quot;; for (int i = 0; i \u0026lt; input.length() - 1; i++) { if (input.charAt(i) == '[' || input.charAt(i) == '(' || input.charAt(i) == '{') { arr[i] = input.substring(i, i + 1); } else if (arr[i + 1] == \u0026quot;]\u0026quot; || arr[i + 1] == \u0026quot;)\u0026quot; || arr[i + 1] == \u0026quot;}\u0026quot;) { } // res += input.substring(i, i + 1); } System.out.println(Arrays.toString(arr)); return false; } // Deque\u0026lt;Character\u0026gt; res = new ArrayDeque\u0026lt;Character\u0026gt;(); // ArrayDeque\u0026lt;Character\u0026gt; // res = new Deque\u0026lt;Character\u0026gt; ;  }\n"});index.add({'id':97,'href':'/school/java/oop-course/006-java-oop-practical-arrays/','title':"006 Java Oop Practical Arrays",'content':"Naming a Package и массивы объектов #   Практическая реализация пройденного материала\n Огромное количество теоретического материала с теоретическими примерами плохо усваиваемы.\nДавайте попробуем это исправить.\nЯ создам новый проект:\nproject . +-- src | +-- de | +-- andron13 | +-- application | +-- LibraryApp.java | +-- dao | +-- Library.java | +-- data | +-- Book.java +-- .gitignore +-- readme.md В файл readme.md обычно пишут о чём проект, как его запустить и кто его делал. Подобие минимальной документации. Пример такого ридми можно посмотреть например у проекта Hugo/readme.md.\nЕсли вы пользуетесь гитом, то хорошим стилем является исключать из репозитория темпоральные файлы. В файл .gitignore добавляют исключения из репозитория. У Hugo есть такой файл - Hugo/.gitignore.\nВ папке src я использовал в названии своё собственное доменное имя. Это конвенция, которую рекомендует использовать Java - Naming a Package. Согласно этой конвенции моя вебстраница andron13.de становится в названии package как de.andron13. Точка значит переход к дочерней папке.\nВнутри я создал папку data, где создам мой класс для работы. В данном случае Book. В папке application моя программа будет запускаться. Это будет точка входа в мою программу. Папка dao расшифровывается как Data Access Object. Data Access Object используется в одном из когда-то очень популярном в Java шаблонов(дизайнов) проектирования приложения. Наш пример с этим паттерном имеет очень посредственную связь. Но как-то думать о разделение разных частей кода надо. и почему бы не разделить так? Как бы то ни было именно в папке dao мы сегодня и будем делать всё самое интересное.\n  Начинаем реализацию с класса Book в папке data:\npublic class Book { private String title; private String author; private int dateOfIssue; private int pages; public Book (String title, String author, int pages, int dateOfIssue){ this.title = title; this.author = author; this.pages = pages; this.dateOfIssue = dateOfIssue; } public String getTitle() { return title; } public String getAuthor() { return author; } public int getPages() { return pages; } public int getDateOfIssue() { return dateOfIssue; } public void setTitle(String title) { this.title = title; } public void setAuthor(String author) { this.author = author; } public void setPages(int pages) { this.pages = pages; } public void setDateOfIssue(int dateOfIssue) { this.dateOfIssue = dateOfIssue; } @Override public String toString() { return \u0026#34;Book: \u0026#34; + title + \u0026#34;, \u0026#34; + author + \u0026#34;, \u0026#34; + pages + \u0026#34;, \u0026#34; + dateOfIssue; } } Делаем все поля закрытыми, один конструктор, гетеры, сетеры и переопределяем toString. Вроде пока больше ничего не надо.\nВ application пишем:\npublic class LibraryApp { public static void main(String[] args) { Book book1 = new Book(\u0026#34;Harry Potter\u0026#34;, \u0026#34;Joan Rollings\u0026#34;, 435, 2010); Book book2 = new Book(\u0026#34;Winnie the Pooh\u0026#34;, \u0026#34;Alex Milan\u0026#34;, 256, 1957); Book book3 = new Book(\u0026#34;Sherlock Holmes\u0026#34;, \u0026#34;Artur Conan Doyle\u0026#34;, 388, 1892); Book book4 = new Book(\u0026#34;Little prince\u0026#34;, \u0026#34;Antoine de Saint-Exupery\u0026#34;, 200, 1943); } } Книги создаются и дошло время до создания библиотеки. Библиотека будет состоять из массивов книг:\npublic class Library { private Book[] books; } Для создания массива нам надо знать как минимум размер массива. Потому конструктор будет принимать размер\npublic Library(int capacity) { books = new Book[capacity]; } Наша библиотека может заполнятся по мере добавления новых книжек и хотелось бы знать количество уже добавленных. Размер массива не равен количеству добавленных книг. Если мы спроектируем наше приложение так, что бы книги добавлялись по порядку, то мы сможем работать с индексом последней книги. Индекс последней добавленной книги можно назвать size. И наш класс выглядит теперь вот так:\npublic class Library { private Book[] books; private int size; public Library(int capacity) { books = new Book[capacity]; size = 0; } public int getSize() { return size; } } У нас есть массив книг, пока пустой и у нас есть начальное количество книг - 0. Надо реализовать метод добавления книг. Прежде всего мы должны задуматься какой тип данных возвращает нам метод добавления книги в массив.\nЕсть мнение, что человеку, который будет ставить книгу на полку не важен ни номер полки, ни номер книги. Ему надо знать только одно смогла книга встать на полку или нет. Хватило ли ей места. Соответственно метод добавления будет возвращать логическое значение.\npublic boolean addBook(Book book) { if (size \u0026lt; books.length) { books[size] = book; size++; return true; } return false; } Таким же образом мы можем удалить книгу из массива:\npublic boolean deleteBook(Book book) { for (int i = 0; i \u0026lt; size; i++) { if (books[i].equals(book)) { books[i] = books[size - 1]; size--; return true; } } return false; } Метод отображения массива:\npublic void display() { for (int i = 0; i \u0026lt; size; i++) { System.out.println(books[i]); } } Метод поиска нужной книги по автору:\npublic void searchBookByAuthor(String author) { boolean flag = false; for (int i = 0; i \u0026lt; size; i++) { if (books[i].getAuthor().equalsIgnoreCase(author)) { System.out.println(books[i]); flag = true; } } if (!flag) { System.out.println(\u0026#34;book is not found\u0026#34;); } } Давайте в точке входа программы создадим библиотеку и поиграем с нашими данными.\nLibrary myLib = new Library(100); System.out.println(myLib.getSize()); myLib.addBook(book1); myLib.addBook(book2); myLib.addBook(book3); myLib.addBook(book4); System.out.println(myLib.getSize()); myLib.addBook(new Book(\u0026#34;War and Peace\u0026#34;, \u0026#34;Lev Tolstoy\u0026#34;, 678, 1886)); myLib.deleteBook(book3); myLib.display(); myLib.searchBookByAuthor(\u0026#34;Alex Milan\u0026#34;); myLib.searchBookByAuthor(\u0026#34;Gogol\u0026#34;); Дополнительные ссылки #   Naming a Package Что такое шаблоны проектирования? Dao Шпаргалка по шаблонам проектирования Design Patterns and Frameworks  "});index.add({'id':98,'href':'/school/java/oop-course/007-java-oop-abstraction/','title':"007 Java Oop Abstraction",'content':"Абстрактные классы и методы в Java #  Иногда наши родственные объекты, которые наследованы от одного базового класса имеют разный подход к реализации методов. И часто во всех дочерних классах метод нужно переопределить.\nОдна из парадигм ООП - схожее объединять. И эта парадигма может объединить и разные методы. Пример разных методов есть у домашних животных. Лошадка скачет, собачка бежит, птичка летит, рыбка плывёт. Метод движения нам нужен, потому что мы должны прописать передачу целевых координат и задать движение объекту.\nВ данном случае нам поможет абстрактный класс.\nabstract class Pet { abstract void moves(); } Абстрактным класс называется, если в нём есть хотя бы один метод абстрактный. Без тела. Этот метод должен быть реализован в каждом классе наследнике, так как больше подходит этому типу.\nclass Duck extends Pet{ void moves() { } } Мы можем создавать не только абстрактные методы, но и \u0026ldquo;обычные\u0026rdquo;:\nabstract class Pet { abstract void moves(); protected void eats() { System.out.println(\u0026#34;Трёхразовое питание\u0026#34;); } } Обычные методы наследуются так же, как мы учили в \u0026ldquo;наследовании\u0026rdquo;, а это значит, что они должны быть переопределены.\nclass Duck extends Pet { void moves() { } @Override protected void eats() { super.eats(); } } Ещё раз:\n абстрактные методы имплементируются(implemented), родительские классы переопределяются(override)\n Пример создания объекта абстрактного класса. #  class Test{ public static void main(String[] args) { Pet pet = new Pet(); } } Попытка запуска/компиляции такого кода приведёт к следующей ошибке:\njava: Pet is abstract; cannot be instantiated   abstract instance   IDEA тоже подозревала это заранее.\nНо нам никто не запретит обработать наши объекты вот так:\nclass Test{ public static void main(String[] args) { Pet pet = new Duck(); Duck duck = new Duck(); } } Это вполне себе валидный код.\nАбстрактный класс #   Класс, который содержит в себе ключевое слово abstract. класс должен быть абстрактным, если он содержит хотя бы один абстрактный метод. Абстрактные классы в Java могут содержать или не содержать абстрактные методы, т.е. методы без тела protected void move(); Абстрактные классы не могут быть инстанцированы(объекты класса не могут быть созданы). Класс наследник абстрактного класса обязан имплементировать все абстрактные методы базового класса.  Абстрактный метод #   Ключевое слово abstract используется для объявления метода абстрактным. У абстрактного метода нет тела и соответственно фигурных скобок. Абстрактный метод имеет только сигнатуру (название метода плюс параметры).  Пример реализации #  abstract class Pet { String name; public Pet() { } public Pet(String name) { this.name = name; } abstract void moves(); protected void eats() { System.out.println(\u0026#34;Трёхразовое питание\u0026#34;); } } class Duck extends Pet { public Duck(String name) { super(name); } void moves() { this.flies(); } void flies() { System.out.println(\u0026#34;Лети птичка\u0026#34;); } @Override protected void eats() { super.eats(); } } class Test { public static void main(String[] args) { Pet pet = new Duck(\u0026#34;Дональд Дак\u0026#34;); Duck duck = new Duck(\u0026#34;Дейзи Дак\u0026#34;); } } Вот так может работать реализации абстракции в Java.\nДополнительные ссылки #  Ссылок не будет, потому что абстрактные классы обычно(всегда) объясняются с интерфейсами. Определённо между ними есть связь, но всё же интерфейсы будут позже. Давайте закрепим материал.\nДомашнее задание #   Измените своих домашних животных из урока с наследованием. Реализуйте абстрактны класс Pet. Добавьте в вашу экосистему дракона \u0026ldquo;Змей Горыныч\u0026rdquo;, чёрного цвета.  "});index.add({'id':99,'href':'/school/java/oop-course/008-java-oop-association-aggregation-composition/','title':"008 Java Oop Association Aggregation Composition",'content':"Association, Aggregation and Composition #  В ООП(не только в Java) помимо наследования различают ещё три связи между объектами:\n Ассоциация Агрегация Композиция Наследование  Агрегация - Aggregation #  Мы говорим об агрегации, когда объект может быть частью нескольких составных объектов(компонентов). В этом случае полученный объект агрегирован. Срок службы деталей может быть больше, чем срок службы агрегата.\nПримером агрегации являются взаимоотношения между футбольной командой и ее игроками. Человек может играть в нескольких командах, и если команда распущена, обычно это не означает конец для ее бывших игроков. Футбольная команда - Aggregate.\n  Association, Aggregation, Composition   Композиция - Composition #  В композиции деталь может содержаться только в одном композитном объекте, а срок службы композитного объекта всегда соответствует сроку службы его компонентов. Здесь составной объект называется композитным.\nПримером композиции является связь между заказом на покупку и отдельными позициями заказа на покупку. Если заказ на покупку удаляется, то автоматически удаляются и все его элементы. Дом и квартира в нём. Если дом разрушить, то и квартира не может пережить разрушение дома.\nАссоциация - Association #  Отношение между классами, которые не влияют друг на друга и не являются \u0026ldquo;родственниками\u0026rdquo; называют ассоциация. Иногда слово ассоциация используют как синоним слову отношения. На мой взгляд это немного запутывает. Но Java не единственный язык OOP и реализаций отношений между объектами возможно много больше, чем определений. Потому я не претендую на последнюю инстанцию. Но в своей статье использую \u0026ldquo;Association\u0026rdquo; для \u0026ldquo;простых связей\u0026rdquo; между объектами.\nПример ассоциации. Человек(Водитель) и легковая машина. Водитель может управлять машиной. Но каждый из них живёт своей собственной жизнью и не является частью другого.\nНи в какие рамки #   Студент и университет. Какая здесь связь?\n По идее не композиция. Студенты точно не являются частью университета. Это и не наследование. Простая ассоциация или агрегация? Может это такой же случай как и футбольная команда. Может универ существовать без студентов или нет? Мы понимаем, что универ наверное немного сложнее, чем футбол, и в нём есть кафедры, специальности, потоки, курсы, группы. И вот группа скорее всего агрегация. Сама группа часть кафедры, а кафедры уже часть универа.\nПорой надо понимать реализацию или упрощать связь до возможного описания в коде. Но в жизни всё может быть немного сложнее, чем в книге.\nЯ сделал маленькую табличку, которая должна помочь разобраться:\nТаблица Association, Aggregation and Composition #     - Ассоциация Агрегация Композиция     Владелец нет владельца есть владелец есть владелец   Жизненный цикл собственный цикл жизни собственный цикл жизни Цикл жизни владельца    \u0026ldquo;Пара\u0026rdquo; примеров отношений между классами #   Менеджер открывает ключ-картой дверь отдела. Java-программист работает на крупную IT-фирму Java-программист в подчинении у менеджера, как и весь его отдел. Менеджер несёт персональную ответственность за успешность проекта. Зарплата менеджера напрямую зависит от успешности проекта.  Менеджер и карта, первый пример #    Это ассоциация. Объекты живут собственной жизнью. Объекты взаимодействуют друг с другом в одном из методов.\nJava-программист работает на крупную IT-фирму #  Это ассоциация.\nJava-программист в подчинении у менеджера, как и весь его отдел. #  Агрегация. Менеджер агрегировал весь отдел.\nМенеджер, Проект, Зарплата 4 и 5 #  Композиция. Есть явная связь между зарплатой и проектом. Работой и проектом.\n  Дополнительные ссылки #   Association In Java – Explore the Concepts of Composition \u0026amp; Aggregation Understanding Association, Aggregation, and Composition  Отношения между классами (объектами)  Домашнее задание #   Создайте проект с Книгой, Жанром, Автором, Издательством Продумайте связи между объектами, необходимыми полями и поведением. Назовите типы связей между вашими объектами  "});index.add({'id':100,'href':'/school/java/oop-course/009-java-oop-interface/','title':"009 Java O O P Interface",'content':"https://javarush.ru/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih\n"});index.add({'id':101,'href':'/school/java/oop-course/010-java-oop-practical-number-and-fraction/','title':"010 Java Oop Practical Number and Fraction",'content':"public class Fraction { private int numerator; private int denominator; Fraction(int numerator) { this.numerator = numerator; this.denominator = 1; } public Fraction(int numerator, int denominator) { this.numerator = numerator; this.denominator = denominator; } public int getNumerator() { return numerator; } public int getDenominator() { return denominator; } public Fraction sum(Fraction fraction) { Fraction result = sum(fraction, this); return result; } public static Fraction sum(Fraction a, Fraction b) { // описать сложение;  // выполнить сокращение дробей, если это возможно  // находим нок знаменателей дробей  // подставить полученное значение в знаменатель РЕЗУЛЬТАТА  // Разделить нок на знаменатели данных дробей.  // умножить числитель и знаменатель каждой дроби на дополнительный множитель  int cDenominator = Math.nok(a.denominator, b.denominator); int cNumerator = a.numerator * (cDenominator / a.denominator) + b.numerator * (cDenominator / b.denominator); Fraction c = new Fraction(cNumerator, cDenominator); return c; } @Override public String toString() { return \u0026#34;Fraction(дробь){\u0026#34; + \u0026#34;numerator(числитель)=\u0026#34; + numerator + \u0026#34;, denominator(знаменатель)=\u0026#34; + denominator + \u0026#39;}\u0026#39;; } } class Math { static int nok(int a, int b) { return a * b / nod(a, b); } static int nod(int a, int b) { if (b == 0) { return a; } return nod(b, a % b); } } Дополнительные ссылки #  http://java-online.ru/java-lang-wrapper.xhtml https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html\n"});index.add({'id':102,'href':'/school/java/oop-course/011-java-oop-enum/','title':"011 Java O O P Enum",'content':"enum Level { LOW, MEDIUM, HIGH } Level myVar = Level.MEDIUM; enum Level { LOW, MEDIUM, HIGH } public class MyClass { public static void main(String[] args) { Level myVar = Level.MEDIUM; switch(myVar) { case LOW: System.out.println(\u0026#34;Low level\u0026#34;); break; case MEDIUM: System.out.println(\u0026#34;Medium level\u0026#34;); break; case HIGH: System.out.println(\u0026#34;High level\u0026#34;); break; } } } https://mkyong.com/java/java-enum-example/ https://www.w3schools.com/java/java_enums.asp https://javarush.ru/groups/posts/1963-kak-ispoljhzovatjh-klass-enum\npublic enum Gender { M(1), W(2), D(3); private int gend; private Gender(int gend) { this.gend = gend; } public int getGend() { return gend; } } https://javarush.ru/groups/posts/1963-kak-ispoljhzovatjh-klass-enum\nhttps://github.com/sergeylukichev/JavaCourse/blob/master/Drafts/DayOfWeek/src/DayOfWeek.java\n"});index.add({'id':103,'href':'/school/java/oop-course/013-java-oop-date/','title':"013 Java Oop Date",'content':"Дата и время в Java #  Прежде чем\nJava и время: Пре\nDate today = new Date(); System.out.println(today); Date dateStart = new Date(0); System.out.println(\u0026#34;dateStart \u0026#34; + dateStart); Date anotherDay = new Date(1_451_665_447_567L); System.out.println(\u0026#34;just anotherDay \u0026#34; + anotherDay); Date theEnd = new Date(Long.MAX_VALUE); System.out.println(theEnd); В итоге у нас получился вот такой вот класс, в котором мы поработали с некоторыми вариантами даты в Java.\nimport java.text.*; import java.time.*; import java.time.format.DateTimeFormatter; import java.time.temporal.ChronoUnit; import java.util.*; public class HelloDate { public static void main(String[] args) throws Exception { // haliHalloDate();  //findBirthDay();  helloLocaleDate(); } private static void helloLocaleDate() { LocalDate localDate = LocalDate.now(); LocalDate plusDays = localDate.plusMonths(5).minusDays(5); System.out.println(\u0026#34;plus minus \u0026#34; + plusDays); LocalDateTime myParseDate = LocalDateTime.parse(\u0026#34;2018-02-20 10:15:30\u0026#34; , DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;)); System.out.println(myParseDate); final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\u0026#34;EEEE\u0026#34;, new Locale(\u0026#34;ru\u0026#34;)); final String day = myParseDate.format(formatter); System.out.println(day); final DateTimeFormatter formatterMonth = DateTimeFormatter.ofPattern(\u0026#34;MMMMM\u0026#34;, new Locale(\u0026#34;ru\u0026#34;)); final String month = myParseDate.format(formatterMonth); System.out.println(\u0026#34;Попытка номер 5 \u0026#34; + month); LocalDateTime now = LocalDateTime.now(); ZoneId berlin = ZoneId.of(\u0026#34;Europe/Berlin\u0026#34;); ZoneId moskow = ZoneId.of(\u0026#34;Europe/Moscow\u0026#34;); ZonedDateTime inBerlin = ZonedDateTime.of(now, berlin); ZonedDateTime inMoskow = ZonedDateTime.of(now, moskow); System.out.println(\u0026#34;time in berlin\u0026#34; + inBerlin); System.out.println(\u0026#34;time in moskow\u0026#34; + inMoskow); LocalDateTime plasDays2 = now.plusDays(10); LocalDateTime plasDays3 = now.minusWeeks(10); LocalDateTime plasDays4 = now.minusHours(1); long between = ChronoUnit.DAYS.between(now, plasDays2); System.out.println(between); ArrayList\u0026lt;LocalDate\u0026gt; dates = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(dates, LocalDate.now(), LocalDate.now().plusDays(10), LocalDate.now().plusDays(20), LocalDate.now().plusWeeks(6)); System.out.println(dates); ArrayList\u0026lt;String\u0026gt; stringDates = new ArrayList\u0026lt;\u0026gt;(); Collections.addAll(stringDates, \u0026#34;03 Jun 2015\u0026#34;, \u0026#34;08 JUL 2016\u0026#34;, \u0026#34;12 DEZ 2013\u0026#34;); System.out.println(stringDates); String test = \u0026#34;03/07/2015\u0026#34;; System.out.println(createLocalDateFromString(test)); System.out.println(createStringFromLocaleDate(plusDays)); } public static LocalDate createLocalDateFromString(String s) { return LocalDate.parse(s, DateTimeFormatter.ofPattern(\u0026#34;dd/MM/yyyy\u0026#34;)); } public static String createStringFromLocaleDate(LocalDate d) { return d.format(DateTimeFormatter.ofPattern(\u0026#34;EEEE, dd MMMM yyyy\u0026#34;, new Locale(\u0026#34;ru\u0026#34;))); } private static void findBirthDay() { LocalDate today = LocalDate.now(); // день сегодня  System.out.println(\u0026#34;today\u0026#34; + today); LocalDate birthDay = LocalDate.of(1980, Month.AUGUST, 10); // день варения  System.out.println(\u0026#34;birthDay \u0026#34; + birthDay); Period period = Period.between(birthDay, today); System.out.println(\u0026#34;period = birthDay, today \u0026#34; + period); System.out.println(period.getYears()); System.out.println(period.getMonths()); System.out.println(period.getDays()); System.out.println(period.getUnits()); System.out.println(period.getChronology()); } private static void haliHalloDate() throws ParseException { Date today = new Date(); System.out.println(today); Date dateStart = new Date(0); System.out.println(\u0026#34;dateStart \u0026#34; + dateStart); Date anotherDay = new Date(1_451_665_447_567L); System.out.println(\u0026#34;just anotherDay \u0026#34; + anotherDay); Calendar calendar = Calendar.getInstance(); calendar.setTime(anotherDay); // # August 17, 292278994 7:12:55 AM UTC  // System.out.println(\u0026#34;just calendar anotherDay \u0026#34; + calendar); //ужас-ужас  System.out.println(\u0026#34;calendar.getTime() \u0026#34; + calendar.getTime()); calendar.add(Calendar.WEEK_OF_MONTH, 1); System.out.println(\u0026#34;calendar.getTime() + week \u0026#34; + calendar.getTime()); calendar.add(Calendar.MINUTE, 5); System.out.println(\u0026#34;calendar.getTime() + minute \u0026#34; + calendar.getTime()); DateFormat dateFormat = DateFormat.getDateInstance(DateFormat.SHORT); System.out.println(\u0026#34;dateFormat.format(calendar.getTime()) \u0026#34; + dateFormat.format(calendar.getTime())); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;dd/MM/yyyy\u0026#34;); System.out.println(\u0026#34;simpleDateFormat.format(calendar.getTime()) \u0026#34; + simpleDateFormat.format(calendar.getTime())); SimpleDateFormat simpleDateFormatBerlin = new SimpleDateFormat(\u0026#34;dd-M-yyyy\u0026#34;); System.out.println(\u0026#34;simpleDateFormatBerlin.format(calendar.getTime()) \u0026#34; + simpleDateFormatBerlin.format(calendar.getTime())); Calendar calendarToday = Calendar.getInstance(); calendarToday.setTime(today); System.out.println(\u0026#34;simple format today \u0026#34; + simpleDateFormatBerlin.format(calendarToday.getTime())); Date oldDate = simpleDateFormat.parse(\u0026#34;20/07/1993\u0026#34;); System.out.println(\u0026#34;oldDate\u0026#34; + oldDate); } } Joda-Time #  Пока не вышла Java 8, программисты не мирились с недостатками языка и создавали свой функционал. Одной из самых популярных библиотек была библиотека Joda-Time.\nНа сайте создателей формата времени дословно стоит следующее.\n Joda-Time provides a quality replacement for the Java date and time classes.\nJoda-Time is the de facto standard date and time library for Java prior to Java SE 8. Users are now asked to migrate to java.time (JSR-310).\n Это значит, что нам эта библиотека может быть интересна только в историческом и учебном плане.\nДополнительные ссылки #   Docs.oracle - SimpleDateFormat Docs.oracle DateTimeFormatter Oracle - Java SE 8 Date and Time Habr - Java и время: часть первая, часть вторая Baeldung - Introduction to the Java 8 Date/Time API Get the Current Date, Time and Timestamp in Java 8 Migrating to the New Java 8 Date Time API Joda-Time - deprecated Unix time, also known as Epoch time, POSIX time, seconds since the Epoch, or UNIX Epoch time.  Домашнее задание #   Создайте программу, которая находит сколько дней осталось до Нового Года. Создайте класс Human и гетер, который даёт точный возраст человека(в годах), если нам известна дата его рождения. Напишите калькулятор, который принимает от пользователя дату, и возвращает Unix time.  "});index.add({'id':104,'href':'/school/java/oop-course/014-java-practical-hashcode-equals-tostring/','title':"014 Java Practical Hashcode Equals Tostring",'content':""});index.add({'id':105,'href':'/school/java/oop-course/015-java-oop-mutable-immutable-objects/','title':"015 Java Oop Mutable Immutable Objects",'content':"Mutable vs Immutable Objects https://www.interviewcake.com/concept/java/mutable\n"});index.add({'id':106,'href':'/school/java/oop-course/016-java-oop-arraylist/','title':"016 Java Oop Arraylist",'content':"Java ArrayList - основы #  При использовании массивов можно было заметить, что у них есть один минус - они конечны. Мы не можем расширить массив. При незапланированном увеличении элементов массива мы вынуждены создавать новый массив, так как массив не меняет своей длины.\nJava предоставляет ArrayList, который решает эту и часть других ограничений обычного массива. Не надо считать эти ограничения массива его недостатками. Это просто особенности, которые надо учитывать.\nНа примере ниже можно посмотреть различия между способами хранения информации.\nСоздание ArrayList #  List\u0026lt;String\u0026gt; list = Arrays.asList(array); System.out.println(list); ArrayList\u0026lt;String\u0026gt; myList = new ArrayList\u0026lt;\u0026gt;(); ArrayList\u0026lt;String\u0026gt; yourList = new ArrayList\u0026lt;\u0026gt;(myList); ArrayList\u0026lt;String\u0026gt; berliners = new ArrayList\u0026lt;\u0026gt;(3_500_000); // есть смысл указать сразу Работа с элементами в ArrayList #  list.add(element); // добавление в конец list.add(7, element); // добавление на определённую позицию list.add(0, element); // позиция равна нулю, начало list.remove(3); // удаление элемента на позиции три Заполнение ArrayList и получение информации из ArrayList. #  import java.util.ArrayList; import java.util.Random; public class HalloArrayList { public static void main(String[] args) { addToArrayList(); } private static String generateString(int n) { Random random = new Random(); String result = \u0026quot;\u0026quot;; for (int i = 0; i \u0026lt; n; i++) { char c = (char) (random.nextInt(25) + 65); result = result + c; } return result; } private static void addToArrayList() { ArrayList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;String\u0026gt;(); for (int i = 0; i \u0026lt; 10; i++) { String s = generateString(10); list.add(s); } for (String element : list) { System.out.println(\u0026quot;Вариант 1 \u0026quot; + element); } for (int i = 0; i \u0026lt; list.size(); i++) { System.out.println(\u0026quot;вариант 2 \u0026quot; + list.get(i).toLowerCase()); } System.out.println(\u0026quot;вариант 3 \u0026quot; + list.toString()); } } Методы ArrayList #  add(E e) add(int index, E element) addAll(Collection \u0026lt;? extends E\u0026gt; collection) addAll(int index, Collection \u0026lt;? extends E\u0026gt; collection) clear() clone() ArrayList\u0026lt;String\u0026gt; copyOfSecondList = (ArrayList\u0026lt;String\u0026gt;) secondList.clone(); secondList.clear(); System.out.println(copyOfSecondList); contains(Object o) ensureCapacity(int minCapacity) get(int index) isEmpty() remove(int index) remove(Object o) removeAll(Collection\u0026lt;?\u0026gt; c) set(int index, E element) size() toArray() ArrayList\u0026lt;String\u0026gt; countryListArray = new ArrayList\u0026lt;String\u0026gt;(); listArray.add(\u0026quot;Germany\u0026quot;); listArray.add(\u0026quot;Holland\u0026quot;); listArray.add(\u0026quot;Sweden\u0026quot;); String[] strArray = new String[3]; String[] a = listArray.toArray(strArray); ArrayList хранит объекты #  Примитивные типы данных и их обёртки(Wrapper classes) #     Примитивный тип Класс обёртка     byte Byte   short Short   char Character   int Integer   long Long   float Float   double Double   boolean Boolean    Wrapper classes числовых типов (Byte, Short, Integer, Long, Float, Double) наследуются от класса Number, который содержит код, общий для всех классов-оберток числовых типов. Все классы-обертки реализуют интерфейс Comparable.\nДополнительные материалы #   http://java-online.ru/java-lang-wrapper.xhtml https://www.baeldung.com/java-arraylist http://developer.alexanderklimov.ru/android/java/arraylist.php https://docs.oracle.com/javase/tutorial/collections/interfaces/list.html https://docs.oracle.com/javase/8/docs/api/java/lang/Number.html  Домашнее задание #   Добавить наши книги из библиотек предыдущих уроков в ArrayList. Создать класс и лист пользователей библиотеки.  "});index.add({'id':107,'href':'/school/java/oop-course/035-java-formatter-systemoutprintf/','title':"035 Java Formatter System Out Printf",'content':"https://www.youtube.com/watch?v=IVcagooE5y4\u0026amp;list=PL71C6DFDDF73835C2\u0026amp;index=18\n"});index.add({'id':108,'href':'/school/java/oop-course/037-java-object-chapter-2/','title':"037 Java Object Chapter 2",'content':"А запомнить нам поможет, то, что String тоже пишется с большой буквы, но как исключение из всех объектов инициализируется по упрощённой формуле. Вернее может, а может и по новой:\nString helloWorld = new String(\u0026#34;Hello Java World!\u0026#34;) https://www.baeldung.com/java-string-pool\n/**\n  BC12-Morning\n  16 18 : 25 */ public class Test { public static void main(String[] args) { String a = \u0026ldquo;Андрей\u0026rdquo;; String b = new String(\u0026ldquo;Андрей\u0026rdquo;); String e = new String(\u0026ldquo;Андрей\u0026rdquo;); String newE = e; boolean c = a.equals(b); boolean d = (a == b); System.out.println(c); System.out.println(d); boolean f = b == e; System.out.println(f); System.out.println(\u0026ldquo;исчо раз\u0026rdquo; + newE == e);\n String str1 = \u0026quot;Java\u0026quot;; String str2 = new String(); // пустая строка String str3 = new String(new char[]{'h', 'e', 'l', 'l', 'o'}); String str4 = new String(new char[]{'w', 'e', 'l', 'c', 'o', 'm', 'e'}, 3, 4);//3 -начальный индекс, 4 -кол-во символов System.out.println(str1); // Java System.out.println(str2); // System.out.println(str3); // hello System.out.println(str4); // come String str10 = \u0026quot;Hello World!!\u0026quot;; String str20 = \u0026quot;Hello World!!\u0026quot;; System.out.println(str10 == str20); // правда  } }\n  "});index.add({'id':109,'href':'/school/java/oop-course/038-java-object-chapter-3/','title':"038 Java Object Chapter 3",'content':"Три ноги на которых стоит Java #   Наследование - inheritance. https://vertex-academy.com/tutorials/ru/pravila-nasledovaniya-v-java/ Инкапсуляция - encapsulation. Полиморфизм - polymorphism.  перегрузка - overloading. overriding    Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным).\npublic class Person { private String name; private String firstName; public int age; public Person(String ln, String fn) { name = ln; firstName = fn; } public Person() { this(\u0026#34;Doe\u0026#34;, \u0026#34;John\u0026#34;); } public void setName(String ln, String fn) { name = ln; firstName = fn; } public String fullName() { return (name + \u0026#34; \u0026#34; + firstName); } } import java.util.Arrays; public class Employee extends Person { private String employeeId; public Employee(String ln, String fn, String EmpId, int a) { super(ln, fn); // Java ruft hier den Konstruktor der Oberklasse auf  employeeId = EmpId; age = a; } public String getEmployeeId() { return employeeId; } public String printAll() { return (fullName() + \u0026#34; \u0026#34; + employeeId + \u0026#34; \u0026#34; + age); } } class EmployeeTest { public static void main(String[] args) { Employee ceo = new Employee(\u0026#34;Doe\u0026#34;, \u0026#34;Jane\u0026#34;, \u0026#34;1\u0026#34;, 25); Employee cto = new Employee(\u0026#34;Miller\u0026#34;, \u0026#34;John\u0026#34;, \u0026#34;2\u0026#34;, 30); Employee e1 = new Employee(\u0026#34;Сергей\u0026#34;, \u0026#34;Серёгин\u0026#34;, \u0026#34;3\u0026#34;, 25); Employee e2 = new Employee(\u0026#34;Петя\u0026#34;, \u0026#34;Петров\u0026#34;, \u0026#34;4\u0026#34;, 57); Employee e3 = new Employee(\u0026#34;Вася\u0026#34;, \u0026#34;Васечкин\u0026#34;, \u0026#34;5\u0026#34;, 43); Employee e4 = new Employee(\u0026#34;Дмитрий\u0026#34;, \u0026#34;Дмитриев\u0026#34;, \u0026#34;6\u0026#34;, 36); cto.age++; System.out.println(ceo.printAll()); System.out.println(cto.printAll()); Employee[] work = {ceo, cto, e1, e2, e3, e4}; System.out.println(\u0026#34;Принт ансорт аррэй\u0026#34;); for (Employee empl : work) { System.out.println(empl.printAll()); } Employee[] work1 = bubbleSort(work); System.out.println(\u0026#34;Принт сорт аррэй\u0026#34;); for (Employee empl : work1) { System.out.println(empl.printAll()); } } public static Employee[] bubbleSort(Employee[] myArray) { boolean unsorted = true; while (unsorted) { int count = 0; for (int i = 0; i \u0026lt; myArray.length - 1; i++) { if (myArray[i].age \u0026gt; myArray[i + 1].age) { myArray[i].age = myArray[i].age + myArray[i + 1].age; myArray[i + 1].age = myArray[i].age - myArray[i + 1].age; myArray[i].age = myArray[i].age - myArray[i + 1].age; count++; } } if (count == 0) { unsorted = false; } } return myArray; } } "});index.add({'id':110,'href':'/school/java/oop-course/040-java-uml-diagram/','title':"040 Java Uml Diagram",'content':"https://www.youtube.com/watch?v=ksvwF2sUjHM\u0026amp;list=PLBlnK6fEyqRjKA_NuK9mHmlk0dZzuP1P5\u0026amp;index=120\n"});index.add({'id':111,'href':'/school/java/oop-course/042-java-maven/','title':"042 Java Maven",'content':"Java и Apache Maven — фреймворк для автоматизации сборки проектов #  В предыдущем уроке мы собрали свою библиотеку и говорили о сборке своего собственного приложения. Хотя ни одного приложения ещё и не сделали.\nПредставьте, что мы до сих пор собирали телескоп, что бы посмотреть на звёзды. И вот собрав его мы теперь можем изучать планеты, звёзды, луну, солнце. С чего начать?\nПримерно перед таким же выбором стою и я. Вы выучили основы и вам можно рассказывать всё. Абсолютно любую тему. Например продолжать рассказывать про объекты. Ведь мы остановились на самом интересном, на том что с ними можно делать.\nОднако опыт обучения абсолютно новеньких людей в програмирование говорит мне о том, что надо немного отвлечься и дать уложиться знаниям. Именно по этому я дам пару следующих тем, которые на прямую может и не связаны с объектами, но без которых ни один Java-разработчик не сможет выполнять свою работу.\nИ так. В предыдущем уроке мы собрали библиотеку-приложение. Каждый раз так собирать приложение достаточно утомительно, а програмисты самые ленивые люди в мире. И со временем для сборки приложений, внесения зависимости и для помощи в разработке в мир Java появился Maven.\nMaven - важное #  Важно знать не язык, а фреймворки на его основе. Современные фреймворки на языке Java используют один из двух \u0026ldquo;сборщиков\u0026rdquo; Maven или Gradle. Забежим вперёд - Gradle мы рассмотрим следующим.\nКомплексность и сложность современных приложений требует подходящие инструменты. С помощью Maven могут решать вопросы зависимостей, тестирования, сборки, деплоя и инсталяции приложений. Как все вместе, так и по отдельности.\nMaven - установка #  Я всё таки считаю, что программист должен сам научиться устанавливать необходимые инструменты, но не смотря на это одну ссылку дам - http://maven.apache.org/install.html.\nMaven - практический пример использования #  А вот пример реального кейса мы сейчас и рассмотрим. Давайте попробуем наш вчерашний Password собрать с помощью Maven. У нас есть два пути. Один раз добавить Maven в уже существующий проект, а другой создать Maven проект с нуля.\n"});index.add({'id':112,'href':'/school/java/oop-course/043-java-gradle/','title':"043 Java Gradle",'content':"Gradle - сборщик для Android \u0026amp; C #  Мир программирования это мир конкуренции. Вопрос, почему придумали Gradle отвечается сам собой. Потому что програмисты тоже человеки. А человеки всегда находятся в поиске. И даже улучшение работы на пару процентов уже для многих может иметь решающее значение.\nGradle подходит к решению некоторых задач по другому чем Maven и активно используется многими фреймворками так же как и Maven на ваш выбор или даже безальтернативно - только Gradle.\nЯ не буду, да и не смогу рассказать что находится по капотами обеих технологий я просто покажу, пример использования Gradle на одном или другом примере.\n"});index.add({'id':113,'href':'/school/java/oop-course/044-java-testing-junit/','title':"044 Java Testing J Unit",'content':"JUnit - тестировние приложений в Java #  В начале перед первым уроком я стоял перед выбором какую из \u0026ldquo;страшных\u0026rdquo; технологий, дать в самом начале и не говорить что они страшные. В итоге я решил, что Git та технология, которая даётся сложнее всего и в каждом уроке стоит немного уделять ему внимания. Потому что без написания код нельзя выучить методы работы с Git.\nОднако существует ещё одна технология, которая невозможна сама по себе, она требует уже написанного кода. Это тестирование. Ради этой главы и было введение в Maven и Gradle. Выучив тестирование и освоив его мы окунёмся в мир настоящего взрослого и прекрасного объектно-ориентированного программирования.\npublic class Calculator { public static int addition(int... values) { int result = 0; for (int element : values) { result += element; } return result; } public static void main(String[] args) { testAdditionOne(); testAdditionTwo(); testAdditionThree(); testAdditionFor(); } private static void testAdditionFor() { if (addition(1, 2, 5) == 8) { System.out.println(\u0026#34;Тест 4 прошёл успешно\u0026#34;); } else System.out.println(\u0026#34;Тест 4 не прошёл\u0026#34;); } private static void testAdditionThree() { if (addition(5, -5) == 0) { System.out.println(\u0026#34;Тест 3 прошёл успешно\u0026#34;); } else System.out.println(\u0026#34;Тест 3 не прошёл\u0026#34;); } private static void testAdditionTwo() { if (addition(100, 1000) == 1100) { System.out.println(\u0026#34;Тест 2 прошёл успешно\u0026#34;); } else System.out.println(\u0026#34;Тест 2 не прошёл\u0026#34;); } private static void testAdditionOne() { if (addition(2, 5) == 7) { System.out.println(\u0026#34;Тест 1 прошёл успешно\u0026#34;); } else System.out.println(\u0026#34;Тест 1 не прошёл\u0026#34;); } } Тестирование - основы #  Существует самые различные виды тестирования.\nhttps://junit.org/junit5/\n"});index.add({'id':114,'href':'/school/java/oop-course/050-bit-operation/','title':"050 Bit Operation",'content':"https://javarush.ru/groups/posts/1925-pobitovihe-operacii\nhttps://qna.habr.com/q/152931\n"});index.add({'id':115,'href':'/school/java/spring/001-java-spring/','title':"001 Java Spring",'content':"https://www.youtube.com/watch?v=5ePo08sqcpk\u0026amp;list=PLAma_mKffTOR5o0WNHnY0mTjKxnCgSXrZ\n"});index.add({'id':116,'href':'/school/tools/01-git/','title':"01 Git",'content':"Git #  Не буду скрывать, Git это та технология, которая не так легко даётся.\nПринципиально, написано достаточно книг, которые всё объясняют намного лучше, чем я когда либо смогу. Именно по этому я написал просто короткую инструкцию для начинающих , где описаны основные приказы, которые тебе понадобятся первое время.\nЕдинственное, что я бы хотел добавить к книгам, которые вам всё равно обязательно надо прочитать, всего несколько предложений.\n Git - это система контроля версий в разработке. Разработка может быть программным кодом, а может быть романом или сценарием к фильму. Не имеет особого значения, что именно мы разрабатываем. В технологии Git используются две важные особенности ветки и коммиты. Коммиты - это точки во временном континууме, которые вы создаёте, для того, что бы была возможность к ним вернуться, если всё пойдёт не так. Что-то вроде сохранения, перед биг-боссом в конце игровой стадии. Ветки - это линии времени, которые может прожить ваш проект или вы с ним. Эти линии можно сводить в одну. А можно развести в любой точке. А можно вести параллельно две или даже три линии и смотреть как получается.  Всё.\nНадеюсь эти аллегории вас не запутали ещё больше.\nПолезные материалы #   Ссылка на методичку в pdf формате Ссылка на хороший мануал от Atlassian  Лайфхак. #  Другие программисты или администраторы у вас будут спрашивать SSH-ключи.\nДля входа на сервер например, что бы внести вас в администраторы или просто дать доступ. Очень хитрый способ предоставления ключей в любой момент с помощью гитхаба\nhttps://github.com/andron13.keys - ник на гитхабе точка keys и там те ключи, которые вы внесли фля работы с ним. с вероятностью в 99% это то, что у вас спрашивают.\n"});index.add({'id':117,'href':'/school/tools/02-github-basic/','title':"02 Github Basic",'content':"Методичка по работе с Git #  Терминология #     Термин Ссылка Пояснение     Git https://git-scm.com/downloads Git - это очень популярная технология контроля версий, используемая при разработке програмного обеспечения и веб-приложений. Онлайн инструкция на русском языке - https://git-scm.com/book/ru/v2/   Github https://github.com/ Популярный сервис для хранения Git-репозиториев. С 2018 года принадлежит Microsoft   Bitbucket https://bitbucket.org/ Популярный сервис для хранения Git-репозиториев. Принадлежит Atlassian и очень тесно интегрирован с популярными IT-приложениями этой фирмы как Trello или Jira   Gitlab https://gitlab.com/ Альтернативный сервис для хранения Git-репозиториев.    Очень важно понимать, что Git и Github не одно и то же. Дополнительные материалы, книги и ссылки следует обязательно прочитать самому. И прежде всего стоит начать с https://git-scm.com/book/ru/v2/\nПолезная информация #  Для работы новичку достаточно знать несколько приказов и установить саму программу https://git-scm.com/downloads. Все команды ниже надо вводить в окно терминала/консоли. Я использую Git Bash\nСоздание SSH ключа для работы с git сервисами #  Для полноценной работы с git-репозиториями требуется SSH-ключ. У Google можно спросить как его получить - \u0026ldquo;how to generate a new ssh key\u0026rdquo;. Или просто ввести команду ниже, если подробности создания уже известны:\nssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; Инициализация проекта #  Часто новичкам удобнее создавать проект в пустой папке:\nmkdir newProjectname cd newProjectname git init Добавление в репозиторий файлов #  Добавление в репозиторий файла index.html:\ngit add index.htm Добавление в репозиторий всех файлов в папке:\ngit add . Часто эта команда приводит к плохим последствиям. Потому что добавляет не только файлы разработки, но и временные файлы программы и инструментов, в которых работает программист. Рекомендуется добавлять в репозиторий файлы осознанно и поимённо.\nКоммит #  Фиксирование изменений, ещё несколько лет назад именно так переводили этот термин в литературе. Сегодня этот англицизм плотно вошёл во всю техничискую литературу мирa без перевода.\ngit commit -m \u0026#34;комментарий к коммиту, который объясняет изменения\u0026#34; Ветки #  По умолчанию работа ведётся в ветке мастер. Выйти из ветки мастер и войти в новосоздаваемую ветку одним приказом:\ngit checkout -b newBranchName Выйти/вернуться в ветку, которая на проекте уже была создана\ngit checkout master Удалённый репозиторий и работа с ним #  Origin - это адрес вашего репозитория на одном из git-сервисов, которые вы выбрали. К примеру - Gitlab, Bitbucket или Github. Теоретически можно изменить имя удалёного репозитория на любое другое. Но у новичков достаточно путанницы в терминах и командах, чтобы дополнительно усложнять себе жизнь.\nСинхронизировать ветку мастер на локальном компьютере и origin #  Отправить изменения в интернет:\ngit push origin master Обновить локальный репозиторий:\ngit pull origin master Проверить состояние репозитория или лог изменений в ветке:\ngit status git log Дополнительные материалы #  Ask Google - \u0026ldquo;git book online\u0026rdquo;\n"});index.add({'id':118,'href':'/school/tools/03-boolean-algebra/','title':"03 Boolean Algebra",'content':"Булева алгебра #  Булева алгебра, ударение на первый слог. БУлева.\nПрограммисты учат её в институте. Люди, которые не учились в институте должны будут понять её самостоятельно.\nПри этом всё не так уж и сложно.\nДавайте я попробую на пальцах рассказать основы и то, что нам понадобится на минимальном уровне.\nДизъюнкция #   Когда мама ИЛИ папа дают мне деньги на карманные расходы, то я бегу и покупаю себе мороженное.\n Знакомая ситуация, деньги можно получить в трёх случах из четырёх. В одном случае деньги может дать и мама, и папа, тогда и друга можно угостить мороженным.\nЭто дизъюнкция.\nДизъюнкция - логическое сложение, логическое ИЛИ, включающее или, просто \u0026ldquo;или\u0026rdquo;(англ. OR; нем. ODER) В Java операторы \u0026quot;|\u0026quot; и \u0026quot;||\u0026quot;\nboolean a = false, b = true, c; c = a | b; Пример в технике; дублирование выключателя или кнопки, дверной звонок и звонок у калитки вызывают одну и туже реакцию - включается мелодия звонка.\nКонъюнкция #  Конъюнкция - логическое \u0026ldquo;И\u0026rdquo;, логическое умножение, просто \u0026ldquo;И\u0026rdquo;, \u0026ldquo;AND\u0026rdquo;, \u0026quot;\u0026amp;\u0026quot;.\nВ Java оператор \u0026quot;\u0026amp;\u0026quot; и \u0026quot;\u0026amp;\u0026amp;\u0026quot;.\nboolean a = false, b = true, c; c = a \u0026amp; b;  Если светит солнце \u0026ldquo;И\u0026rdquo; у меня выходной, то я иду купаться на озеро.\n Пример из жизни. Ядерный чемоданчик могут активировать только два офицера одновременно. По отдельности чемодан остаётся неактивным.\nАнтиваленц #  \u0026ldquo;XOR\u0026rdquo;, эксклюзивное или, \u0026ldquo;EOR\u0026rdquo;, \u0026ldquo;EXOR\u0026rdquo;. В Java оператор \u0026quot;^\u0026quot;.\nboolean a = false, b = true, c; c = a ^ b;  Только на горных лыжах в Австрии или на лошадях у бабушки в деревне я забываю про свою работу.\n  Или ты садишься за математику или я расскажу всё отцу.\n ИЛИ - ИЛИ. Исключительное или.\nЛампочка в больнице может работать от городского электричества или от дизельного генератора в подвале. Но не от двух источников одновременно.\nОтрицание #  Negation. NOT. В Java оператор \u0026quot;!\u0026quot;.\nboolean a = false, b; b = !a; Давайте представим огромный станок по продольной распилке леса. В цеху есть две кнопки. Зелёная и красная. При включении зелёной пила должна работать. При нажатии на красную пила должна остановится.\nДополнительные материалы #   Прекрасный сайт симулятор для электротехников. Помогает в живую понять основы(и не только) булевой алгебры. http://simulator.io . В последнее время ходили слухи, что проект закроют. Будет невероятно жаль, если сайт не спасут.  Домашнее задание: #  Задача. Петя, Вася и Маша остались дома одни. Кто-то из них ел варенье. На вопрос мамы, кто это сделал, они сказали: а) Петя: \u0026ldquo;Я не ел. Маша тоже не ела.\u0026rdquo; б) Вася: \u0026ldquo;Маша действительно не ела. Это сделал Петя\u0026rdquo; в) Маша: \u0026ldquo;Вася врет. Это он съел.\u0026rdquo;\nВыясните, кто ел варенье, если известно, что двое из них оба раза сказали правду, а третий один раз соврал, а один раз сказал правду.\n"});})();