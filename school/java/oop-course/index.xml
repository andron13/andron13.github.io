<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>02 - Введение в ООП on andron13</title><link>https://andron13.de/school/java/oop-course/</link><description>Recent content in 02 - Введение в ООП on andron13</description><generator>Hugo -- gohugo.io</generator><language>ru</language><lastBuildDate>Wed, 10 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://andron13.de/school/java/oop-course/index.xml" rel="self" type="application/rss+xml"/><item><title>StringBuffer, StringBuilder и String в чём отличие</title><link>https://andron13.de/school/java/oop-course/013-java-string-stringbuffer-stringbuilder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/013-java-string-stringbuffer-stringbuilder/</guid><description>#String, StringBuffer и StringBuilder — Java OPP 12
(В разработке)
Нас уже не должны пугать ключевые слова с большой буквы. Нам известны как минимум два из них String и Scanner. StringBuffer и StringBuilder родные братья уже давно изученного типа данных String.
Чем был плох String? # String всем прекрасен, только он неизменяем (immutable). И операции со строковыми величинами иногда дороги в потреблении ресурсов. Например, если мы в цикле изменяем строку добавляя к ней символы.</description></item><item><title>Java-OOP 11 - Обыкновенные дроби, НОД, НОК</title><link>https://andron13.de/school/java/oop-course/011-java-oop-practical-number-and-fraction/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/011-java-oop-practical-number-and-fraction/</guid><description>Мы уже не раз складывали два простых числа, две десятичные дроби или даже простое число с десятичной дробью. Однако мир состоит не только из примитивных данных, порой нам приходится работать и с дробями, с обыкновенными дробями.
Обыкновенные дроби # сложение дробей Обыкновенная дробь, как мы знаем из школы, состоит из двух частей: верхней и нижней. Это если не считать чёрточку посередине за часть дроби. Верхнюю часть дроби в математике принято называть числитель, а нижнюю часть знаменатель.</description></item><item><title>Java-OOP 02 - Перегрузка методов в Java Overloadin</title><link>https://andron13.de/school/java/oop-course/002-java-oop-method-overloading-polymorphism/</link><pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/002-java-oop-method-overloading-polymorphism/</guid><description>Перегрузка методов (Method Overloading) # В Java несколько методов из одного класса могут иметь одно название.
Одно название и несколько методов # Давайте сразу рассмотрим пример.
public class Calculator { public static int addition(int a, int b) { return a + b; } public static double addition(double a, double b) { return a + b; } } Очевидное-невероятное, но Java сама выбирает подходящий метод, для решения проблемы.Если мы передадим ей два int, то выберется первый метод, если два double, то JDK выберет самостоятельно нижний метод.</description></item><item><title>Java-OOP 03 - Конструктор в Java и ключевое слово this - введение в Java-OOP</title><link>https://andron13.de/school/java/oop-course/003-java-oop-constructor-this/</link><pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/003-java-oop-constructor-this/</guid><description>Конструктор в Java и ключевое слово this- введение в Java-OOP 003 # Стройка Создание объектов в Java часто сравнивает с обычной стройкой в жизни. И английский constructor и русский конструктор связаны со строительством напрямую.
Принципиально, конструктор - это просто метод. Просто метод который создаёт объекты. В связи с тем, что это очень важный метод и является краеугольным камнем всей парадигмы ООП, то у этого метода есть привилегия.</description></item><item><title>Java-OOP 04 - Инкапсуляция - encapsulation</title><link>https://andron13.de/school/java/oop-course/004-java-oop-encapsulation-get-set/</link><pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/004-java-oop-encapsulation-get-set/</guid><description>Инкапсуляция - encapsulation # В слове инкапсуляция корень капсула. Если мы спрячем в &amp;ldquo;капсулу&amp;rdquo; параметры объекта, то это и будет инкапсуляцией.
Инкапсуляция - encapsulation Зачем нужна инкапсуляция? # Во-первых, к некоторым параметрам не должно быть доступа ни у других программ, ни у пользователей, ни у (даже!) программистов. Например:
Поле день рождения в программе паспортного стола. Посмотреть его можно. Изменить нельзя. Это поле должно быть создано в месте с записью о человеке и позже его менять нельзя.</description></item><item><title>Java-OOP 05 - наследование - inheritance</title><link>https://andron13.de/school/java/oop-course/005-java-oop-inheritance/</link><pubDate>Fri, 06 Nov 2020 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/005-java-oop-inheritance/</guid><description>Наследование - inheritance # При разработке приложения для предприятия мы можем столкнуться с тем, что у различных профессий или должностей существуют различные параметры(поля класса) и поведение(методы).
Простейший пример университет. В нём есть студенты, преподаватели, научные и технические работники. У всех этих преподавателей должен быть пропуск. Например в зависимости от типа пропуска различные скидки в университетской столовой(например).
Давайте создадим класс Студента, Препода, и Работника.
public class Student { private String firstName; private String secondName; private String uniID; void study(){ } } public class Teacher { private String firstName; private String secondName; private String uniID; void teach(){ } } public class Worker { private String firstName; private String secondName; private String uniID; void work(){ } } На самой ранней стадии написания поля мы видим, что в нашем приложении будут 3 класса, которые содержат повторяющийся код.</description></item><item><title>Java-OOP 01 - Первые объекты</title><link>https://andron13.de/school/java/oop-course/001-java-object-introduction-chapter-1/</link><pubDate>Sun, 06 Sep 2020 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/001-java-object-introduction-chapter-1/</guid><description>Первые объекты в Java - введение в Java-OOP 001 # Введение в объектно-ориентированное программирование(Object-Oriented Programming) продолжает курс - Басовый курс Java.
Java является объектно-ориентированным языком. Хотя на сегодня в ООП умеют играть все популярные языки. Это новшество на конец прошлого века, сегодня уже добавлено даже в старые языки, изначально не поддерживающие ООП (например php, javascript).
ООП очень важная тема. И всё что было до этого было просто разминкой перед настоящей Java.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/006-java-oop-practical-methods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/006-java-oop-practical-methods/</guid><description>Глава, где мы попытаемся разобраться методами # Практическая реализация пройденного материала
Мы изучили процедурное(императивное) программирование и прошли уже пару глав объектно-ориентированного программирования. И это примерно то место, где мы должны сравнить и обобщить методы из одной парадигмы с другой. Есть ли между ними разница?
Если мы хотим найти сумму двух чисел, то в императивной парадигме метод выглядел примерно вот так:
public static int addition(int a, int b) { return a + b; } В ООП наш метод может выглядеть вот так:</description></item><item><title/><link>https://andron13.de/school/java/oop-course/007-java-oop-practical-arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/007-java-oop-practical-arrays/</guid><description>Naming a Package и массивы объектов # Практическая реализация пройденного материала
Огромное количество теоретического материала с теоретическими примерами плохо усваиваемы.
Давайте попробуем это исправить.
Я создам новый проект:
project . +-- src | +-- de | +-- andron13 | +-- application | +-- LibraryApp.java | +-- dao | +-- Library.java | +-- data | +-- Book.java +-- .gitignore +-- readme.md В файл readme.md обычно пишут о чём проект, как его запустить и кто его делал.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/008-java-oop-abstraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/008-java-oop-abstraction/</guid><description>Абстрактные классы и методы в Java # Иногда наши родственные объекты, которые наследованы от одного базового класса имеют разный подход к реализации методов. И часто во всех дочерних классах метод нужно переопределить.
Одна из парадигм ООП - схожее объединять. И эта парадигма может объединить и разные методы. Пример разных методов есть у домашних животных. Лошадка скачет, собачка бежит, птичка летит, рыбка плывёт. Метод движения нам нужен, потому что мы должны прописать передачу целевых координат и задать движение объекта.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/009-java-oop-association-aggregation-composition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/009-java-oop-association-aggregation-composition/</guid><description>Association, Aggregation and Composition # В ООП(не только в Java) помимо наследования различают ещё три связи между объектами:
Ассоциация Агрегация Композиция Наследование Агрегация - Aggregation # Мы говорим об агрегации, когда объект может быть частью нескольких составных объектов(компонентов). В этом случае полученный объект агрегирован. Срок службы деталей может быть больше, чем срок службы агрегата.
Примером агрегации являются взаимоотношения между футбольной командой и ее игроками. Человек может играть в нескольких командах, и если команда распущена, обычно это не означает конец для ее бывших игроков.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/010-java-oop-interface/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/010-java-oop-interface/</guid><description>https://javarush.ru/groups/posts/1981-dlja-chego-v-java-nuzhnih-interfeysih</description></item><item><title/><link>https://andron13.de/school/java/oop-course/012-java-oop-enum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/012-java-oop-enum/</guid><description>enum Level { LOW, MEDIUM, HIGH } Level myVar = Level.MEDIUM; enum Level { LOW, MEDIUM, HIGH } public class MyClass { public static void main(String[] args) { Level myVar = Level.MEDIUM; switch(myVar) { case LOW: System.out.println(&amp;#34;Low level&amp;#34;); break; case MEDIUM: System.out.println(&amp;#34;Medium level&amp;#34;); break; case HIGH: System.out.println(&amp;#34;High level&amp;#34;); break; } } } https://mkyong.com/java/java-enum-example/ https://www.w3schools.com/java/java_enums.asp https://javarush.ru/groups/posts/1963-kak-ispoljhzovatjh-klass-enum
public enum Gender { M(1), W(2), D(3); private int gend; private Gender(int gend) { this.gend = gend; } public int getGend() { return gend; } } https://javarush.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/014-java-oop-date/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/014-java-oop-date/</guid><description>Дата и время в Java # Прежде чем
Java и время: Пре
Date today = new Date(); System.out.println(today); Date dateStart = new Date(0); System.out.println(&amp;#34;dateStart &amp;#34; + dateStart); Date anotherDay = new Date(1_451_665_447_567L); System.out.println(&amp;#34;just anotherDay &amp;#34; + anotherDay); Date theEnd = new Date(Long.MAX_VALUE); System.out.println(theEnd); В итоге у нас получился вот такой вот класс, в котором мы поработали с некоторыми вариантами даты в Java.
import java.text.*; import java.time.*; import java.time.format.DateTimeFormatter; import java.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/015-java-practical-hashcode-equals-tostring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/015-java-practical-hashcode-equals-tostring/</guid><description/></item><item><title/><link>https://andron13.de/school/java/oop-course/016-java-oop-mutable-immutable-objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/016-java-oop-mutable-immutable-objects/</guid><description>Mutable vs Immutable Objects https://www.interviewcake.com/concept/java/mutable</description></item><item><title/><link>https://andron13.de/school/java/oop-course/017-java-oop-arraylist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/017-java-oop-arraylist/</guid><description>Java ArrayList - основы # При использовании массивов можно было заметить, что у них есть один минус - они конечны. Мы не можем расширить массив. При незапланированном увеличении элементов массива мы вынуждены создавать новый массив, так как массив не меняет своей длины.
Java предоставляет ArrayList, который решает эту и часть других ограничений обычного массива. Не надо считать эти ограничения массива его недостатками. Это просто особенности, которые надо учитывать.
На примере ниже можно посмотреть различия между способами хранения информации.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/035-java-formatter-systemoutprintf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/035-java-formatter-systemoutprintf/</guid><description>https://www.youtube.com/watch?v=IVcagooE5y4&amp;amp;list=PL71C6DFDDF73835C2&amp;amp;index=18</description></item><item><title/><link>https://andron13.de/school/java/oop-course/037-java-object-chapter-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/037-java-object-chapter-2/</guid><description>А запомнить нам поможет, то, что String тоже пишется с большой буквы, но как исключение из всех объектов инициализируется по упрощённой формуле. Вернее может, а может и по новой:
String helloWorld = new String(&amp;#34;Hello Java World!&amp;#34;) https://www.baeldung.com/java-string-pool
/**
BC12-Morning
16 18 : 25 */ public class Test { public static void main(String[] args) { String a = &amp;ldquo;Андрей&amp;rdquo;; String b = new String(&amp;ldquo;Андрей&amp;rdquo;); String e = new String(&amp;ldquo;Андрей&amp;rdquo;); String newE = e; boolean c = a.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/038-java-object-chapter-3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/038-java-object-chapter-3/</guid><description>Три ноги на которых стоит Java # Наследование - inheritance. https://vertex-academy.com/tutorials/ru/pravila-nasledovaniya-v-java/ Инкапсуляция - encapsulation. Полиморфизм - polymorphism. перегрузка - overloading. overriding Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным).
public class Person { private String name; private String firstName; public int age; public Person(String ln, String fn) { name = ln; firstName = fn; } public Person() { this(&amp;#34;Doe&amp;#34;, &amp;#34;John&amp;#34;); } public void setName(String ln, String fn) { name = ln; firstName = fn; } public String fullName() { return (name + &amp;#34; &amp;#34; + firstName); } } import java.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/040-java-uml-diagram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/040-java-uml-diagram/</guid><description>https://www.youtube.com/watch?v=ksvwF2sUjHM&amp;amp;list=PLBlnK6fEyqRjKA_NuK9mHmlk0dZzuP1P5&amp;amp;index=120</description></item><item><title/><link>https://andron13.de/school/java/oop-course/042-java-maven/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/042-java-maven/</guid><description>Java и Apache Maven — фреймворк для автоматизации сборки проектов # В предыдущем уроке мы собрали свою библиотеку и говорили о сборке своего собственного приложения. Хотя ни одного приложения ещё и не сделали.
Представьте, что мы до сих пор собирали телескоп, что бы посмотреть на звёзды. И вот собрав его мы теперь можем изучать планеты, звёзды, луну, солнце. С чего начать?
Примерно перед таким же выбором стою и я. Вы выучили основы и вам можно рассказывать всё.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/043-java-gradle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/043-java-gradle/</guid><description>Gradle - сборщик для Android &amp;amp; C # Мир программирования это мир конкуренции. Вопрос, почему придумали Gradle отвечается сам собой. Потому что програмисты тоже человеки. А человеки всегда находятся в поиске. И даже улучшение работы на пару процентов уже для многих может иметь решающее значение.
Gradle подходит к решению некоторых задач по другому чем Maven и активно используется многими фреймворками так же как и Maven на ваш выбор или даже безальтернативно - только Gradle.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/044-java-testing-junit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/044-java-testing-junit/</guid><description>JUnit - тестировние приложений в Java # В начале перед первым уроком я стоял перед выбором какую из &amp;ldquo;страшных&amp;rdquo; технологий, дать в самом начале и не говорить что они страшные. В итоге я решил, что Git та технология, которая даётся сложнее всего и в каждом уроке стоит немного уделять ему внимания. Потому что без написания код нельзя выучить методы работы с Git.
Однако существует ещё одна технология, которая невозможна сама по себе, она требует уже написанного кода.</description></item><item><title/><link>https://andron13.de/school/java/oop-course/050-bit-operation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://andron13.de/school/java/oop-course/050-bit-operation/</guid><description>https://javarush.ru/groups/posts/1925-pobitovihe-operacii
https://qna.habr.com/q/152931</description></item></channel></rss>